
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model exam_boards
 * 
 */
export type exam_boards = $Result.DefaultSelection<Prisma.$exam_boardsPayload>
/**
 * Model questions
 * 
 */
export type questions = $Result.DefaultSelection<Prisma.$questionsPayload>
/**
 * Model question_set_items
 * 
 */
export type question_set_items = $Result.DefaultSelection<Prisma.$question_set_itemsPayload>
/**
 * Model question_sets
 * 
 */
export type question_sets = $Result.DefaultSelection<Prisma.$question_setsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model subjects
 * 
 */
export type subjects = $Result.DefaultSelection<Prisma.$subjectsPayload>
/**
 * Model subtopics
 * 
 */
export type subtopics = $Result.DefaultSelection<Prisma.$subtopicsPayload>
/**
 * Model test_executions
 * 
 */
export type test_executions = $Result.DefaultSelection<Prisma.$test_executionsPayload>
/**
 * Model test_plan_question_sets
 * 
 */
export type test_plan_question_sets = $Result.DefaultSelection<Prisma.$test_plan_question_setsPayload>
/**
 * Model test_plans
 * 
 */
export type test_plans = $Result.DefaultSelection<Prisma.$test_plansPayload>
/**
 * Model test_templates
 * 
 */
export type test_templates = $Result.DefaultSelection<Prisma.$test_templatesPayload>
/**
 * Model topics
 * 
 */
export type topics = $Result.DefaultSelection<Prisma.$topicsPayload>
/**
 * Model user_roles
 * 
 */
export type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model difficulty_levels
 * 
 */
export type difficulty_levels = $Result.DefaultSelection<Prisma.$difficulty_levelsPayload>
/**
 * Model student_progress
 * 
 */
export type student_progress = $Result.DefaultSelection<Prisma.$student_progressPayload>
/**
 * Model achievements
 * 
 */
export type achievements = $Result.DefaultSelection<Prisma.$achievementsPayload>
/**
 * Model student_achievements
 * 
 */
export type student_achievements = $Result.DefaultSelection<Prisma.$student_achievementsPayload>
/**
 * Model rewards
 * 
 */
export type rewards = $Result.DefaultSelection<Prisma.$rewardsPayload>
/**
 * Model student_rewards
 * 
 */
export type student_rewards = $Result.DefaultSelection<Prisma.$student_rewardsPayload>
/**
 * Model subject_mastery
 * 
 */
export type subject_mastery = $Result.DefaultSelection<Prisma.$subject_masteryPayload>
/**
 * Model activity_log
 * 
 */
export type activity_log = $Result.DefaultSelection<Prisma.$activity_logPayload>
/**
 * Model level_config
 * 
 */
export type level_config = $Result.DefaultSelection<Prisma.$level_configPayload>
/**
 * Model study_groups
 * 
 */
export type study_groups = $Result.DefaultSelection<Prisma.$study_groupsPayload>
/**
 * Model student_guardians
 * 
 */
export type student_guardians = $Result.DefaultSelection<Prisma.$student_guardiansPayload>
/**
 * Model group_members
 * 
 */
export type group_members = $Result.DefaultSelection<Prisma.$group_membersPayload>
/**
 * Model test_assignments
 * 
 */
export type test_assignments = $Result.DefaultSelection<Prisma.$test_assignmentsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const exam_boards_input_type: {
  NUMERIC: 'NUMERIC',
  MCQ: 'MCQ'
};

export type exam_boards_input_type = (typeof exam_boards_input_type)[keyof typeof exam_boards_input_type]


export const test_executions_status: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED'
};

export type test_executions_status = (typeof test_executions_status)[keyof typeof test_executions_status]


export const test_plans_test_type: {
  TOPIC: 'TOPIC',
  MIXED: 'MIXED',
  MENTAL_ARITHMETIC: 'MENTAL_ARITHMETIC'
};

export type test_plans_test_type = (typeof test_plans_test_type)[keyof typeof test_plans_test_type]


export const test_plans_timing_type: {
  TIMED: 'TIMED',
  UNTIMED: 'UNTIMED'
};

export type test_plans_timing_type = (typeof test_plans_timing_type)[keyof typeof test_plans_timing_type]


export const test_templates_source: {
  SYSTEM: 'SYSTEM',
  USER: 'USER'
};

export type test_templates_source = (typeof test_templates_source)[keyof typeof test_templates_source]


export const test_templates_test_type: {
  TOPIC: 'TOPIC',
  MIXED: 'MIXED',
  MENTAL_ARITHMETIC: 'MENTAL_ARITHMETIC'
};

export type test_templates_test_type = (typeof test_templates_test_type)[keyof typeof test_templates_test_type]


export const test_templates_timing_type: {
  TIMED: 'TIMED',
  UNTIMED: 'UNTIMED'
};

export type test_templates_timing_type = (typeof test_templates_timing_type)[keyof typeof test_templates_timing_type]


export const GuardianRelationType: {
  PARENT: 'PARENT',
  TUTOR: 'TUTOR'
};

export type GuardianRelationType = (typeof GuardianRelationType)[keyof typeof GuardianRelationType]


export const GuardianRelationStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type GuardianRelationStatus = (typeof GuardianRelationStatus)[keyof typeof GuardianRelationStatus]


export const TestAssignmentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  OVERDUE: 'OVERDUE'
};

export type TestAssignmentStatus = (typeof TestAssignmentStatus)[keyof typeof TestAssignmentStatus]

}

export type exam_boards_input_type = $Enums.exam_boards_input_type

export const exam_boards_input_type: typeof $Enums.exam_boards_input_type

export type test_executions_status = $Enums.test_executions_status

export const test_executions_status: typeof $Enums.test_executions_status

export type test_plans_test_type = $Enums.test_plans_test_type

export const test_plans_test_type: typeof $Enums.test_plans_test_type

export type test_plans_timing_type = $Enums.test_plans_timing_type

export const test_plans_timing_type: typeof $Enums.test_plans_timing_type

export type test_templates_source = $Enums.test_templates_source

export const test_templates_source: typeof $Enums.test_templates_source

export type test_templates_test_type = $Enums.test_templates_test_type

export const test_templates_test_type: typeof $Enums.test_templates_test_type

export type test_templates_timing_type = $Enums.test_templates_timing_type

export const test_templates_timing_type: typeof $Enums.test_templates_timing_type

export type GuardianRelationType = $Enums.GuardianRelationType

export const GuardianRelationType: typeof $Enums.GuardianRelationType

export type GuardianRelationStatus = $Enums.GuardianRelationStatus

export const GuardianRelationStatus: typeof $Enums.GuardianRelationStatus

export type TestAssignmentStatus = $Enums.TestAssignmentStatus

export const TestAssignmentStatus: typeof $Enums.TestAssignmentStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Exam_boards
 * const exam_boards = await prisma.exam_boards.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Exam_boards
   * const exam_boards = await prisma.exam_boards.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.exam_boards`: Exposes CRUD operations for the **exam_boards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exam_boards
    * const exam_boards = await prisma.exam_boards.findMany()
    * ```
    */
  get exam_boards(): Prisma.exam_boardsDelegate<ExtArgs>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate<ExtArgs>;

  /**
   * `prisma.question_set_items`: Exposes CRUD operations for the **question_set_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Question_set_items
    * const question_set_items = await prisma.question_set_items.findMany()
    * ```
    */
  get question_set_items(): Prisma.question_set_itemsDelegate<ExtArgs>;

  /**
   * `prisma.question_sets`: Exposes CRUD operations for the **question_sets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Question_sets
    * const question_sets = await prisma.question_sets.findMany()
    * ```
    */
  get question_sets(): Prisma.question_setsDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.subjectsDelegate<ExtArgs>;

  /**
   * `prisma.subtopics`: Exposes CRUD operations for the **subtopics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtopics
    * const subtopics = await prisma.subtopics.findMany()
    * ```
    */
  get subtopics(): Prisma.subtopicsDelegate<ExtArgs>;

  /**
   * `prisma.test_executions`: Exposes CRUD operations for the **test_executions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_executions
    * const test_executions = await prisma.test_executions.findMany()
    * ```
    */
  get test_executions(): Prisma.test_executionsDelegate<ExtArgs>;

  /**
   * `prisma.test_plan_question_sets`: Exposes CRUD operations for the **test_plan_question_sets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_plan_question_sets
    * const test_plan_question_sets = await prisma.test_plan_question_sets.findMany()
    * ```
    */
  get test_plan_question_sets(): Prisma.test_plan_question_setsDelegate<ExtArgs>;

  /**
   * `prisma.test_plans`: Exposes CRUD operations for the **test_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_plans
    * const test_plans = await prisma.test_plans.findMany()
    * ```
    */
  get test_plans(): Prisma.test_plansDelegate<ExtArgs>;

  /**
   * `prisma.test_templates`: Exposes CRUD operations for the **test_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_templates
    * const test_templates = await prisma.test_templates.findMany()
    * ```
    */
  get test_templates(): Prisma.test_templatesDelegate<ExtArgs>;

  /**
   * `prisma.topics`: Exposes CRUD operations for the **topics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topics.findMany()
    * ```
    */
  get topics(): Prisma.topicsDelegate<ExtArgs>;

  /**
   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_roles.findMany()
    * ```
    */
  get user_roles(): Prisma.user_rolesDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.difficulty_levels`: Exposes CRUD operations for the **difficulty_levels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Difficulty_levels
    * const difficulty_levels = await prisma.difficulty_levels.findMany()
    * ```
    */
  get difficulty_levels(): Prisma.difficulty_levelsDelegate<ExtArgs>;

  /**
   * `prisma.student_progress`: Exposes CRUD operations for the **student_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_progresses
    * const student_progresses = await prisma.student_progress.findMany()
    * ```
    */
  get student_progress(): Prisma.student_progressDelegate<ExtArgs>;

  /**
   * `prisma.achievements`: Exposes CRUD operations for the **achievements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievements.findMany()
    * ```
    */
  get achievements(): Prisma.achievementsDelegate<ExtArgs>;

  /**
   * `prisma.student_achievements`: Exposes CRUD operations for the **student_achievements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_achievements
    * const student_achievements = await prisma.student_achievements.findMany()
    * ```
    */
  get student_achievements(): Prisma.student_achievementsDelegate<ExtArgs>;

  /**
   * `prisma.rewards`: Exposes CRUD operations for the **rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.rewards.findMany()
    * ```
    */
  get rewards(): Prisma.rewardsDelegate<ExtArgs>;

  /**
   * `prisma.student_rewards`: Exposes CRUD operations for the **student_rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_rewards
    * const student_rewards = await prisma.student_rewards.findMany()
    * ```
    */
  get student_rewards(): Prisma.student_rewardsDelegate<ExtArgs>;

  /**
   * `prisma.subject_mastery`: Exposes CRUD operations for the **subject_mastery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subject_masteries
    * const subject_masteries = await prisma.subject_mastery.findMany()
    * ```
    */
  get subject_mastery(): Prisma.subject_masteryDelegate<ExtArgs>;

  /**
   * `prisma.activity_log`: Exposes CRUD operations for the **activity_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activity_logs
    * const activity_logs = await prisma.activity_log.findMany()
    * ```
    */
  get activity_log(): Prisma.activity_logDelegate<ExtArgs>;

  /**
   * `prisma.level_config`: Exposes CRUD operations for the **level_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Level_configs
    * const level_configs = await prisma.level_config.findMany()
    * ```
    */
  get level_config(): Prisma.level_configDelegate<ExtArgs>;

  /**
   * `prisma.study_groups`: Exposes CRUD operations for the **study_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_groups
    * const study_groups = await prisma.study_groups.findMany()
    * ```
    */
  get study_groups(): Prisma.study_groupsDelegate<ExtArgs>;

  /**
   * `prisma.student_guardians`: Exposes CRUD operations for the **student_guardians** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_guardians
    * const student_guardians = await prisma.student_guardians.findMany()
    * ```
    */
  get student_guardians(): Prisma.student_guardiansDelegate<ExtArgs>;

  /**
   * `prisma.group_members`: Exposes CRUD operations for the **group_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_members
    * const group_members = await prisma.group_members.findMany()
    * ```
    */
  get group_members(): Prisma.group_membersDelegate<ExtArgs>;

  /**
   * `prisma.test_assignments`: Exposes CRUD operations for the **test_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_assignments
    * const test_assignments = await prisma.test_assignments.findMany()
    * ```
    */
  get test_assignments(): Prisma.test_assignmentsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    exam_boards: 'exam_boards',
    questions: 'questions',
    question_set_items: 'question_set_items',
    question_sets: 'question_sets',
    roles: 'roles',
    subjects: 'subjects',
    subtopics: 'subtopics',
    test_executions: 'test_executions',
    test_plan_question_sets: 'test_plan_question_sets',
    test_plans: 'test_plans',
    test_templates: 'test_templates',
    topics: 'topics',
    user_roles: 'user_roles',
    users: 'users',
    difficulty_levels: 'difficulty_levels',
    student_progress: 'student_progress',
    achievements: 'achievements',
    student_achievements: 'student_achievements',
    rewards: 'rewards',
    student_rewards: 'student_rewards',
    subject_mastery: 'subject_mastery',
    activity_log: 'activity_log',
    level_config: 'level_config',
    study_groups: 'study_groups',
    student_guardians: 'student_guardians',
    group_members: 'group_members',
    test_assignments: 'test_assignments'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "exam_boards" | "questions" | "question_set_items" | "question_sets" | "roles" | "subjects" | "subtopics" | "test_executions" | "test_plan_question_sets" | "test_plans" | "test_templates" | "topics" | "user_roles" | "users" | "difficulty_levels" | "student_progress" | "achievements" | "student_achievements" | "rewards" | "student_rewards" | "subject_mastery" | "activity_log" | "level_config" | "study_groups" | "student_guardians" | "group_members" | "test_assignments"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      exam_boards: {
        payload: Prisma.$exam_boardsPayload<ExtArgs>
        fields: Prisma.exam_boardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exam_boardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exam_boardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>
          }
          findFirst: {
            args: Prisma.exam_boardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exam_boardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>
          }
          findMany: {
            args: Prisma.exam_boardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>[]
          }
          create: {
            args: Prisma.exam_boardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>
          }
          createMany: {
            args: Prisma.exam_boardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.exam_boardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>
          }
          update: {
            args: Prisma.exam_boardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>
          }
          deleteMany: {
            args: Prisma.exam_boardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exam_boardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.exam_boardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exam_boardsPayload>
          }
          aggregate: {
            args: Prisma.Exam_boardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam_boards>
          }
          groupBy: {
            args: Prisma.exam_boardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Exam_boardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.exam_boardsCountArgs<ExtArgs>
            result: $Utils.Optional<Exam_boardsCountAggregateOutputType> | number
          }
        }
      }
      questions: {
        payload: Prisma.$questionsPayload<ExtArgs>
        fields: Prisma.questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findFirst: {
            args: Prisma.questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findMany: {
            args: Prisma.questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          create: {
            args: Prisma.questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          createMany: {
            args: Prisma.questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          update: {
            args: Prisma.questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          deleteMany: {
            args: Prisma.questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      question_set_items: {
        payload: Prisma.$question_set_itemsPayload<ExtArgs>
        fields: Prisma.question_set_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.question_set_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.question_set_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>
          }
          findFirst: {
            args: Prisma.question_set_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.question_set_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>
          }
          findMany: {
            args: Prisma.question_set_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>[]
          }
          create: {
            args: Prisma.question_set_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>
          }
          createMany: {
            args: Prisma.question_set_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.question_set_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>
          }
          update: {
            args: Prisma.question_set_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>
          }
          deleteMany: {
            args: Prisma.question_set_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.question_set_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.question_set_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_set_itemsPayload>
          }
          aggregate: {
            args: Prisma.Question_set_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion_set_items>
          }
          groupBy: {
            args: Prisma.question_set_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Question_set_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.question_set_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Question_set_itemsCountAggregateOutputType> | number
          }
        }
      }
      question_sets: {
        payload: Prisma.$question_setsPayload<ExtArgs>
        fields: Prisma.question_setsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.question_setsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.question_setsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>
          }
          findFirst: {
            args: Prisma.question_setsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.question_setsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>
          }
          findMany: {
            args: Prisma.question_setsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>[]
          }
          create: {
            args: Prisma.question_setsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>
          }
          createMany: {
            args: Prisma.question_setsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.question_setsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>
          }
          update: {
            args: Prisma.question_setsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>
          }
          deleteMany: {
            args: Prisma.question_setsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.question_setsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.question_setsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_setsPayload>
          }
          aggregate: {
            args: Prisma.Question_setsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion_sets>
          }
          groupBy: {
            args: Prisma.question_setsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Question_setsGroupByOutputType>[]
          }
          count: {
            args: Prisma.question_setsCountArgs<ExtArgs>
            result: $Utils.Optional<Question_setsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      subjects: {
        payload: Prisma.$subjectsPayload<ExtArgs>
        fields: Prisma.subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findFirst: {
            args: Prisma.subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findMany: {
            args: Prisma.subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          create: {
            args: Prisma.subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          createMany: {
            args: Prisma.subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          update: {
            args: Prisma.subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          deleteMany: {
            args: Prisma.subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      subtopics: {
        payload: Prisma.$subtopicsPayload<ExtArgs>
        fields: Prisma.subtopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subtopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subtopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>
          }
          findFirst: {
            args: Prisma.subtopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subtopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>
          }
          findMany: {
            args: Prisma.subtopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>[]
          }
          create: {
            args: Prisma.subtopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>
          }
          createMany: {
            args: Prisma.subtopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subtopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>
          }
          update: {
            args: Prisma.subtopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>
          }
          deleteMany: {
            args: Prisma.subtopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subtopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subtopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subtopicsPayload>
          }
          aggregate: {
            args: Prisma.SubtopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtopics>
          }
          groupBy: {
            args: Prisma.subtopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subtopicsCountArgs<ExtArgs>
            result: $Utils.Optional<SubtopicsCountAggregateOutputType> | number
          }
        }
      }
      test_executions: {
        payload: Prisma.$test_executionsPayload<ExtArgs>
        fields: Prisma.test_executionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_executionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_executionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>
          }
          findFirst: {
            args: Prisma.test_executionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_executionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>
          }
          findMany: {
            args: Prisma.test_executionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>[]
          }
          create: {
            args: Prisma.test_executionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>
          }
          createMany: {
            args: Prisma.test_executionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_executionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>
          }
          update: {
            args: Prisma.test_executionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>
          }
          deleteMany: {
            args: Prisma.test_executionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_executionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_executionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_executionsPayload>
          }
          aggregate: {
            args: Prisma.Test_executionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_executions>
          }
          groupBy: {
            args: Prisma.test_executionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_executionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_executionsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_executionsCountAggregateOutputType> | number
          }
        }
      }
      test_plan_question_sets: {
        payload: Prisma.$test_plan_question_setsPayload<ExtArgs>
        fields: Prisma.test_plan_question_setsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_plan_question_setsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_plan_question_setsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>
          }
          findFirst: {
            args: Prisma.test_plan_question_setsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_plan_question_setsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>
          }
          findMany: {
            args: Prisma.test_plan_question_setsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>[]
          }
          create: {
            args: Prisma.test_plan_question_setsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>
          }
          createMany: {
            args: Prisma.test_plan_question_setsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_plan_question_setsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>
          }
          update: {
            args: Prisma.test_plan_question_setsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>
          }
          deleteMany: {
            args: Prisma.test_plan_question_setsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_plan_question_setsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_plan_question_setsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_question_setsPayload>
          }
          aggregate: {
            args: Prisma.Test_plan_question_setsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_plan_question_sets>
          }
          groupBy: {
            args: Prisma.test_plan_question_setsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_plan_question_setsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_plan_question_setsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_plan_question_setsCountAggregateOutputType> | number
          }
        }
      }
      test_plans: {
        payload: Prisma.$test_plansPayload<ExtArgs>
        fields: Prisma.test_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          findFirst: {
            args: Prisma.test_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          findMany: {
            args: Prisma.test_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>[]
          }
          create: {
            args: Prisma.test_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          createMany: {
            args: Prisma.test_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          update: {
            args: Prisma.test_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          deleteMany: {
            args: Prisma.test_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          aggregate: {
            args: Prisma.Test_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_plans>
          }
          groupBy: {
            args: Prisma.test_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Test_plansCountAggregateOutputType> | number
          }
        }
      }
      test_templates: {
        payload: Prisma.$test_templatesPayload<ExtArgs>
        fields: Prisma.test_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>
          }
          findFirst: {
            args: Prisma.test_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>
          }
          findMany: {
            args: Prisma.test_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>[]
          }
          create: {
            args: Prisma.test_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>
          }
          createMany: {
            args: Prisma.test_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>
          }
          update: {
            args: Prisma.test_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>
          }
          deleteMany: {
            args: Prisma.test_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_templatesPayload>
          }
          aggregate: {
            args: Prisma.Test_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_templates>
          }
          groupBy: {
            args: Prisma.test_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Test_templatesCountAggregateOutputType> | number
          }
        }
      }
      topics: {
        payload: Prisma.$topicsPayload<ExtArgs>
        fields: Prisma.topicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.topicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.topicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>
          }
          findFirst: {
            args: Prisma.topicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.topicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>
          }
          findMany: {
            args: Prisma.topicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>[]
          }
          create: {
            args: Prisma.topicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>
          }
          createMany: {
            args: Prisma.topicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.topicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>
          }
          update: {
            args: Prisma.topicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>
          }
          deleteMany: {
            args: Prisma.topicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.topicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.topicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$topicsPayload>
          }
          aggregate: {
            args: Prisma.TopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopics>
          }
          groupBy: {
            args: Prisma.topicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.topicsCountArgs<ExtArgs>
            result: $Utils.Optional<TopicsCountAggregateOutputType> | number
          }
        }
      }
      user_roles: {
        payload: Prisma.$user_rolesPayload<ExtArgs>
        fields: Prisma.user_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findFirst: {
            args: Prisma.user_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findMany: {
            args: Prisma.user_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          create: {
            args: Prisma.user_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          createMany: {
            args: Prisma.user_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          update: {
            args: Prisma.user_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          deleteMany: {
            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          aggregate: {
            args: Prisma.User_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_roles>
          }
          groupBy: {
            args: Prisma.user_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      difficulty_levels: {
        payload: Prisma.$difficulty_levelsPayload<ExtArgs>
        fields: Prisma.difficulty_levelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.difficulty_levelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.difficulty_levelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>
          }
          findFirst: {
            args: Prisma.difficulty_levelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.difficulty_levelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>
          }
          findMany: {
            args: Prisma.difficulty_levelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>[]
          }
          create: {
            args: Prisma.difficulty_levelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>
          }
          createMany: {
            args: Prisma.difficulty_levelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.difficulty_levelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>
          }
          update: {
            args: Prisma.difficulty_levelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>
          }
          deleteMany: {
            args: Prisma.difficulty_levelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.difficulty_levelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.difficulty_levelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$difficulty_levelsPayload>
          }
          aggregate: {
            args: Prisma.Difficulty_levelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDifficulty_levels>
          }
          groupBy: {
            args: Prisma.difficulty_levelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Difficulty_levelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.difficulty_levelsCountArgs<ExtArgs>
            result: $Utils.Optional<Difficulty_levelsCountAggregateOutputType> | number
          }
        }
      }
      student_progress: {
        payload: Prisma.$student_progressPayload<ExtArgs>
        fields: Prisma.student_progressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_progressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_progressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>
          }
          findFirst: {
            args: Prisma.student_progressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_progressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>
          }
          findMany: {
            args: Prisma.student_progressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>[]
          }
          create: {
            args: Prisma.student_progressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>
          }
          createMany: {
            args: Prisma.student_progressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_progressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>
          }
          update: {
            args: Prisma.student_progressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>
          }
          deleteMany: {
            args: Prisma.student_progressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_progressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_progressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_progressPayload>
          }
          aggregate: {
            args: Prisma.Student_progressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_progress>
          }
          groupBy: {
            args: Prisma.student_progressGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_progressGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_progressCountArgs<ExtArgs>
            result: $Utils.Optional<Student_progressCountAggregateOutputType> | number
          }
        }
      }
      achievements: {
        payload: Prisma.$achievementsPayload<ExtArgs>
        fields: Prisma.achievementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.achievementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.achievementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>
          }
          findFirst: {
            args: Prisma.achievementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.achievementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>
          }
          findMany: {
            args: Prisma.achievementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>[]
          }
          create: {
            args: Prisma.achievementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>
          }
          createMany: {
            args: Prisma.achievementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.achievementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>
          }
          update: {
            args: Prisma.achievementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>
          }
          deleteMany: {
            args: Prisma.achievementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.achievementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.achievementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementsPayload>
          }
          aggregate: {
            args: Prisma.AchievementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievements>
          }
          groupBy: {
            args: Prisma.achievementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.achievementsCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementsCountAggregateOutputType> | number
          }
        }
      }
      student_achievements: {
        payload: Prisma.$student_achievementsPayload<ExtArgs>
        fields: Prisma.student_achievementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_achievementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_achievementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>
          }
          findFirst: {
            args: Prisma.student_achievementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_achievementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>
          }
          findMany: {
            args: Prisma.student_achievementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>[]
          }
          create: {
            args: Prisma.student_achievementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>
          }
          createMany: {
            args: Prisma.student_achievementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_achievementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>
          }
          update: {
            args: Prisma.student_achievementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>
          }
          deleteMany: {
            args: Prisma.student_achievementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_achievementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_achievementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_achievementsPayload>
          }
          aggregate: {
            args: Prisma.Student_achievementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_achievements>
          }
          groupBy: {
            args: Prisma.student_achievementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_achievementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_achievementsCountArgs<ExtArgs>
            result: $Utils.Optional<Student_achievementsCountAggregateOutputType> | number
          }
        }
      }
      rewards: {
        payload: Prisma.$rewardsPayload<ExtArgs>
        fields: Prisma.rewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          findFirst: {
            args: Prisma.rewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          findMany: {
            args: Prisma.rewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>[]
          }
          create: {
            args: Prisma.rewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          createMany: {
            args: Prisma.rewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          update: {
            args: Prisma.rewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          deleteMany: {
            args: Prisma.rewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          aggregate: {
            args: Prisma.RewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewards>
          }
          groupBy: {
            args: Prisma.rewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rewardsCountArgs<ExtArgs>
            result: $Utils.Optional<RewardsCountAggregateOutputType> | number
          }
        }
      }
      student_rewards: {
        payload: Prisma.$student_rewardsPayload<ExtArgs>
        fields: Prisma.student_rewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_rewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_rewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>
          }
          findFirst: {
            args: Prisma.student_rewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_rewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>
          }
          findMany: {
            args: Prisma.student_rewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>[]
          }
          create: {
            args: Prisma.student_rewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>
          }
          createMany: {
            args: Prisma.student_rewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_rewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>
          }
          update: {
            args: Prisma.student_rewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>
          }
          deleteMany: {
            args: Prisma.student_rewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_rewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_rewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_rewardsPayload>
          }
          aggregate: {
            args: Prisma.Student_rewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_rewards>
          }
          groupBy: {
            args: Prisma.student_rewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_rewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_rewardsCountArgs<ExtArgs>
            result: $Utils.Optional<Student_rewardsCountAggregateOutputType> | number
          }
        }
      }
      subject_mastery: {
        payload: Prisma.$subject_masteryPayload<ExtArgs>
        fields: Prisma.subject_masteryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subject_masteryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subject_masteryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>
          }
          findFirst: {
            args: Prisma.subject_masteryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subject_masteryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>
          }
          findMany: {
            args: Prisma.subject_masteryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>[]
          }
          create: {
            args: Prisma.subject_masteryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>
          }
          createMany: {
            args: Prisma.subject_masteryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subject_masteryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>
          }
          update: {
            args: Prisma.subject_masteryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>
          }
          deleteMany: {
            args: Prisma.subject_masteryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subject_masteryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subject_masteryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_masteryPayload>
          }
          aggregate: {
            args: Prisma.Subject_masteryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject_mastery>
          }
          groupBy: {
            args: Prisma.subject_masteryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Subject_masteryGroupByOutputType>[]
          }
          count: {
            args: Prisma.subject_masteryCountArgs<ExtArgs>
            result: $Utils.Optional<Subject_masteryCountAggregateOutputType> | number
          }
        }
      }
      activity_log: {
        payload: Prisma.$activity_logPayload<ExtArgs>
        fields: Prisma.activity_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activity_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activity_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>
          }
          findFirst: {
            args: Prisma.activity_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activity_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>
          }
          findMany: {
            args: Prisma.activity_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>[]
          }
          create: {
            args: Prisma.activity_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>
          }
          createMany: {
            args: Prisma.activity_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.activity_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>
          }
          update: {
            args: Prisma.activity_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>
          }
          deleteMany: {
            args: Prisma.activity_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activity_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.activity_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logPayload>
          }
          aggregate: {
            args: Prisma.Activity_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity_log>
          }
          groupBy: {
            args: Prisma.activity_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Activity_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.activity_logCountArgs<ExtArgs>
            result: $Utils.Optional<Activity_logCountAggregateOutputType> | number
          }
        }
      }
      level_config: {
        payload: Prisma.$level_configPayload<ExtArgs>
        fields: Prisma.level_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.level_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.level_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>
          }
          findFirst: {
            args: Prisma.level_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.level_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>
          }
          findMany: {
            args: Prisma.level_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>[]
          }
          create: {
            args: Prisma.level_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>
          }
          createMany: {
            args: Prisma.level_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.level_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>
          }
          update: {
            args: Prisma.level_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>
          }
          deleteMany: {
            args: Prisma.level_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.level_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.level_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$level_configPayload>
          }
          aggregate: {
            args: Prisma.Level_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel_config>
          }
          groupBy: {
            args: Prisma.level_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Level_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.level_configCountArgs<ExtArgs>
            result: $Utils.Optional<Level_configCountAggregateOutputType> | number
          }
        }
      }
      study_groups: {
        payload: Prisma.$study_groupsPayload<ExtArgs>
        fields: Prisma.study_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>
          }
          findFirst: {
            args: Prisma.study_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>
          }
          findMany: {
            args: Prisma.study_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>[]
          }
          create: {
            args: Prisma.study_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>
          }
          createMany: {
            args: Prisma.study_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>
          }
          update: {
            args: Prisma.study_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>
          }
          deleteMany: {
            args: Prisma.study_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_groupsPayload>
          }
          aggregate: {
            args: Prisma.Study_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_groups>
          }
          groupBy: {
            args: Prisma.study_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Study_groupsCountAggregateOutputType> | number
          }
        }
      }
      student_guardians: {
        payload: Prisma.$student_guardiansPayload<ExtArgs>
        fields: Prisma.student_guardiansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_guardiansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_guardiansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>
          }
          findFirst: {
            args: Prisma.student_guardiansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_guardiansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>
          }
          findMany: {
            args: Prisma.student_guardiansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>[]
          }
          create: {
            args: Prisma.student_guardiansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>
          }
          createMany: {
            args: Prisma.student_guardiansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_guardiansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>
          }
          update: {
            args: Prisma.student_guardiansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>
          }
          deleteMany: {
            args: Prisma.student_guardiansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_guardiansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_guardiansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_guardiansPayload>
          }
          aggregate: {
            args: Prisma.Student_guardiansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_guardians>
          }
          groupBy: {
            args: Prisma.student_guardiansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_guardiansGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_guardiansCountArgs<ExtArgs>
            result: $Utils.Optional<Student_guardiansCountAggregateOutputType> | number
          }
        }
      }
      group_members: {
        payload: Prisma.$group_membersPayload<ExtArgs>
        fields: Prisma.group_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_membersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_membersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>
          }
          findFirst: {
            args: Prisma.group_membersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_membersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>
          }
          findMany: {
            args: Prisma.group_membersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>[]
          }
          create: {
            args: Prisma.group_membersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>
          }
          createMany: {
            args: Prisma.group_membersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.group_membersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>
          }
          update: {
            args: Prisma.group_membersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>
          }
          deleteMany: {
            args: Prisma.group_membersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_membersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.group_membersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_membersPayload>
          }
          aggregate: {
            args: Prisma.Group_membersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_members>
          }
          groupBy: {
            args: Prisma.group_membersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_membersCountArgs<ExtArgs>
            result: $Utils.Optional<Group_membersCountAggregateOutputType> | number
          }
        }
      }
      test_assignments: {
        payload: Prisma.$test_assignmentsPayload<ExtArgs>
        fields: Prisma.test_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.test_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>
          }
          findMany: {
            args: Prisma.test_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>[]
          }
          create: {
            args: Prisma.test_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>
          }
          createMany: {
            args: Prisma.test_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>
          }
          update: {
            args: Prisma.test_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.test_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.Test_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_assignments>
          }
          groupBy: {
            args: Prisma.test_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_assignmentsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Exam_boardsCountOutputType
   */

  export type Exam_boardsCountOutputType = {
    test_plans: number
    test_templates: number
  }

  export type Exam_boardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plans?: boolean | Exam_boardsCountOutputTypeCountTest_plansArgs
    test_templates?: boolean | Exam_boardsCountOutputTypeCountTest_templatesArgs
  }

  // Custom InputTypes
  /**
   * Exam_boardsCountOutputType without action
   */
  export type Exam_boardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam_boardsCountOutputType
     */
    select?: Exam_boardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Exam_boardsCountOutputType without action
   */
  export type Exam_boardsCountOutputTypeCountTest_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
  }

  /**
   * Exam_boardsCountOutputType without action
   */
  export type Exam_boardsCountOutputTypeCountTest_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_templatesWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    question_set_items: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_set_items?: boolean | QuestionsCountOutputTypeCountQuestion_set_itemsArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestion_set_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_set_itemsWhereInput
  }


  /**
   * Count Type Question_setsCountOutputType
   */

  export type Question_setsCountOutputType = {
    question_set_items: number
    test_plan_links: number
  }

  export type Question_setsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_set_items?: boolean | Question_setsCountOutputTypeCountQuestion_set_itemsArgs
    test_plan_links?: boolean | Question_setsCountOutputTypeCountTest_plan_linksArgs
  }

  // Custom InputTypes
  /**
   * Question_setsCountOutputType without action
   */
  export type Question_setsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question_setsCountOutputType
     */
    select?: Question_setsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Question_setsCountOutputType without action
   */
  export type Question_setsCountOutputTypeCountQuestion_set_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_set_itemsWhereInput
  }

  /**
   * Question_setsCountOutputType without action
   */
  export type Question_setsCountOutputTypeCountTest_plan_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_question_setsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    user_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | RolesCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    topics: number
    subject_mastery: number
    difficulty_levels: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | SubjectsCountOutputTypeCountTopicsArgs
    subject_mastery?: boolean | SubjectsCountOutputTypeCountSubject_masteryArgs
    difficulty_levels?: boolean | SubjectsCountOutputTypeCountDifficulty_levelsArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: topicsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountSubject_masteryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_masteryWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountDifficulty_levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: difficulty_levelsWhereInput
  }


  /**
   * Count Type SubtopicsCountOutputType
   */

  export type SubtopicsCountOutputType = {
    questions: number
  }

  export type SubtopicsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | SubtopicsCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * SubtopicsCountOutputType without action
   */
  export type SubtopicsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtopicsCountOutputType
     */
    select?: SubtopicsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubtopicsCountOutputType without action
   */
  export type SubtopicsCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type Test_plansCountOutputType
   */

  export type Test_plansCountOutputType = {
    test_executions: number
    study_groups: number
    assignments: number
    question_set_links: number
  }

  export type Test_plansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_executions?: boolean | Test_plansCountOutputTypeCountTest_executionsArgs
    study_groups?: boolean | Test_plansCountOutputTypeCountStudy_groupsArgs
    assignments?: boolean | Test_plansCountOutputTypeCountAssignmentsArgs
    question_set_links?: boolean | Test_plansCountOutputTypeCountQuestion_set_linksArgs
  }

  // Custom InputTypes
  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_plansCountOutputType
     */
    select?: Test_plansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeCountTest_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_executionsWhereInput
  }

  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeCountStudy_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_groupsWhereInput
  }

  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_assignmentsWhereInput
  }

  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeCountQuestion_set_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_question_setsWhereInput
  }


  /**
   * Count Type Test_templatesCountOutputType
   */

  export type Test_templatesCountOutputType = {
    test_plans: number
  }

  export type Test_templatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plans?: boolean | Test_templatesCountOutputTypeCountTest_plansArgs
  }

  // Custom InputTypes
  /**
   * Test_templatesCountOutputType without action
   */
  export type Test_templatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_templatesCountOutputType
     */
    select?: Test_templatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_templatesCountOutputType without action
   */
  export type Test_templatesCountOutputTypeCountTest_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
  }


  /**
   * Count Type TopicsCountOutputType
   */

  export type TopicsCountOutputType = {
    subtopics: number
  }

  export type TopicsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtopics?: boolean | TopicsCountOutputTypeCountSubtopicsArgs
  }

  // Custom InputTypes
  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicsCountOutputType
     */
    select?: TopicsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeCountSubtopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subtopicsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    questions: number
    created_question_sets: number
    test_executions: number
    assigned_test_plans: number
    planned_test_plans: number
    test_templates: number
    user_roles: number
    achievements_earned: number
    tutor_groups: number
    student_groups: number
    group_memberships: number
    subject_mastery: number
    activity_logs: number
    student_rewards: number
    guardian_relationships: number
    student_relationships: number
    assignments_created: number
    assignments_received: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | UsersCountOutputTypeCountQuestionsArgs
    created_question_sets?: boolean | UsersCountOutputTypeCountCreated_question_setsArgs
    test_executions?: boolean | UsersCountOutputTypeCountTest_executionsArgs
    assigned_test_plans?: boolean | UsersCountOutputTypeCountAssigned_test_plansArgs
    planned_test_plans?: boolean | UsersCountOutputTypeCountPlanned_test_plansArgs
    test_templates?: boolean | UsersCountOutputTypeCountTest_templatesArgs
    user_roles?: boolean | UsersCountOutputTypeCountUser_rolesArgs
    achievements_earned?: boolean | UsersCountOutputTypeCountAchievements_earnedArgs
    tutor_groups?: boolean | UsersCountOutputTypeCountTutor_groupsArgs
    student_groups?: boolean | UsersCountOutputTypeCountStudent_groupsArgs
    group_memberships?: boolean | UsersCountOutputTypeCountGroup_membershipsArgs
    subject_mastery?: boolean | UsersCountOutputTypeCountSubject_masteryArgs
    activity_logs?: boolean | UsersCountOutputTypeCountActivity_logsArgs
    student_rewards?: boolean | UsersCountOutputTypeCountStudent_rewardsArgs
    guardian_relationships?: boolean | UsersCountOutputTypeCountGuardian_relationshipsArgs
    student_relationships?: boolean | UsersCountOutputTypeCountStudent_relationshipsArgs
    assignments_created?: boolean | UsersCountOutputTypeCountAssignments_createdArgs
    assignments_received?: boolean | UsersCountOutputTypeCountAssignments_receivedArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreated_question_setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_setsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTest_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_executionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAssigned_test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPlanned_test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTest_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_templatesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAchievements_earnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_achievementsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTutor_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_groupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStudent_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_groupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGroup_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_membersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSubject_masteryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_masteryWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountActivity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activity_logWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStudent_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_rewardsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGuardian_relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_guardiansWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStudent_relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_guardiansWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAssignments_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_assignmentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAssignments_receivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_assignmentsWhereInput
  }


  /**
   * Count Type AchievementsCountOutputType
   */

  export type AchievementsCountOutputType = {
    student_achievements: number
  }

  export type AchievementsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_achievements?: boolean | AchievementsCountOutputTypeCountStudent_achievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementsCountOutputType without action
   */
  export type AchievementsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsCountOutputType
     */
    select?: AchievementsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementsCountOutputType without action
   */
  export type AchievementsCountOutputTypeCountStudent_achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_achievementsWhereInput
  }


  /**
   * Count Type RewardsCountOutputType
   */

  export type RewardsCountOutputType = {
    student_rewards: number
  }

  export type RewardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_rewards?: boolean | RewardsCountOutputTypeCountStudent_rewardsArgs
  }

  // Custom InputTypes
  /**
   * RewardsCountOutputType without action
   */
  export type RewardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardsCountOutputType
     */
    select?: RewardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RewardsCountOutputType without action
   */
  export type RewardsCountOutputTypeCountStudent_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_rewardsWhereInput
  }


  /**
   * Count Type Study_groupsCountOutputType
   */

  export type Study_groupsCountOutputType = {
    students: number
    members: number
    assignments: number
    test_plans: number
  }

  export type Study_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | Study_groupsCountOutputTypeCountStudentsArgs
    members?: boolean | Study_groupsCountOutputTypeCountMembersArgs
    assignments?: boolean | Study_groupsCountOutputTypeCountAssignmentsArgs
    test_plans?: boolean | Study_groupsCountOutputTypeCountTest_plansArgs
  }

  // Custom InputTypes
  /**
   * Study_groupsCountOutputType without action
   */
  export type Study_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study_groupsCountOutputType
     */
    select?: Study_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Study_groupsCountOutputType without action
   */
  export type Study_groupsCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * Study_groupsCountOutputType without action
   */
  export type Study_groupsCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_membersWhereInput
  }

  /**
   * Study_groupsCountOutputType without action
   */
  export type Study_groupsCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_assignmentsWhereInput
  }

  /**
   * Study_groupsCountOutputType without action
   */
  export type Study_groupsCountOutputTypeCountTest_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
  }


  /**
   * Models
   */

  /**
   * Model exam_boards
   */

  export type AggregateExam_boards = {
    _count: Exam_boardsCountAggregateOutputType | null
    _avg: Exam_boardsAvgAggregateOutputType | null
    _sum: Exam_boardsSumAggregateOutputType | null
    _min: Exam_boardsMinAggregateOutputType | null
    _max: Exam_boardsMaxAggregateOutputType | null
  }

  export type Exam_boardsAvgAggregateOutputType = {
    board_id: number | null
  }

  export type Exam_boardsSumAggregateOutputType = {
    board_id: number | null
  }

  export type Exam_boardsMinAggregateOutputType = {
    board_id: number | null
    board_name: string | null
    description: string | null
    input_type: $Enums.exam_boards_input_type | null
  }

  export type Exam_boardsMaxAggregateOutputType = {
    board_id: number | null
    board_name: string | null
    description: string | null
    input_type: $Enums.exam_boards_input_type | null
  }

  export type Exam_boardsCountAggregateOutputType = {
    board_id: number
    board_name: number
    description: number
    input_type: number
    _all: number
  }


  export type Exam_boardsAvgAggregateInputType = {
    board_id?: true
  }

  export type Exam_boardsSumAggregateInputType = {
    board_id?: true
  }

  export type Exam_boardsMinAggregateInputType = {
    board_id?: true
    board_name?: true
    description?: true
    input_type?: true
  }

  export type Exam_boardsMaxAggregateInputType = {
    board_id?: true
    board_name?: true
    description?: true
    input_type?: true
  }

  export type Exam_boardsCountAggregateInputType = {
    board_id?: true
    board_name?: true
    description?: true
    input_type?: true
    _all?: true
  }

  export type Exam_boardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exam_boards to aggregate.
     */
    where?: exam_boardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_boards to fetch.
     */
    orderBy?: exam_boardsOrderByWithRelationInput | exam_boardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exam_boardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exam_boards
    **/
    _count?: true | Exam_boardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exam_boardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exam_boardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exam_boardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exam_boardsMaxAggregateInputType
  }

  export type GetExam_boardsAggregateType<T extends Exam_boardsAggregateArgs> = {
        [P in keyof T & keyof AggregateExam_boards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam_boards[P]>
      : GetScalarType<T[P], AggregateExam_boards[P]>
  }




  export type exam_boardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exam_boardsWhereInput
    orderBy?: exam_boardsOrderByWithAggregationInput | exam_boardsOrderByWithAggregationInput[]
    by: Exam_boardsScalarFieldEnum[] | Exam_boardsScalarFieldEnum
    having?: exam_boardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exam_boardsCountAggregateInputType | true
    _avg?: Exam_boardsAvgAggregateInputType
    _sum?: Exam_boardsSumAggregateInputType
    _min?: Exam_boardsMinAggregateInputType
    _max?: Exam_boardsMaxAggregateInputType
  }

  export type Exam_boardsGroupByOutputType = {
    board_id: number
    board_name: string
    description: string | null
    input_type: $Enums.exam_boards_input_type
    _count: Exam_boardsCountAggregateOutputType | null
    _avg: Exam_boardsAvgAggregateOutputType | null
    _sum: Exam_boardsSumAggregateOutputType | null
    _min: Exam_boardsMinAggregateOutputType | null
    _max: Exam_boardsMaxAggregateOutputType | null
  }

  type GetExam_boardsGroupByPayload<T extends exam_boardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Exam_boardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exam_boardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exam_boardsGroupByOutputType[P]>
            : GetScalarType<T[P], Exam_boardsGroupByOutputType[P]>
        }
      >
    >


  export type exam_boardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    board_id?: boolean
    board_name?: boolean
    description?: boolean
    input_type?: boolean
    test_plans?: boolean | exam_boards$test_plansArgs<ExtArgs>
    test_templates?: boolean | exam_boards$test_templatesArgs<ExtArgs>
    _count?: boolean | Exam_boardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam_boards"]>


  export type exam_boardsSelectScalar = {
    board_id?: boolean
    board_name?: boolean
    description?: boolean
    input_type?: boolean
  }

  export type exam_boardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plans?: boolean | exam_boards$test_plansArgs<ExtArgs>
    test_templates?: boolean | exam_boards$test_templatesArgs<ExtArgs>
    _count?: boolean | Exam_boardsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $exam_boardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exam_boards"
    objects: {
      test_plans: Prisma.$test_plansPayload<ExtArgs>[]
      test_templates: Prisma.$test_templatesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      board_id: number
      board_name: string
      description: string | null
      input_type: $Enums.exam_boards_input_type
    }, ExtArgs["result"]["exam_boards"]>
    composites: {}
  }

  type exam_boardsGetPayload<S extends boolean | null | undefined | exam_boardsDefaultArgs> = $Result.GetResult<Prisma.$exam_boardsPayload, S>

  type exam_boardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<exam_boardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Exam_boardsCountAggregateInputType | true
    }

  export interface exam_boardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exam_boards'], meta: { name: 'exam_boards' } }
    /**
     * Find zero or one Exam_boards that matches the filter.
     * @param {exam_boardsFindUniqueArgs} args - Arguments to find a Exam_boards
     * @example
     * // Get one Exam_boards
     * const exam_boards = await prisma.exam_boards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exam_boardsFindUniqueArgs>(args: SelectSubset<T, exam_boardsFindUniqueArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam_boards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {exam_boardsFindUniqueOrThrowArgs} args - Arguments to find a Exam_boards
     * @example
     * // Get one Exam_boards
     * const exam_boards = await prisma.exam_boards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exam_boardsFindUniqueOrThrowArgs>(args: SelectSubset<T, exam_boardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam_boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_boardsFindFirstArgs} args - Arguments to find a Exam_boards
     * @example
     * // Get one Exam_boards
     * const exam_boards = await prisma.exam_boards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exam_boardsFindFirstArgs>(args?: SelectSubset<T, exam_boardsFindFirstArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam_boards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_boardsFindFirstOrThrowArgs} args - Arguments to find a Exam_boards
     * @example
     * // Get one Exam_boards
     * const exam_boards = await prisma.exam_boards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exam_boardsFindFirstOrThrowArgs>(args?: SelectSubset<T, exam_boardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exam_boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_boardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exam_boards
     * const exam_boards = await prisma.exam_boards.findMany()
     * 
     * // Get first 10 Exam_boards
     * const exam_boards = await prisma.exam_boards.findMany({ take: 10 })
     * 
     * // Only select the `board_id`
     * const exam_boardsWithBoard_idOnly = await prisma.exam_boards.findMany({ select: { board_id: true } })
     * 
     */
    findMany<T extends exam_boardsFindManyArgs>(args?: SelectSubset<T, exam_boardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam_boards.
     * @param {exam_boardsCreateArgs} args - Arguments to create a Exam_boards.
     * @example
     * // Create one Exam_boards
     * const Exam_boards = await prisma.exam_boards.create({
     *   data: {
     *     // ... data to create a Exam_boards
     *   }
     * })
     * 
     */
    create<T extends exam_boardsCreateArgs>(args: SelectSubset<T, exam_boardsCreateArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exam_boards.
     * @param {exam_boardsCreateManyArgs} args - Arguments to create many Exam_boards.
     * @example
     * // Create many Exam_boards
     * const exam_boards = await prisma.exam_boards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exam_boardsCreateManyArgs>(args?: SelectSubset<T, exam_boardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exam_boards.
     * @param {exam_boardsDeleteArgs} args - Arguments to delete one Exam_boards.
     * @example
     * // Delete one Exam_boards
     * const Exam_boards = await prisma.exam_boards.delete({
     *   where: {
     *     // ... filter to delete one Exam_boards
     *   }
     * })
     * 
     */
    delete<T extends exam_boardsDeleteArgs>(args: SelectSubset<T, exam_boardsDeleteArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam_boards.
     * @param {exam_boardsUpdateArgs} args - Arguments to update one Exam_boards.
     * @example
     * // Update one Exam_boards
     * const exam_boards = await prisma.exam_boards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exam_boardsUpdateArgs>(args: SelectSubset<T, exam_boardsUpdateArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exam_boards.
     * @param {exam_boardsDeleteManyArgs} args - Arguments to filter Exam_boards to delete.
     * @example
     * // Delete a few Exam_boards
     * const { count } = await prisma.exam_boards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exam_boardsDeleteManyArgs>(args?: SelectSubset<T, exam_boardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exam_boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_boardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exam_boards
     * const exam_boards = await prisma.exam_boards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exam_boardsUpdateManyArgs>(args: SelectSubset<T, exam_boardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam_boards.
     * @param {exam_boardsUpsertArgs} args - Arguments to update or create a Exam_boards.
     * @example
     * // Update or create a Exam_boards
     * const exam_boards = await prisma.exam_boards.upsert({
     *   create: {
     *     // ... data to create a Exam_boards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam_boards we want to update
     *   }
     * })
     */
    upsert<T extends exam_boardsUpsertArgs>(args: SelectSubset<T, exam_boardsUpsertArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exam_boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_boardsCountArgs} args - Arguments to filter Exam_boards to count.
     * @example
     * // Count the number of Exam_boards
     * const count = await prisma.exam_boards.count({
     *   where: {
     *     // ... the filter for the Exam_boards we want to count
     *   }
     * })
    **/
    count<T extends exam_boardsCountArgs>(
      args?: Subset<T, exam_boardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exam_boardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam_boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exam_boardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exam_boardsAggregateArgs>(args: Subset<T, Exam_boardsAggregateArgs>): Prisma.PrismaPromise<GetExam_boardsAggregateType<T>>

    /**
     * Group by Exam_boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_boardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exam_boardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exam_boardsGroupByArgs['orderBy'] }
        : { orderBy?: exam_boardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exam_boardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExam_boardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exam_boards model
   */
  readonly fields: exam_boardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exam_boards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exam_boardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_plans<T extends exam_boards$test_plansArgs<ExtArgs> = {}>(args?: Subset<T, exam_boards$test_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany"> | Null>
    test_templates<T extends exam_boards$test_templatesArgs<ExtArgs> = {}>(args?: Subset<T, exam_boards$test_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exam_boards model
   */ 
  interface exam_boardsFieldRefs {
    readonly board_id: FieldRef<"exam_boards", 'Int'>
    readonly board_name: FieldRef<"exam_boards", 'String'>
    readonly description: FieldRef<"exam_boards", 'String'>
    readonly input_type: FieldRef<"exam_boards", 'exam_boards_input_type'>
  }
    

  // Custom InputTypes
  /**
   * exam_boards findUnique
   */
  export type exam_boardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * Filter, which exam_boards to fetch.
     */
    where: exam_boardsWhereUniqueInput
  }

  /**
   * exam_boards findUniqueOrThrow
   */
  export type exam_boardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * Filter, which exam_boards to fetch.
     */
    where: exam_boardsWhereUniqueInput
  }

  /**
   * exam_boards findFirst
   */
  export type exam_boardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * Filter, which exam_boards to fetch.
     */
    where?: exam_boardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_boards to fetch.
     */
    orderBy?: exam_boardsOrderByWithRelationInput | exam_boardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exam_boards.
     */
    cursor?: exam_boardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exam_boards.
     */
    distinct?: Exam_boardsScalarFieldEnum | Exam_boardsScalarFieldEnum[]
  }

  /**
   * exam_boards findFirstOrThrow
   */
  export type exam_boardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * Filter, which exam_boards to fetch.
     */
    where?: exam_boardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_boards to fetch.
     */
    orderBy?: exam_boardsOrderByWithRelationInput | exam_boardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exam_boards.
     */
    cursor?: exam_boardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exam_boards.
     */
    distinct?: Exam_boardsScalarFieldEnum | Exam_boardsScalarFieldEnum[]
  }

  /**
   * exam_boards findMany
   */
  export type exam_boardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * Filter, which exam_boards to fetch.
     */
    where?: exam_boardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_boards to fetch.
     */
    orderBy?: exam_boardsOrderByWithRelationInput | exam_boardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exam_boards.
     */
    cursor?: exam_boardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_boards.
     */
    skip?: number
    distinct?: Exam_boardsScalarFieldEnum | Exam_boardsScalarFieldEnum[]
  }

  /**
   * exam_boards create
   */
  export type exam_boardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * The data needed to create a exam_boards.
     */
    data: XOR<exam_boardsCreateInput, exam_boardsUncheckedCreateInput>
  }

  /**
   * exam_boards createMany
   */
  export type exam_boardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exam_boards.
     */
    data: exam_boardsCreateManyInput | exam_boardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exam_boards update
   */
  export type exam_boardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * The data needed to update a exam_boards.
     */
    data: XOR<exam_boardsUpdateInput, exam_boardsUncheckedUpdateInput>
    /**
     * Choose, which exam_boards to update.
     */
    where: exam_boardsWhereUniqueInput
  }

  /**
   * exam_boards updateMany
   */
  export type exam_boardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exam_boards.
     */
    data: XOR<exam_boardsUpdateManyMutationInput, exam_boardsUncheckedUpdateManyInput>
    /**
     * Filter which exam_boards to update
     */
    where?: exam_boardsWhereInput
  }

  /**
   * exam_boards upsert
   */
  export type exam_boardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * The filter to search for the exam_boards to update in case it exists.
     */
    where: exam_boardsWhereUniqueInput
    /**
     * In case the exam_boards found by the `where` argument doesn't exist, create a new exam_boards with this data.
     */
    create: XOR<exam_boardsCreateInput, exam_boardsUncheckedCreateInput>
    /**
     * In case the exam_boards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exam_boardsUpdateInput, exam_boardsUncheckedUpdateInput>
  }

  /**
   * exam_boards delete
   */
  export type exam_boardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
    /**
     * Filter which exam_boards to delete.
     */
    where: exam_boardsWhereUniqueInput
  }

  /**
   * exam_boards deleteMany
   */
  export type exam_boardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exam_boards to delete
     */
    where?: exam_boardsWhereInput
  }

  /**
   * exam_boards.test_plans
   */
  export type exam_boards$test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    cursor?: test_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * exam_boards.test_templates
   */
  export type exam_boards$test_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    where?: test_templatesWhereInput
    orderBy?: test_templatesOrderByWithRelationInput | test_templatesOrderByWithRelationInput[]
    cursor?: test_templatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_templatesScalarFieldEnum | Test_templatesScalarFieldEnum[]
  }

  /**
   * exam_boards without action
   */
  export type exam_boardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exam_boards
     */
    select?: exam_boardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exam_boardsInclude<ExtArgs> | null
  }


  /**
   * Model questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    question_id: number | null
    subtopic_id: number | null
    difficulty_level: number | null
    created_by: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    question_id: bigint | null
    subtopic_id: number | null
    difficulty_level: number | null
    created_by: bigint | null
  }

  export type QuestionsMinAggregateOutputType = {
    question_id: bigint | null
    subtopic_id: number | null
    question_text: string | null
    question_text_plain: string | null
    options: string | null
    correct_answer: string | null
    correct_answer_plain: string | null
    solution: string | null
    solution_plain: string | null
    difficulty_level: number | null
    created_at: Date | null
    created_by: bigint | null
    active: boolean | null
  }

  export type QuestionsMaxAggregateOutputType = {
    question_id: bigint | null
    subtopic_id: number | null
    question_text: string | null
    question_text_plain: string | null
    options: string | null
    correct_answer: string | null
    correct_answer_plain: string | null
    solution: string | null
    solution_plain: string | null
    difficulty_level: number | null
    created_at: Date | null
    created_by: bigint | null
    active: boolean | null
  }

  export type QuestionsCountAggregateOutputType = {
    question_id: number
    subtopic_id: number
    question_text: number
    question_text_plain: number
    options: number
    correct_answer: number
    correct_answer_plain: number
    solution: number
    solution_plain: number
    difficulty_level: number
    created_at: number
    created_by: number
    active: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    question_id?: true
    subtopic_id?: true
    difficulty_level?: true
    created_by?: true
  }

  export type QuestionsSumAggregateInputType = {
    question_id?: true
    subtopic_id?: true
    difficulty_level?: true
    created_by?: true
  }

  export type QuestionsMinAggregateInputType = {
    question_id?: true
    subtopic_id?: true
    question_text?: true
    question_text_plain?: true
    options?: true
    correct_answer?: true
    correct_answer_plain?: true
    solution?: true
    solution_plain?: true
    difficulty_level?: true
    created_at?: true
    created_by?: true
    active?: true
  }

  export type QuestionsMaxAggregateInputType = {
    question_id?: true
    subtopic_id?: true
    question_text?: true
    question_text_plain?: true
    options?: true
    correct_answer?: true
    correct_answer_plain?: true
    solution?: true
    solution_plain?: true
    difficulty_level?: true
    created_at?: true
    created_by?: true
    active?: true
  }

  export type QuestionsCountAggregateInputType = {
    question_id?: true
    subtopic_id?: true
    question_text?: true
    question_text_plain?: true
    options?: true
    correct_answer?: true
    correct_answer_plain?: true
    solution?: true
    solution_plain?: true
    difficulty_level?: true
    created_at?: true
    created_by?: true
    active?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to aggregate.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithAggregationInput | questionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    question_id: bigint
    subtopic_id: number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at: Date | null
    created_by: bigint
    active: boolean | null
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    subtopic_id?: boolean
    question_text?: boolean
    question_text_plain?: boolean
    options?: boolean
    correct_answer?: boolean
    correct_answer_plain?: boolean
    solution?: boolean
    solution_plain?: boolean
    difficulty_level?: boolean
    created_at?: boolean
    created_by?: boolean
    active?: boolean
    subtopics?: boolean | subtopicsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    question_set_items?: boolean | questions$question_set_itemsArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>


  export type questionsSelectScalar = {
    question_id?: boolean
    subtopic_id?: boolean
    question_text?: boolean
    question_text_plain?: boolean
    options?: boolean
    correct_answer?: boolean
    correct_answer_plain?: boolean
    solution?: boolean
    solution_plain?: boolean
    difficulty_level?: boolean
    created_at?: boolean
    created_by?: boolean
    active?: boolean
  }

  export type questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtopics?: boolean | subtopicsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    question_set_items?: boolean | questions$question_set_itemsArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions"
    objects: {
      subtopics: Prisma.$subtopicsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
      question_set_items: Prisma.$question_set_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      question_id: bigint
      subtopic_id: number
      question_text: string
      question_text_plain: string
      options: string
      correct_answer: string
      correct_answer_plain: string
      solution: string
      solution_plain: string
      difficulty_level: number
      created_at: Date | null
      created_by: bigint
      active: boolean | null
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type questionsGetPayload<S extends boolean | null | undefined | questionsDefaultArgs> = $Result.GetResult<Prisma.$questionsPayload, S>

  type questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions'], meta: { name: 'questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionsFindUniqueArgs>(args: SelectSubset<T, questionsFindUniqueArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionsFindFirstArgs>(args?: SelectSubset<T, questionsFindFirstArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `question_id`
     * const questionsWithQuestion_idOnly = await prisma.questions.findMany({ select: { question_id: true } })
     * 
     */
    findMany<T extends questionsFindManyArgs>(args?: SelectSubset<T, questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends questionsCreateArgs>(args: SelectSubset<T, questionsCreateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {questionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionsCreateManyArgs>(args?: SelectSubset<T, questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends questionsDeleteArgs>(args: SelectSubset<T, questionsDeleteArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionsUpdateArgs>(args: SelectSubset<T, questionsUpdateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionsDeleteManyArgs>(args?: SelectSubset<T, questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionsUpdateManyArgs>(args: SelectSubset<T, questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends questionsUpsertArgs>(args: SelectSubset<T, questionsUpsertArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionsGroupByArgs['orderBy'] }
        : { orderBy?: questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions model
   */
  readonly fields: questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subtopics<T extends subtopicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subtopicsDefaultArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question_set_items<T extends questions$question_set_itemsArgs<ExtArgs> = {}>(args?: Subset<T, questions$question_set_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions model
   */ 
  interface questionsFieldRefs {
    readonly question_id: FieldRef<"questions", 'BigInt'>
    readonly subtopic_id: FieldRef<"questions", 'Int'>
    readonly question_text: FieldRef<"questions", 'String'>
    readonly question_text_plain: FieldRef<"questions", 'String'>
    readonly options: FieldRef<"questions", 'String'>
    readonly correct_answer: FieldRef<"questions", 'String'>
    readonly correct_answer_plain: FieldRef<"questions", 'String'>
    readonly solution: FieldRef<"questions", 'String'>
    readonly solution_plain: FieldRef<"questions", 'String'>
    readonly difficulty_level: FieldRef<"questions", 'Int'>
    readonly created_at: FieldRef<"questions", 'DateTime'>
    readonly created_by: FieldRef<"questions", 'BigInt'>
    readonly active: FieldRef<"questions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findUniqueOrThrow
   */
  export type questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findFirstOrThrow
   */
  export type questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findMany
   */
  export type questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions create
   */
  export type questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a questions.
     */
    data: XOR<questionsCreateInput, questionsUncheckedCreateInput>
  }

  /**
   * questions createMany
   */
  export type questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions update
   */
  export type questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a questions.
     */
    data: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
    /**
     * Choose, which questions to update.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
  }

  /**
   * questions upsert
   */
  export type questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the questions to update in case it exists.
     */
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
     */
    create: XOR<questionsCreateInput, questionsUncheckedCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
  }

  /**
   * questions delete
   */
  export type questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter which questions to delete.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionsWhereInput
  }

  /**
   * questions.question_set_items
   */
  export type questions$question_set_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    where?: question_set_itemsWhereInput
    orderBy?: question_set_itemsOrderByWithRelationInput | question_set_itemsOrderByWithRelationInput[]
    cursor?: question_set_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Question_set_itemsScalarFieldEnum | Question_set_itemsScalarFieldEnum[]
  }

  /**
   * questions without action
   */
  export type questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
  }


  /**
   * Model question_set_items
   */

  export type AggregateQuestion_set_items = {
    _count: Question_set_itemsCountAggregateOutputType | null
    _avg: Question_set_itemsAvgAggregateOutputType | null
    _sum: Question_set_itemsSumAggregateOutputType | null
    _min: Question_set_itemsMinAggregateOutputType | null
    _max: Question_set_itemsMaxAggregateOutputType | null
  }

  export type Question_set_itemsAvgAggregateOutputType = {
    item_id: number | null
    set_id: number | null
    question_id: number | null
    sequence: number | null
  }

  export type Question_set_itemsSumAggregateOutputType = {
    item_id: bigint | null
    set_id: bigint | null
    question_id: bigint | null
    sequence: number | null
  }

  export type Question_set_itemsMinAggregateOutputType = {
    item_id: bigint | null
    set_id: bigint | null
    question_id: bigint | null
    sequence: number | null
    created_at: Date | null
  }

  export type Question_set_itemsMaxAggregateOutputType = {
    item_id: bigint | null
    set_id: bigint | null
    question_id: bigint | null
    sequence: number | null
    created_at: Date | null
  }

  export type Question_set_itemsCountAggregateOutputType = {
    item_id: number
    set_id: number
    question_id: number
    sequence: number
    created_at: number
    _all: number
  }


  export type Question_set_itemsAvgAggregateInputType = {
    item_id?: true
    set_id?: true
    question_id?: true
    sequence?: true
  }

  export type Question_set_itemsSumAggregateInputType = {
    item_id?: true
    set_id?: true
    question_id?: true
    sequence?: true
  }

  export type Question_set_itemsMinAggregateInputType = {
    item_id?: true
    set_id?: true
    question_id?: true
    sequence?: true
    created_at?: true
  }

  export type Question_set_itemsMaxAggregateInputType = {
    item_id?: true
    set_id?: true
    question_id?: true
    sequence?: true
    created_at?: true
  }

  export type Question_set_itemsCountAggregateInputType = {
    item_id?: true
    set_id?: true
    question_id?: true
    sequence?: true
    created_at?: true
    _all?: true
  }

  export type Question_set_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_set_items to aggregate.
     */
    where?: question_set_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_set_items to fetch.
     */
    orderBy?: question_set_itemsOrderByWithRelationInput | question_set_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: question_set_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_set_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_set_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned question_set_items
    **/
    _count?: true | Question_set_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Question_set_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Question_set_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Question_set_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Question_set_itemsMaxAggregateInputType
  }

  export type GetQuestion_set_itemsAggregateType<T extends Question_set_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion_set_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion_set_items[P]>
      : GetScalarType<T[P], AggregateQuestion_set_items[P]>
  }




  export type question_set_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_set_itemsWhereInput
    orderBy?: question_set_itemsOrderByWithAggregationInput | question_set_itemsOrderByWithAggregationInput[]
    by: Question_set_itemsScalarFieldEnum[] | Question_set_itemsScalarFieldEnum
    having?: question_set_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Question_set_itemsCountAggregateInputType | true
    _avg?: Question_set_itemsAvgAggregateInputType
    _sum?: Question_set_itemsSumAggregateInputType
    _min?: Question_set_itemsMinAggregateInputType
    _max?: Question_set_itemsMaxAggregateInputType
  }

  export type Question_set_itemsGroupByOutputType = {
    item_id: bigint
    set_id: bigint
    question_id: bigint
    sequence: number
    created_at: Date
    _count: Question_set_itemsCountAggregateOutputType | null
    _avg: Question_set_itemsAvgAggregateOutputType | null
    _sum: Question_set_itemsSumAggregateOutputType | null
    _min: Question_set_itemsMinAggregateOutputType | null
    _max: Question_set_itemsMaxAggregateOutputType | null
  }

  type GetQuestion_set_itemsGroupByPayload<T extends question_set_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Question_set_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Question_set_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Question_set_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Question_set_itemsGroupByOutputType[P]>
        }
      >
    >


  export type question_set_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    set_id?: boolean
    question_id?: boolean
    sequence?: boolean
    created_at?: boolean
    question_set?: boolean | question_setsDefaultArgs<ExtArgs>
    question?: boolean | questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_set_items"]>


  export type question_set_itemsSelectScalar = {
    item_id?: boolean
    set_id?: boolean
    question_id?: boolean
    sequence?: boolean
    created_at?: boolean
  }

  export type question_set_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_set?: boolean | question_setsDefaultArgs<ExtArgs>
    question?: boolean | questionsDefaultArgs<ExtArgs>
  }

  export type $question_set_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question_set_items"
    objects: {
      question_set: Prisma.$question_setsPayload<ExtArgs>
      question: Prisma.$questionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      item_id: bigint
      set_id: bigint
      question_id: bigint
      sequence: number
      created_at: Date
    }, ExtArgs["result"]["question_set_items"]>
    composites: {}
  }

  type question_set_itemsGetPayload<S extends boolean | null | undefined | question_set_itemsDefaultArgs> = $Result.GetResult<Prisma.$question_set_itemsPayload, S>

  type question_set_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<question_set_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Question_set_itemsCountAggregateInputType | true
    }

  export interface question_set_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question_set_items'], meta: { name: 'question_set_items' } }
    /**
     * Find zero or one Question_set_items that matches the filter.
     * @param {question_set_itemsFindUniqueArgs} args - Arguments to find a Question_set_items
     * @example
     * // Get one Question_set_items
     * const question_set_items = await prisma.question_set_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends question_set_itemsFindUniqueArgs>(args: SelectSubset<T, question_set_itemsFindUniqueArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question_set_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {question_set_itemsFindUniqueOrThrowArgs} args - Arguments to find a Question_set_items
     * @example
     * // Get one Question_set_items
     * const question_set_items = await prisma.question_set_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends question_set_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, question_set_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question_set_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_set_itemsFindFirstArgs} args - Arguments to find a Question_set_items
     * @example
     * // Get one Question_set_items
     * const question_set_items = await prisma.question_set_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends question_set_itemsFindFirstArgs>(args?: SelectSubset<T, question_set_itemsFindFirstArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question_set_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_set_itemsFindFirstOrThrowArgs} args - Arguments to find a Question_set_items
     * @example
     * // Get one Question_set_items
     * const question_set_items = await prisma.question_set_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends question_set_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, question_set_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Question_set_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_set_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Question_set_items
     * const question_set_items = await prisma.question_set_items.findMany()
     * 
     * // Get first 10 Question_set_items
     * const question_set_items = await prisma.question_set_items.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const question_set_itemsWithItem_idOnly = await prisma.question_set_items.findMany({ select: { item_id: true } })
     * 
     */
    findMany<T extends question_set_itemsFindManyArgs>(args?: SelectSubset<T, question_set_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question_set_items.
     * @param {question_set_itemsCreateArgs} args - Arguments to create a Question_set_items.
     * @example
     * // Create one Question_set_items
     * const Question_set_items = await prisma.question_set_items.create({
     *   data: {
     *     // ... data to create a Question_set_items
     *   }
     * })
     * 
     */
    create<T extends question_set_itemsCreateArgs>(args: SelectSubset<T, question_set_itemsCreateArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Question_set_items.
     * @param {question_set_itemsCreateManyArgs} args - Arguments to create many Question_set_items.
     * @example
     * // Create many Question_set_items
     * const question_set_items = await prisma.question_set_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends question_set_itemsCreateManyArgs>(args?: SelectSubset<T, question_set_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question_set_items.
     * @param {question_set_itemsDeleteArgs} args - Arguments to delete one Question_set_items.
     * @example
     * // Delete one Question_set_items
     * const Question_set_items = await prisma.question_set_items.delete({
     *   where: {
     *     // ... filter to delete one Question_set_items
     *   }
     * })
     * 
     */
    delete<T extends question_set_itemsDeleteArgs>(args: SelectSubset<T, question_set_itemsDeleteArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question_set_items.
     * @param {question_set_itemsUpdateArgs} args - Arguments to update one Question_set_items.
     * @example
     * // Update one Question_set_items
     * const question_set_items = await prisma.question_set_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends question_set_itemsUpdateArgs>(args: SelectSubset<T, question_set_itemsUpdateArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Question_set_items.
     * @param {question_set_itemsDeleteManyArgs} args - Arguments to filter Question_set_items to delete.
     * @example
     * // Delete a few Question_set_items
     * const { count } = await prisma.question_set_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends question_set_itemsDeleteManyArgs>(args?: SelectSubset<T, question_set_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_set_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_set_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Question_set_items
     * const question_set_items = await prisma.question_set_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends question_set_itemsUpdateManyArgs>(args: SelectSubset<T, question_set_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question_set_items.
     * @param {question_set_itemsUpsertArgs} args - Arguments to update or create a Question_set_items.
     * @example
     * // Update or create a Question_set_items
     * const question_set_items = await prisma.question_set_items.upsert({
     *   create: {
     *     // ... data to create a Question_set_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question_set_items we want to update
     *   }
     * })
     */
    upsert<T extends question_set_itemsUpsertArgs>(args: SelectSubset<T, question_set_itemsUpsertArgs<ExtArgs>>): Prisma__question_set_itemsClient<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Question_set_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_set_itemsCountArgs} args - Arguments to filter Question_set_items to count.
     * @example
     * // Count the number of Question_set_items
     * const count = await prisma.question_set_items.count({
     *   where: {
     *     // ... the filter for the Question_set_items we want to count
     *   }
     * })
    **/
    count<T extends question_set_itemsCountArgs>(
      args?: Subset<T, question_set_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Question_set_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question_set_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_set_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Question_set_itemsAggregateArgs>(args: Subset<T, Question_set_itemsAggregateArgs>): Prisma.PrismaPromise<GetQuestion_set_itemsAggregateType<T>>

    /**
     * Group by Question_set_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_set_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends question_set_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: question_set_itemsGroupByArgs['orderBy'] }
        : { orderBy?: question_set_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, question_set_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestion_set_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question_set_items model
   */
  readonly fields: question_set_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question_set_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__question_set_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question_set<T extends question_setsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, question_setsDefaultArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionsDefaultArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question_set_items model
   */ 
  interface question_set_itemsFieldRefs {
    readonly item_id: FieldRef<"question_set_items", 'BigInt'>
    readonly set_id: FieldRef<"question_set_items", 'BigInt'>
    readonly question_id: FieldRef<"question_set_items", 'BigInt'>
    readonly sequence: FieldRef<"question_set_items", 'Int'>
    readonly created_at: FieldRef<"question_set_items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * question_set_items findUnique
   */
  export type question_set_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * Filter, which question_set_items to fetch.
     */
    where: question_set_itemsWhereUniqueInput
  }

  /**
   * question_set_items findUniqueOrThrow
   */
  export type question_set_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * Filter, which question_set_items to fetch.
     */
    where: question_set_itemsWhereUniqueInput
  }

  /**
   * question_set_items findFirst
   */
  export type question_set_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * Filter, which question_set_items to fetch.
     */
    where?: question_set_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_set_items to fetch.
     */
    orderBy?: question_set_itemsOrderByWithRelationInput | question_set_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_set_items.
     */
    cursor?: question_set_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_set_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_set_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_set_items.
     */
    distinct?: Question_set_itemsScalarFieldEnum | Question_set_itemsScalarFieldEnum[]
  }

  /**
   * question_set_items findFirstOrThrow
   */
  export type question_set_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * Filter, which question_set_items to fetch.
     */
    where?: question_set_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_set_items to fetch.
     */
    orderBy?: question_set_itemsOrderByWithRelationInput | question_set_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_set_items.
     */
    cursor?: question_set_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_set_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_set_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_set_items.
     */
    distinct?: Question_set_itemsScalarFieldEnum | Question_set_itemsScalarFieldEnum[]
  }

  /**
   * question_set_items findMany
   */
  export type question_set_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * Filter, which question_set_items to fetch.
     */
    where?: question_set_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_set_items to fetch.
     */
    orderBy?: question_set_itemsOrderByWithRelationInput | question_set_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing question_set_items.
     */
    cursor?: question_set_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_set_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_set_items.
     */
    skip?: number
    distinct?: Question_set_itemsScalarFieldEnum | Question_set_itemsScalarFieldEnum[]
  }

  /**
   * question_set_items create
   */
  export type question_set_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a question_set_items.
     */
    data: XOR<question_set_itemsCreateInput, question_set_itemsUncheckedCreateInput>
  }

  /**
   * question_set_items createMany
   */
  export type question_set_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many question_set_items.
     */
    data: question_set_itemsCreateManyInput | question_set_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * question_set_items update
   */
  export type question_set_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a question_set_items.
     */
    data: XOR<question_set_itemsUpdateInput, question_set_itemsUncheckedUpdateInput>
    /**
     * Choose, which question_set_items to update.
     */
    where: question_set_itemsWhereUniqueInput
  }

  /**
   * question_set_items updateMany
   */
  export type question_set_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update question_set_items.
     */
    data: XOR<question_set_itemsUpdateManyMutationInput, question_set_itemsUncheckedUpdateManyInput>
    /**
     * Filter which question_set_items to update
     */
    where?: question_set_itemsWhereInput
  }

  /**
   * question_set_items upsert
   */
  export type question_set_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the question_set_items to update in case it exists.
     */
    where: question_set_itemsWhereUniqueInput
    /**
     * In case the question_set_items found by the `where` argument doesn't exist, create a new question_set_items with this data.
     */
    create: XOR<question_set_itemsCreateInput, question_set_itemsUncheckedCreateInput>
    /**
     * In case the question_set_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<question_set_itemsUpdateInput, question_set_itemsUncheckedUpdateInput>
  }

  /**
   * question_set_items delete
   */
  export type question_set_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    /**
     * Filter which question_set_items to delete.
     */
    where: question_set_itemsWhereUniqueInput
  }

  /**
   * question_set_items deleteMany
   */
  export type question_set_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_set_items to delete
     */
    where?: question_set_itemsWhereInput
  }

  /**
   * question_set_items without action
   */
  export type question_set_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
  }


  /**
   * Model question_sets
   */

  export type AggregateQuestion_sets = {
    _count: Question_setsCountAggregateOutputType | null
    _avg: Question_setsAvgAggregateOutputType | null
    _sum: Question_setsSumAggregateOutputType | null
    _min: Question_setsMinAggregateOutputType | null
    _max: Question_setsMaxAggregateOutputType | null
  }

  export type Question_setsAvgAggregateOutputType = {
    set_id: number | null
    created_by: number | null
  }

  export type Question_setsSumAggregateOutputType = {
    set_id: bigint | null
    created_by: bigint | null
  }

  export type Question_setsMinAggregateOutputType = {
    set_id: bigint | null
    name: string | null
    description: string | null
    created_by: bigint | null
    created_at: Date | null
    updated_at: Date | null
    active: boolean | null
    metadata: string | null
  }

  export type Question_setsMaxAggregateOutputType = {
    set_id: bigint | null
    name: string | null
    description: string | null
    created_by: bigint | null
    created_at: Date | null
    updated_at: Date | null
    active: boolean | null
    metadata: string | null
  }

  export type Question_setsCountAggregateOutputType = {
    set_id: number
    name: number
    description: number
    created_by: number
    created_at: number
    updated_at: number
    active: number
    metadata: number
    _all: number
  }


  export type Question_setsAvgAggregateInputType = {
    set_id?: true
    created_by?: true
  }

  export type Question_setsSumAggregateInputType = {
    set_id?: true
    created_by?: true
  }

  export type Question_setsMinAggregateInputType = {
    set_id?: true
    name?: true
    description?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    active?: true
    metadata?: true
  }

  export type Question_setsMaxAggregateInputType = {
    set_id?: true
    name?: true
    description?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    active?: true
    metadata?: true
  }

  export type Question_setsCountAggregateInputType = {
    set_id?: true
    name?: true
    description?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    active?: true
    metadata?: true
    _all?: true
  }

  export type Question_setsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_sets to aggregate.
     */
    where?: question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_sets to fetch.
     */
    orderBy?: question_setsOrderByWithRelationInput | question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned question_sets
    **/
    _count?: true | Question_setsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Question_setsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Question_setsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Question_setsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Question_setsMaxAggregateInputType
  }

  export type GetQuestion_setsAggregateType<T extends Question_setsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion_sets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion_sets[P]>
      : GetScalarType<T[P], AggregateQuestion_sets[P]>
  }




  export type question_setsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_setsWhereInput
    orderBy?: question_setsOrderByWithAggregationInput | question_setsOrderByWithAggregationInput[]
    by: Question_setsScalarFieldEnum[] | Question_setsScalarFieldEnum
    having?: question_setsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Question_setsCountAggregateInputType | true
    _avg?: Question_setsAvgAggregateInputType
    _sum?: Question_setsSumAggregateInputType
    _min?: Question_setsMinAggregateInputType
    _max?: Question_setsMaxAggregateInputType
  }

  export type Question_setsGroupByOutputType = {
    set_id: bigint
    name: string
    description: string | null
    created_by: bigint
    created_at: Date
    updated_at: Date
    active: boolean
    metadata: string | null
    _count: Question_setsCountAggregateOutputType | null
    _avg: Question_setsAvgAggregateOutputType | null
    _sum: Question_setsSumAggregateOutputType | null
    _min: Question_setsMinAggregateOutputType | null
    _max: Question_setsMaxAggregateOutputType | null
  }

  type GetQuestion_setsGroupByPayload<T extends question_setsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Question_setsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Question_setsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Question_setsGroupByOutputType[P]>
            : GetScalarType<T[P], Question_setsGroupByOutputType[P]>
        }
      >
    >


  export type question_setsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    set_id?: boolean
    name?: boolean
    description?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    active?: boolean
    metadata?: boolean
    creator?: boolean | usersDefaultArgs<ExtArgs>
    question_set_items?: boolean | question_sets$question_set_itemsArgs<ExtArgs>
    test_plan_links?: boolean | question_sets$test_plan_linksArgs<ExtArgs>
    _count?: boolean | Question_setsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_sets"]>


  export type question_setsSelectScalar = {
    set_id?: boolean
    name?: boolean
    description?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    active?: boolean
    metadata?: boolean
  }

  export type question_setsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | usersDefaultArgs<ExtArgs>
    question_set_items?: boolean | question_sets$question_set_itemsArgs<ExtArgs>
    test_plan_links?: boolean | question_sets$test_plan_linksArgs<ExtArgs>
    _count?: boolean | Question_setsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $question_setsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question_sets"
    objects: {
      creator: Prisma.$usersPayload<ExtArgs>
      question_set_items: Prisma.$question_set_itemsPayload<ExtArgs>[]
      test_plan_links: Prisma.$test_plan_question_setsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      set_id: bigint
      name: string
      description: string | null
      created_by: bigint
      created_at: Date
      updated_at: Date
      active: boolean
      metadata: string | null
    }, ExtArgs["result"]["question_sets"]>
    composites: {}
  }

  type question_setsGetPayload<S extends boolean | null | undefined | question_setsDefaultArgs> = $Result.GetResult<Prisma.$question_setsPayload, S>

  type question_setsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<question_setsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Question_setsCountAggregateInputType | true
    }

  export interface question_setsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question_sets'], meta: { name: 'question_sets' } }
    /**
     * Find zero or one Question_sets that matches the filter.
     * @param {question_setsFindUniqueArgs} args - Arguments to find a Question_sets
     * @example
     * // Get one Question_sets
     * const question_sets = await prisma.question_sets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends question_setsFindUniqueArgs>(args: SelectSubset<T, question_setsFindUniqueArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question_sets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {question_setsFindUniqueOrThrowArgs} args - Arguments to find a Question_sets
     * @example
     * // Get one Question_sets
     * const question_sets = await prisma.question_sets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends question_setsFindUniqueOrThrowArgs>(args: SelectSubset<T, question_setsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question_sets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_setsFindFirstArgs} args - Arguments to find a Question_sets
     * @example
     * // Get one Question_sets
     * const question_sets = await prisma.question_sets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends question_setsFindFirstArgs>(args?: SelectSubset<T, question_setsFindFirstArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question_sets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_setsFindFirstOrThrowArgs} args - Arguments to find a Question_sets
     * @example
     * // Get one Question_sets
     * const question_sets = await prisma.question_sets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends question_setsFindFirstOrThrowArgs>(args?: SelectSubset<T, question_setsFindFirstOrThrowArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Question_sets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_setsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Question_sets
     * const question_sets = await prisma.question_sets.findMany()
     * 
     * // Get first 10 Question_sets
     * const question_sets = await prisma.question_sets.findMany({ take: 10 })
     * 
     * // Only select the `set_id`
     * const question_setsWithSet_idOnly = await prisma.question_sets.findMany({ select: { set_id: true } })
     * 
     */
    findMany<T extends question_setsFindManyArgs>(args?: SelectSubset<T, question_setsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question_sets.
     * @param {question_setsCreateArgs} args - Arguments to create a Question_sets.
     * @example
     * // Create one Question_sets
     * const Question_sets = await prisma.question_sets.create({
     *   data: {
     *     // ... data to create a Question_sets
     *   }
     * })
     * 
     */
    create<T extends question_setsCreateArgs>(args: SelectSubset<T, question_setsCreateArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Question_sets.
     * @param {question_setsCreateManyArgs} args - Arguments to create many Question_sets.
     * @example
     * // Create many Question_sets
     * const question_sets = await prisma.question_sets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends question_setsCreateManyArgs>(args?: SelectSubset<T, question_setsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question_sets.
     * @param {question_setsDeleteArgs} args - Arguments to delete one Question_sets.
     * @example
     * // Delete one Question_sets
     * const Question_sets = await prisma.question_sets.delete({
     *   where: {
     *     // ... filter to delete one Question_sets
     *   }
     * })
     * 
     */
    delete<T extends question_setsDeleteArgs>(args: SelectSubset<T, question_setsDeleteArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question_sets.
     * @param {question_setsUpdateArgs} args - Arguments to update one Question_sets.
     * @example
     * // Update one Question_sets
     * const question_sets = await prisma.question_sets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends question_setsUpdateArgs>(args: SelectSubset<T, question_setsUpdateArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Question_sets.
     * @param {question_setsDeleteManyArgs} args - Arguments to filter Question_sets to delete.
     * @example
     * // Delete a few Question_sets
     * const { count } = await prisma.question_sets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends question_setsDeleteManyArgs>(args?: SelectSubset<T, question_setsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_setsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Question_sets
     * const question_sets = await prisma.question_sets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends question_setsUpdateManyArgs>(args: SelectSubset<T, question_setsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question_sets.
     * @param {question_setsUpsertArgs} args - Arguments to update or create a Question_sets.
     * @example
     * // Update or create a Question_sets
     * const question_sets = await prisma.question_sets.upsert({
     *   create: {
     *     // ... data to create a Question_sets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question_sets we want to update
     *   }
     * })
     */
    upsert<T extends question_setsUpsertArgs>(args: SelectSubset<T, question_setsUpsertArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_setsCountArgs} args - Arguments to filter Question_sets to count.
     * @example
     * // Count the number of Question_sets
     * const count = await prisma.question_sets.count({
     *   where: {
     *     // ... the filter for the Question_sets we want to count
     *   }
     * })
    **/
    count<T extends question_setsCountArgs>(
      args?: Subset<T, question_setsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Question_setsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_setsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Question_setsAggregateArgs>(args: Subset<T, Question_setsAggregateArgs>): Prisma.PrismaPromise<GetQuestion_setsAggregateType<T>>

    /**
     * Group by Question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_setsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends question_setsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: question_setsGroupByArgs['orderBy'] }
        : { orderBy?: question_setsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, question_setsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestion_setsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question_sets model
   */
  readonly fields: question_setsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question_sets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__question_setsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question_set_items<T extends question_sets$question_set_itemsArgs<ExtArgs> = {}>(args?: Subset<T, question_sets$question_set_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_set_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    test_plan_links<T extends question_sets$test_plan_linksArgs<ExtArgs> = {}>(args?: Subset<T, question_sets$test_plan_linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question_sets model
   */ 
  interface question_setsFieldRefs {
    readonly set_id: FieldRef<"question_sets", 'BigInt'>
    readonly name: FieldRef<"question_sets", 'String'>
    readonly description: FieldRef<"question_sets", 'String'>
    readonly created_by: FieldRef<"question_sets", 'BigInt'>
    readonly created_at: FieldRef<"question_sets", 'DateTime'>
    readonly updated_at: FieldRef<"question_sets", 'DateTime'>
    readonly active: FieldRef<"question_sets", 'Boolean'>
    readonly metadata: FieldRef<"question_sets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * question_sets findUnique
   */
  export type question_setsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * Filter, which question_sets to fetch.
     */
    where: question_setsWhereUniqueInput
  }

  /**
   * question_sets findUniqueOrThrow
   */
  export type question_setsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * Filter, which question_sets to fetch.
     */
    where: question_setsWhereUniqueInput
  }

  /**
   * question_sets findFirst
   */
  export type question_setsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * Filter, which question_sets to fetch.
     */
    where?: question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_sets to fetch.
     */
    orderBy?: question_setsOrderByWithRelationInput | question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_sets.
     */
    cursor?: question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_sets.
     */
    distinct?: Question_setsScalarFieldEnum | Question_setsScalarFieldEnum[]
  }

  /**
   * question_sets findFirstOrThrow
   */
  export type question_setsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * Filter, which question_sets to fetch.
     */
    where?: question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_sets to fetch.
     */
    orderBy?: question_setsOrderByWithRelationInput | question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_sets.
     */
    cursor?: question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_sets.
     */
    distinct?: Question_setsScalarFieldEnum | Question_setsScalarFieldEnum[]
  }

  /**
   * question_sets findMany
   */
  export type question_setsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * Filter, which question_sets to fetch.
     */
    where?: question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_sets to fetch.
     */
    orderBy?: question_setsOrderByWithRelationInput | question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing question_sets.
     */
    cursor?: question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_sets.
     */
    skip?: number
    distinct?: Question_setsScalarFieldEnum | Question_setsScalarFieldEnum[]
  }

  /**
   * question_sets create
   */
  export type question_setsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * The data needed to create a question_sets.
     */
    data: XOR<question_setsCreateInput, question_setsUncheckedCreateInput>
  }

  /**
   * question_sets createMany
   */
  export type question_setsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many question_sets.
     */
    data: question_setsCreateManyInput | question_setsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * question_sets update
   */
  export type question_setsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * The data needed to update a question_sets.
     */
    data: XOR<question_setsUpdateInput, question_setsUncheckedUpdateInput>
    /**
     * Choose, which question_sets to update.
     */
    where: question_setsWhereUniqueInput
  }

  /**
   * question_sets updateMany
   */
  export type question_setsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update question_sets.
     */
    data: XOR<question_setsUpdateManyMutationInput, question_setsUncheckedUpdateManyInput>
    /**
     * Filter which question_sets to update
     */
    where?: question_setsWhereInput
  }

  /**
   * question_sets upsert
   */
  export type question_setsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * The filter to search for the question_sets to update in case it exists.
     */
    where: question_setsWhereUniqueInput
    /**
     * In case the question_sets found by the `where` argument doesn't exist, create a new question_sets with this data.
     */
    create: XOR<question_setsCreateInput, question_setsUncheckedCreateInput>
    /**
     * In case the question_sets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<question_setsUpdateInput, question_setsUncheckedUpdateInput>
  }

  /**
   * question_sets delete
   */
  export type question_setsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    /**
     * Filter which question_sets to delete.
     */
    where: question_setsWhereUniqueInput
  }

  /**
   * question_sets deleteMany
   */
  export type question_setsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_sets to delete
     */
    where?: question_setsWhereInput
  }

  /**
   * question_sets.question_set_items
   */
  export type question_sets$question_set_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_set_items
     */
    select?: question_set_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_set_itemsInclude<ExtArgs> | null
    where?: question_set_itemsWhereInput
    orderBy?: question_set_itemsOrderByWithRelationInput | question_set_itemsOrderByWithRelationInput[]
    cursor?: question_set_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Question_set_itemsScalarFieldEnum | Question_set_itemsScalarFieldEnum[]
  }

  /**
   * question_sets.test_plan_links
   */
  export type question_sets$test_plan_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    where?: test_plan_question_setsWhereInput
    orderBy?: test_plan_question_setsOrderByWithRelationInput | test_plan_question_setsOrderByWithRelationInput[]
    cursor?: test_plan_question_setsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plan_question_setsScalarFieldEnum | Test_plan_question_setsScalarFieldEnum[]
  }

  /**
   * question_sets without action
   */
  export type question_setsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RolesSumAggregateOutputType = {
    role_id: number | null
  }

  export type RolesMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    description: string | null
  }

  export type RolesMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    description: string | null
  }

  export type RolesCountAggregateOutputType = {
    role_id: number
    role_name: number
    description: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    role_id?: true
  }

  export type RolesSumAggregateInputType = {
    role_id?: true
  }

  export type RolesMinAggregateInputType = {
    role_id?: true
    role_name?: true
    description?: true
  }

  export type RolesMaxAggregateInputType = {
    role_id?: true
    role_name?: true
    description?: true
  }

  export type RolesCountAggregateInputType = {
    role_id?: true
    role_name?: true
    description?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    role_id: number
    role_name: string
    description: string | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    description?: boolean
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>


  export type rolesSelectScalar = {
    role_id?: boolean
    role_name?: boolean
    description?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string
      description: string | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const rolesWithRole_idOnly = await prisma.roles.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_roles<T extends roles$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly role_id: FieldRef<"roles", 'Int'>
    readonly role_name: FieldRef<"roles", 'String'>
    readonly description: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.user_roles
   */
  export type roles$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsAvgAggregateOutputType = {
    subject_id: number | null
  }

  export type SubjectsSumAggregateOutputType = {
    subject_id: number | null
  }

  export type SubjectsMinAggregateOutputType = {
    subject_id: number | null
    subject_name: string | null
    description: string | null
  }

  export type SubjectsMaxAggregateOutputType = {
    subject_id: number | null
    subject_name: string | null
    description: string | null
  }

  export type SubjectsCountAggregateOutputType = {
    subject_id: number
    subject_name: number
    description: number
    _all: number
  }


  export type SubjectsAvgAggregateInputType = {
    subject_id?: true
  }

  export type SubjectsSumAggregateInputType = {
    subject_id?: true
  }

  export type SubjectsMinAggregateInputType = {
    subject_id?: true
    subject_name?: true
    description?: true
  }

  export type SubjectsMaxAggregateInputType = {
    subject_id?: true
    subject_name?: true
    description?: true
  }

  export type SubjectsCountAggregateInputType = {
    subject_id?: true
    subject_name?: true
    description?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to aggregate.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectsWhereInput
    orderBy?: subjectsOrderByWithAggregationInput | subjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _avg?: SubjectsAvgAggregateInputType
    _sum?: SubjectsSumAggregateInputType
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    subject_id: number
    subject_name: string
    description: string | null
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subject_id?: boolean
    subject_name?: boolean
    description?: boolean
    topics?: boolean | subjects$topicsArgs<ExtArgs>
    subject_mastery?: boolean | subjects$subject_masteryArgs<ExtArgs>
    difficulty_levels?: boolean | subjects$difficulty_levelsArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>


  export type subjectsSelectScalar = {
    subject_id?: boolean
    subject_name?: boolean
    description?: boolean
  }

  export type subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | subjects$topicsArgs<ExtArgs>
    subject_mastery?: boolean | subjects$subject_masteryArgs<ExtArgs>
    difficulty_levels?: boolean | subjects$difficulty_levelsArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subjects"
    objects: {
      topics: Prisma.$topicsPayload<ExtArgs>[]
      subject_mastery: Prisma.$subject_masteryPayload<ExtArgs>[]
      difficulty_levels: Prisma.$difficulty_levelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subject_id: number
      subject_name: string
      description: string | null
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type subjectsGetPayload<S extends boolean | null | undefined | subjectsDefaultArgs> = $Result.GetResult<Prisma.$subjectsPayload, S>

  type subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<subjectsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subjects'], meta: { name: 'subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {subjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectsFindUniqueArgs>(args: SelectSubset<T, subjectsFindUniqueArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {subjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectsFindFirstArgs>(args?: SelectSubset<T, subjectsFindFirstArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `subject_id`
     * const subjectsWithSubject_idOnly = await prisma.subjects.findMany({ select: { subject_id: true } })
     * 
     */
    findMany<T extends subjectsFindManyArgs>(args?: SelectSubset<T, subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subjects.
     * @param {subjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends subjectsCreateArgs>(args: SelectSubset<T, subjectsCreateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subjects.
     * @param {subjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectsCreateManyArgs>(args?: SelectSubset<T, subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subjects.
     * @param {subjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends subjectsDeleteArgs>(args: SelectSubset<T, subjectsDeleteArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subjects.
     * @param {subjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectsUpdateArgs>(args: SelectSubset<T, subjectsUpdateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subjects.
     * @param {subjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectsDeleteManyArgs>(args?: SelectSubset<T, subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectsUpdateManyArgs>(args: SelectSubset<T, subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subjects.
     * @param {subjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends subjectsUpsertArgs>(args: SelectSubset<T, subjectsUpsertArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectsCountArgs>(
      args?: Subset<T, subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectsGroupByArgs['orderBy'] }
        : { orderBy?: subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subjects model
   */
  readonly fields: subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topics<T extends subjects$topicsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findMany"> | Null>
    subject_mastery<T extends subjects$subject_masteryArgs<ExtArgs> = {}>(args?: Subset<T, subjects$subject_masteryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findMany"> | Null>
    difficulty_levels<T extends subjects$difficulty_levelsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$difficulty_levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subjects model
   */ 
  interface subjectsFieldRefs {
    readonly subject_id: FieldRef<"subjects", 'Int'>
    readonly subject_name: FieldRef<"subjects", 'String'>
    readonly description: FieldRef<"subjects", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subjects findUnique
   */
  export type subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findUniqueOrThrow
   */
  export type subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findFirst
   */
  export type subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findFirstOrThrow
   */
  export type subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findMany
   */
  export type subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects create
   */
  export type subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a subjects.
     */
    data: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
  }

  /**
   * subjects createMany
   */
  export type subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectsCreateManyInput | subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subjects update
   */
  export type subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a subjects.
     */
    data: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
    /**
     * Choose, which subjects to update.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects updateMany
   */
  export type subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectsWhereInput
  }

  /**
   * subjects upsert
   */
  export type subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the subjects to update in case it exists.
     */
    where: subjectsWhereUniqueInput
    /**
     * In case the subjects found by the `where` argument doesn't exist, create a new subjects with this data.
     */
    create: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
    /**
     * In case the subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
  }

  /**
   * subjects delete
   */
  export type subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter which subjects to delete.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects deleteMany
   */
  export type subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectsWhereInput
  }

  /**
   * subjects.topics
   */
  export type subjects$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    where?: topicsWhereInput
    orderBy?: topicsOrderByWithRelationInput | topicsOrderByWithRelationInput[]
    cursor?: topicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * subjects.subject_mastery
   */
  export type subjects$subject_masteryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    where?: subject_masteryWhereInput
    orderBy?: subject_masteryOrderByWithRelationInput | subject_masteryOrderByWithRelationInput[]
    cursor?: subject_masteryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Subject_masteryScalarFieldEnum | Subject_masteryScalarFieldEnum[]
  }

  /**
   * subjects.difficulty_levels
   */
  export type subjects$difficulty_levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    where?: difficulty_levelsWhereInput
    orderBy?: difficulty_levelsOrderByWithRelationInput | difficulty_levelsOrderByWithRelationInput[]
    cursor?: difficulty_levelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Difficulty_levelsScalarFieldEnum | Difficulty_levelsScalarFieldEnum[]
  }

  /**
   * subjects without action
   */
  export type subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
  }


  /**
   * Model subtopics
   */

  export type AggregateSubtopics = {
    _count: SubtopicsCountAggregateOutputType | null
    _avg: SubtopicsAvgAggregateOutputType | null
    _sum: SubtopicsSumAggregateOutputType | null
    _min: SubtopicsMinAggregateOutputType | null
    _max: SubtopicsMaxAggregateOutputType | null
  }

  export type SubtopicsAvgAggregateOutputType = {
    subtopic_id: number | null
    topic_id: number | null
  }

  export type SubtopicsSumAggregateOutputType = {
    subtopic_id: number | null
    topic_id: number | null
  }

  export type SubtopicsMinAggregateOutputType = {
    subtopic_id: number | null
    topic_id: number | null
    subtopic_name: string | null
    description: string | null
  }

  export type SubtopicsMaxAggregateOutputType = {
    subtopic_id: number | null
    topic_id: number | null
    subtopic_name: string | null
    description: string | null
  }

  export type SubtopicsCountAggregateOutputType = {
    subtopic_id: number
    topic_id: number
    subtopic_name: number
    description: number
    _all: number
  }


  export type SubtopicsAvgAggregateInputType = {
    subtopic_id?: true
    topic_id?: true
  }

  export type SubtopicsSumAggregateInputType = {
    subtopic_id?: true
    topic_id?: true
  }

  export type SubtopicsMinAggregateInputType = {
    subtopic_id?: true
    topic_id?: true
    subtopic_name?: true
    description?: true
  }

  export type SubtopicsMaxAggregateInputType = {
    subtopic_id?: true
    topic_id?: true
    subtopic_name?: true
    description?: true
  }

  export type SubtopicsCountAggregateInputType = {
    subtopic_id?: true
    topic_id?: true
    subtopic_name?: true
    description?: true
    _all?: true
  }

  export type SubtopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subtopics to aggregate.
     */
    where?: subtopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtopics to fetch.
     */
    orderBy?: subtopicsOrderByWithRelationInput | subtopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subtopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subtopics
    **/
    _count?: true | SubtopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubtopicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubtopicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtopicsMaxAggregateInputType
  }

  export type GetSubtopicsAggregateType<T extends SubtopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtopics[P]>
      : GetScalarType<T[P], AggregateSubtopics[P]>
  }




  export type subtopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subtopicsWhereInput
    orderBy?: subtopicsOrderByWithAggregationInput | subtopicsOrderByWithAggregationInput[]
    by: SubtopicsScalarFieldEnum[] | SubtopicsScalarFieldEnum
    having?: subtopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtopicsCountAggregateInputType | true
    _avg?: SubtopicsAvgAggregateInputType
    _sum?: SubtopicsSumAggregateInputType
    _min?: SubtopicsMinAggregateInputType
    _max?: SubtopicsMaxAggregateInputType
  }

  export type SubtopicsGroupByOutputType = {
    subtopic_id: number
    topic_id: number
    subtopic_name: string
    description: string | null
    _count: SubtopicsCountAggregateOutputType | null
    _avg: SubtopicsAvgAggregateOutputType | null
    _sum: SubtopicsSumAggregateOutputType | null
    _min: SubtopicsMinAggregateOutputType | null
    _max: SubtopicsMaxAggregateOutputType | null
  }

  type GetSubtopicsGroupByPayload<T extends subtopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtopicsGroupByOutputType[P]>
            : GetScalarType<T[P], SubtopicsGroupByOutputType[P]>
        }
      >
    >


  export type subtopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subtopic_id?: boolean
    topic_id?: boolean
    subtopic_name?: boolean
    description?: boolean
    questions?: boolean | subtopics$questionsArgs<ExtArgs>
    topics?: boolean | topicsDefaultArgs<ExtArgs>
    _count?: boolean | SubtopicsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtopics"]>


  export type subtopicsSelectScalar = {
    subtopic_id?: boolean
    topic_id?: boolean
    subtopic_name?: boolean
    description?: boolean
  }

  export type subtopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | subtopics$questionsArgs<ExtArgs>
    topics?: boolean | topicsDefaultArgs<ExtArgs>
    _count?: boolean | SubtopicsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subtopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subtopics"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
      topics: Prisma.$topicsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subtopic_id: number
      topic_id: number
      subtopic_name: string
      description: string | null
    }, ExtArgs["result"]["subtopics"]>
    composites: {}
  }

  type subtopicsGetPayload<S extends boolean | null | undefined | subtopicsDefaultArgs> = $Result.GetResult<Prisma.$subtopicsPayload, S>

  type subtopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<subtopicsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubtopicsCountAggregateInputType | true
    }

  export interface subtopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subtopics'], meta: { name: 'subtopics' } }
    /**
     * Find zero or one Subtopics that matches the filter.
     * @param {subtopicsFindUniqueArgs} args - Arguments to find a Subtopics
     * @example
     * // Get one Subtopics
     * const subtopics = await prisma.subtopics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subtopicsFindUniqueArgs>(args: SelectSubset<T, subtopicsFindUniqueArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subtopics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {subtopicsFindUniqueOrThrowArgs} args - Arguments to find a Subtopics
     * @example
     * // Get one Subtopics
     * const subtopics = await prisma.subtopics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subtopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, subtopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subtopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtopicsFindFirstArgs} args - Arguments to find a Subtopics
     * @example
     * // Get one Subtopics
     * const subtopics = await prisma.subtopics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subtopicsFindFirstArgs>(args?: SelectSubset<T, subtopicsFindFirstArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subtopics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtopicsFindFirstOrThrowArgs} args - Arguments to find a Subtopics
     * @example
     * // Get one Subtopics
     * const subtopics = await prisma.subtopics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subtopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, subtopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subtopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtopics
     * const subtopics = await prisma.subtopics.findMany()
     * 
     * // Get first 10 Subtopics
     * const subtopics = await prisma.subtopics.findMany({ take: 10 })
     * 
     * // Only select the `subtopic_id`
     * const subtopicsWithSubtopic_idOnly = await prisma.subtopics.findMany({ select: { subtopic_id: true } })
     * 
     */
    findMany<T extends subtopicsFindManyArgs>(args?: SelectSubset<T, subtopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subtopics.
     * @param {subtopicsCreateArgs} args - Arguments to create a Subtopics.
     * @example
     * // Create one Subtopics
     * const Subtopics = await prisma.subtopics.create({
     *   data: {
     *     // ... data to create a Subtopics
     *   }
     * })
     * 
     */
    create<T extends subtopicsCreateArgs>(args: SelectSubset<T, subtopicsCreateArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subtopics.
     * @param {subtopicsCreateManyArgs} args - Arguments to create many Subtopics.
     * @example
     * // Create many Subtopics
     * const subtopics = await prisma.subtopics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subtopicsCreateManyArgs>(args?: SelectSubset<T, subtopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subtopics.
     * @param {subtopicsDeleteArgs} args - Arguments to delete one Subtopics.
     * @example
     * // Delete one Subtopics
     * const Subtopics = await prisma.subtopics.delete({
     *   where: {
     *     // ... filter to delete one Subtopics
     *   }
     * })
     * 
     */
    delete<T extends subtopicsDeleteArgs>(args: SelectSubset<T, subtopicsDeleteArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subtopics.
     * @param {subtopicsUpdateArgs} args - Arguments to update one Subtopics.
     * @example
     * // Update one Subtopics
     * const subtopics = await prisma.subtopics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subtopicsUpdateArgs>(args: SelectSubset<T, subtopicsUpdateArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subtopics.
     * @param {subtopicsDeleteManyArgs} args - Arguments to filter Subtopics to delete.
     * @example
     * // Delete a few Subtopics
     * const { count } = await prisma.subtopics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subtopicsDeleteManyArgs>(args?: SelectSubset<T, subtopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtopics
     * const subtopics = await prisma.subtopics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subtopicsUpdateManyArgs>(args: SelectSubset<T, subtopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subtopics.
     * @param {subtopicsUpsertArgs} args - Arguments to update or create a Subtopics.
     * @example
     * // Update or create a Subtopics
     * const subtopics = await prisma.subtopics.upsert({
     *   create: {
     *     // ... data to create a Subtopics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtopics we want to update
     *   }
     * })
     */
    upsert<T extends subtopicsUpsertArgs>(args: SelectSubset<T, subtopicsUpsertArgs<ExtArgs>>): Prisma__subtopicsClient<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subtopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtopicsCountArgs} args - Arguments to filter Subtopics to count.
     * @example
     * // Count the number of Subtopics
     * const count = await prisma.subtopics.count({
     *   where: {
     *     // ... the filter for the Subtopics we want to count
     *   }
     * })
    **/
    count<T extends subtopicsCountArgs>(
      args?: Subset<T, subtopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtopicsAggregateArgs>(args: Subset<T, SubtopicsAggregateArgs>): Prisma.PrismaPromise<GetSubtopicsAggregateType<T>>

    /**
     * Group by Subtopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subtopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subtopicsGroupByArgs['orderBy'] }
        : { orderBy?: subtopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subtopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subtopics model
   */
  readonly fields: subtopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subtopics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subtopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends subtopics$questionsArgs<ExtArgs> = {}>(args?: Subset<T, subtopics$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends topicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, topicsDefaultArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subtopics model
   */ 
  interface subtopicsFieldRefs {
    readonly subtopic_id: FieldRef<"subtopics", 'Int'>
    readonly topic_id: FieldRef<"subtopics", 'Int'>
    readonly subtopic_name: FieldRef<"subtopics", 'String'>
    readonly description: FieldRef<"subtopics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subtopics findUnique
   */
  export type subtopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * Filter, which subtopics to fetch.
     */
    where: subtopicsWhereUniqueInput
  }

  /**
   * subtopics findUniqueOrThrow
   */
  export type subtopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * Filter, which subtopics to fetch.
     */
    where: subtopicsWhereUniqueInput
  }

  /**
   * subtopics findFirst
   */
  export type subtopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * Filter, which subtopics to fetch.
     */
    where?: subtopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtopics to fetch.
     */
    orderBy?: subtopicsOrderByWithRelationInput | subtopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subtopics.
     */
    cursor?: subtopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subtopics.
     */
    distinct?: SubtopicsScalarFieldEnum | SubtopicsScalarFieldEnum[]
  }

  /**
   * subtopics findFirstOrThrow
   */
  export type subtopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * Filter, which subtopics to fetch.
     */
    where?: subtopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtopics to fetch.
     */
    orderBy?: subtopicsOrderByWithRelationInput | subtopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subtopics.
     */
    cursor?: subtopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subtopics.
     */
    distinct?: SubtopicsScalarFieldEnum | SubtopicsScalarFieldEnum[]
  }

  /**
   * subtopics findMany
   */
  export type subtopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * Filter, which subtopics to fetch.
     */
    where?: subtopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtopics to fetch.
     */
    orderBy?: subtopicsOrderByWithRelationInput | subtopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subtopics.
     */
    cursor?: subtopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtopics.
     */
    skip?: number
    distinct?: SubtopicsScalarFieldEnum | SubtopicsScalarFieldEnum[]
  }

  /**
   * subtopics create
   */
  export type subtopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a subtopics.
     */
    data: XOR<subtopicsCreateInput, subtopicsUncheckedCreateInput>
  }

  /**
   * subtopics createMany
   */
  export type subtopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subtopics.
     */
    data: subtopicsCreateManyInput | subtopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subtopics update
   */
  export type subtopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a subtopics.
     */
    data: XOR<subtopicsUpdateInput, subtopicsUncheckedUpdateInput>
    /**
     * Choose, which subtopics to update.
     */
    where: subtopicsWhereUniqueInput
  }

  /**
   * subtopics updateMany
   */
  export type subtopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subtopics.
     */
    data: XOR<subtopicsUpdateManyMutationInput, subtopicsUncheckedUpdateManyInput>
    /**
     * Filter which subtopics to update
     */
    where?: subtopicsWhereInput
  }

  /**
   * subtopics upsert
   */
  export type subtopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the subtopics to update in case it exists.
     */
    where: subtopicsWhereUniqueInput
    /**
     * In case the subtopics found by the `where` argument doesn't exist, create a new subtopics with this data.
     */
    create: XOR<subtopicsCreateInput, subtopicsUncheckedCreateInput>
    /**
     * In case the subtopics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subtopicsUpdateInput, subtopicsUncheckedUpdateInput>
  }

  /**
   * subtopics delete
   */
  export type subtopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    /**
     * Filter which subtopics to delete.
     */
    where: subtopicsWhereUniqueInput
  }

  /**
   * subtopics deleteMany
   */
  export type subtopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subtopics to delete
     */
    where?: subtopicsWhereInput
  }

  /**
   * subtopics.questions
   */
  export type subtopics$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * subtopics without action
   */
  export type subtopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
  }


  /**
   * Model test_executions
   */

  export type AggregateTest_executions = {
    _count: Test_executionsCountAggregateOutputType | null
    _avg: Test_executionsAvgAggregateOutputType | null
    _sum: Test_executionsSumAggregateOutputType | null
    _min: Test_executionsMinAggregateOutputType | null
    _max: Test_executionsMaxAggregateOutputType | null
  }

  export type Test_executionsAvgAggregateOutputType = {
    execution_id: number | null
    test_plan_id: number | null
    student_id: number | null
    score: number | null
  }

  export type Test_executionsSumAggregateOutputType = {
    execution_id: bigint | null
    test_plan_id: bigint | null
    student_id: bigint | null
    score: number | null
  }

  export type Test_executionsMinAggregateOutputType = {
    execution_id: bigint | null
    test_plan_id: bigint | null
    student_id: bigint | null
    status: $Enums.test_executions_status | null
    started_at: Date | null
    completed_at: Date | null
    test_data: string | null
    score: number | null
  }

  export type Test_executionsMaxAggregateOutputType = {
    execution_id: bigint | null
    test_plan_id: bigint | null
    student_id: bigint | null
    status: $Enums.test_executions_status | null
    started_at: Date | null
    completed_at: Date | null
    test_data: string | null
    score: number | null
  }

  export type Test_executionsCountAggregateOutputType = {
    execution_id: number
    test_plan_id: number
    student_id: number
    status: number
    started_at: number
    completed_at: number
    test_data: number
    score: number
    _all: number
  }


  export type Test_executionsAvgAggregateInputType = {
    execution_id?: true
    test_plan_id?: true
    student_id?: true
    score?: true
  }

  export type Test_executionsSumAggregateInputType = {
    execution_id?: true
    test_plan_id?: true
    student_id?: true
    score?: true
  }

  export type Test_executionsMinAggregateInputType = {
    execution_id?: true
    test_plan_id?: true
    student_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    test_data?: true
    score?: true
  }

  export type Test_executionsMaxAggregateInputType = {
    execution_id?: true
    test_plan_id?: true
    student_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    test_data?: true
    score?: true
  }

  export type Test_executionsCountAggregateInputType = {
    execution_id?: true
    test_plan_id?: true
    student_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    test_data?: true
    score?: true
    _all?: true
  }

  export type Test_executionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_executions to aggregate.
     */
    where?: test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_executions to fetch.
     */
    orderBy?: test_executionsOrderByWithRelationInput | test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_executions
    **/
    _count?: true | Test_executionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_executionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_executionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_executionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_executionsMaxAggregateInputType
  }

  export type GetTest_executionsAggregateType<T extends Test_executionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_executions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_executions[P]>
      : GetScalarType<T[P], AggregateTest_executions[P]>
  }




  export type test_executionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_executionsWhereInput
    orderBy?: test_executionsOrderByWithAggregationInput | test_executionsOrderByWithAggregationInput[]
    by: Test_executionsScalarFieldEnum[] | Test_executionsScalarFieldEnum
    having?: test_executionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_executionsCountAggregateInputType | true
    _avg?: Test_executionsAvgAggregateInputType
    _sum?: Test_executionsSumAggregateInputType
    _min?: Test_executionsMinAggregateInputType
    _max?: Test_executionsMaxAggregateInputType
  }

  export type Test_executionsGroupByOutputType = {
    execution_id: bigint
    test_plan_id: bigint
    student_id: bigint
    status: $Enums.test_executions_status
    started_at: Date | null
    completed_at: Date | null
    test_data: string
    score: number | null
    _count: Test_executionsCountAggregateOutputType | null
    _avg: Test_executionsAvgAggregateOutputType | null
    _sum: Test_executionsSumAggregateOutputType | null
    _min: Test_executionsMinAggregateOutputType | null
    _max: Test_executionsMaxAggregateOutputType | null
  }

  type GetTest_executionsGroupByPayload<T extends test_executionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_executionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_executionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_executionsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_executionsGroupByOutputType[P]>
        }
      >
    >


  export type test_executionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    execution_id?: boolean
    test_plan_id?: boolean
    student_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    test_data?: boolean
    score?: boolean
    test_plans?: boolean | test_plansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_executions"]>


  export type test_executionsSelectScalar = {
    execution_id?: boolean
    test_plan_id?: boolean
    student_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    test_data?: boolean
    score?: boolean
  }

  export type test_executionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plans?: boolean | test_plansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $test_executionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_executions"
    objects: {
      test_plans: Prisma.$test_plansPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      execution_id: bigint
      test_plan_id: bigint
      student_id: bigint
      status: $Enums.test_executions_status
      started_at: Date | null
      completed_at: Date | null
      test_data: string
      score: number | null
    }, ExtArgs["result"]["test_executions"]>
    composites: {}
  }

  type test_executionsGetPayload<S extends boolean | null | undefined | test_executionsDefaultArgs> = $Result.GetResult<Prisma.$test_executionsPayload, S>

  type test_executionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<test_executionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Test_executionsCountAggregateInputType | true
    }

  export interface test_executionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_executions'], meta: { name: 'test_executions' } }
    /**
     * Find zero or one Test_executions that matches the filter.
     * @param {test_executionsFindUniqueArgs} args - Arguments to find a Test_executions
     * @example
     * // Get one Test_executions
     * const test_executions = await prisma.test_executions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_executionsFindUniqueArgs>(args: SelectSubset<T, test_executionsFindUniqueArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Test_executions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {test_executionsFindUniqueOrThrowArgs} args - Arguments to find a Test_executions
     * @example
     * // Get one Test_executions
     * const test_executions = await prisma.test_executions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_executionsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_executionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Test_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_executionsFindFirstArgs} args - Arguments to find a Test_executions
     * @example
     * // Get one Test_executions
     * const test_executions = await prisma.test_executions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_executionsFindFirstArgs>(args?: SelectSubset<T, test_executionsFindFirstArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Test_executions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_executionsFindFirstOrThrowArgs} args - Arguments to find a Test_executions
     * @example
     * // Get one Test_executions
     * const test_executions = await prisma.test_executions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_executionsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_executionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Test_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_executionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_executions
     * const test_executions = await prisma.test_executions.findMany()
     * 
     * // Get first 10 Test_executions
     * const test_executions = await prisma.test_executions.findMany({ take: 10 })
     * 
     * // Only select the `execution_id`
     * const test_executionsWithExecution_idOnly = await prisma.test_executions.findMany({ select: { execution_id: true } })
     * 
     */
    findMany<T extends test_executionsFindManyArgs>(args?: SelectSubset<T, test_executionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Test_executions.
     * @param {test_executionsCreateArgs} args - Arguments to create a Test_executions.
     * @example
     * // Create one Test_executions
     * const Test_executions = await prisma.test_executions.create({
     *   data: {
     *     // ... data to create a Test_executions
     *   }
     * })
     * 
     */
    create<T extends test_executionsCreateArgs>(args: SelectSubset<T, test_executionsCreateArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Test_executions.
     * @param {test_executionsCreateManyArgs} args - Arguments to create many Test_executions.
     * @example
     * // Create many Test_executions
     * const test_executions = await prisma.test_executions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_executionsCreateManyArgs>(args?: SelectSubset<T, test_executionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_executions.
     * @param {test_executionsDeleteArgs} args - Arguments to delete one Test_executions.
     * @example
     * // Delete one Test_executions
     * const Test_executions = await prisma.test_executions.delete({
     *   where: {
     *     // ... filter to delete one Test_executions
     *   }
     * })
     * 
     */
    delete<T extends test_executionsDeleteArgs>(args: SelectSubset<T, test_executionsDeleteArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Test_executions.
     * @param {test_executionsUpdateArgs} args - Arguments to update one Test_executions.
     * @example
     * // Update one Test_executions
     * const test_executions = await prisma.test_executions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_executionsUpdateArgs>(args: SelectSubset<T, test_executionsUpdateArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Test_executions.
     * @param {test_executionsDeleteManyArgs} args - Arguments to filter Test_executions to delete.
     * @example
     * // Delete a few Test_executions
     * const { count } = await prisma.test_executions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_executionsDeleteManyArgs>(args?: SelectSubset<T, test_executionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_executionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_executions
     * const test_executions = await prisma.test_executions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_executionsUpdateManyArgs>(args: SelectSubset<T, test_executionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_executions.
     * @param {test_executionsUpsertArgs} args - Arguments to update or create a Test_executions.
     * @example
     * // Update or create a Test_executions
     * const test_executions = await prisma.test_executions.upsert({
     *   create: {
     *     // ... data to create a Test_executions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_executions we want to update
     *   }
     * })
     */
    upsert<T extends test_executionsUpsertArgs>(args: SelectSubset<T, test_executionsUpsertArgs<ExtArgs>>): Prisma__test_executionsClient<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_executionsCountArgs} args - Arguments to filter Test_executions to count.
     * @example
     * // Count the number of Test_executions
     * const count = await prisma.test_executions.count({
     *   where: {
     *     // ... the filter for the Test_executions we want to count
     *   }
     * })
    **/
    count<T extends test_executionsCountArgs>(
      args?: Subset<T, test_executionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_executionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_executionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_executionsAggregateArgs>(args: Subset<T, Test_executionsAggregateArgs>): Prisma.PrismaPromise<GetTest_executionsAggregateType<T>>

    /**
     * Group by Test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_executionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_executionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_executionsGroupByArgs['orderBy'] }
        : { orderBy?: test_executionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_executionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_executionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_executions model
   */
  readonly fields: test_executionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_executions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_executionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_plans<T extends test_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_plansDefaultArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_executions model
   */ 
  interface test_executionsFieldRefs {
    readonly execution_id: FieldRef<"test_executions", 'BigInt'>
    readonly test_plan_id: FieldRef<"test_executions", 'BigInt'>
    readonly student_id: FieldRef<"test_executions", 'BigInt'>
    readonly status: FieldRef<"test_executions", 'test_executions_status'>
    readonly started_at: FieldRef<"test_executions", 'DateTime'>
    readonly completed_at: FieldRef<"test_executions", 'DateTime'>
    readonly test_data: FieldRef<"test_executions", 'String'>
    readonly score: FieldRef<"test_executions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * test_executions findUnique
   */
  export type test_executionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_executions to fetch.
     */
    where: test_executionsWhereUniqueInput
  }

  /**
   * test_executions findUniqueOrThrow
   */
  export type test_executionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_executions to fetch.
     */
    where: test_executionsWhereUniqueInput
  }

  /**
   * test_executions findFirst
   */
  export type test_executionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_executions to fetch.
     */
    where?: test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_executions to fetch.
     */
    orderBy?: test_executionsOrderByWithRelationInput | test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_executions.
     */
    cursor?: test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_executions.
     */
    distinct?: Test_executionsScalarFieldEnum | Test_executionsScalarFieldEnum[]
  }

  /**
   * test_executions findFirstOrThrow
   */
  export type test_executionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_executions to fetch.
     */
    where?: test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_executions to fetch.
     */
    orderBy?: test_executionsOrderByWithRelationInput | test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_executions.
     */
    cursor?: test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_executions.
     */
    distinct?: Test_executionsScalarFieldEnum | Test_executionsScalarFieldEnum[]
  }

  /**
   * test_executions findMany
   */
  export type test_executionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_executions to fetch.
     */
    where?: test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_executions to fetch.
     */
    orderBy?: test_executionsOrderByWithRelationInput | test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_executions.
     */
    cursor?: test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_executions.
     */
    skip?: number
    distinct?: Test_executionsScalarFieldEnum | Test_executionsScalarFieldEnum[]
  }

  /**
   * test_executions create
   */
  export type test_executionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_executions.
     */
    data: XOR<test_executionsCreateInput, test_executionsUncheckedCreateInput>
  }

  /**
   * test_executions createMany
   */
  export type test_executionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_executions.
     */
    data: test_executionsCreateManyInput | test_executionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_executions update
   */
  export type test_executionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_executions.
     */
    data: XOR<test_executionsUpdateInput, test_executionsUncheckedUpdateInput>
    /**
     * Choose, which test_executions to update.
     */
    where: test_executionsWhereUniqueInput
  }

  /**
   * test_executions updateMany
   */
  export type test_executionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_executions.
     */
    data: XOR<test_executionsUpdateManyMutationInput, test_executionsUncheckedUpdateManyInput>
    /**
     * Filter which test_executions to update
     */
    where?: test_executionsWhereInput
  }

  /**
   * test_executions upsert
   */
  export type test_executionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_executions to update in case it exists.
     */
    where: test_executionsWhereUniqueInput
    /**
     * In case the test_executions found by the `where` argument doesn't exist, create a new test_executions with this data.
     */
    create: XOR<test_executionsCreateInput, test_executionsUncheckedCreateInput>
    /**
     * In case the test_executions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_executionsUpdateInput, test_executionsUncheckedUpdateInput>
  }

  /**
   * test_executions delete
   */
  export type test_executionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    /**
     * Filter which test_executions to delete.
     */
    where: test_executionsWhereUniqueInput
  }

  /**
   * test_executions deleteMany
   */
  export type test_executionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_executions to delete
     */
    where?: test_executionsWhereInput
  }

  /**
   * test_executions without action
   */
  export type test_executionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
  }


  /**
   * Model test_plan_question_sets
   */

  export type AggregateTest_plan_question_sets = {
    _count: Test_plan_question_setsCountAggregateOutputType | null
    _avg: Test_plan_question_setsAvgAggregateOutputType | null
    _sum: Test_plan_question_setsSumAggregateOutputType | null
    _min: Test_plan_question_setsMinAggregateOutputType | null
    _max: Test_plan_question_setsMaxAggregateOutputType | null
  }

  export type Test_plan_question_setsAvgAggregateOutputType = {
    link_id: number | null
    test_plan_id: number | null
    set_id: number | null
    sequence: number | null
  }

  export type Test_plan_question_setsSumAggregateOutputType = {
    link_id: bigint | null
    test_plan_id: bigint | null
    set_id: bigint | null
    sequence: number | null
  }

  export type Test_plan_question_setsMinAggregateOutputType = {
    link_id: bigint | null
    test_plan_id: bigint | null
    set_id: bigint | null
    sequence: number | null
    created_at: Date | null
  }

  export type Test_plan_question_setsMaxAggregateOutputType = {
    link_id: bigint | null
    test_plan_id: bigint | null
    set_id: bigint | null
    sequence: number | null
    created_at: Date | null
  }

  export type Test_plan_question_setsCountAggregateOutputType = {
    link_id: number
    test_plan_id: number
    set_id: number
    sequence: number
    created_at: number
    _all: number
  }


  export type Test_plan_question_setsAvgAggregateInputType = {
    link_id?: true
    test_plan_id?: true
    set_id?: true
    sequence?: true
  }

  export type Test_plan_question_setsSumAggregateInputType = {
    link_id?: true
    test_plan_id?: true
    set_id?: true
    sequence?: true
  }

  export type Test_plan_question_setsMinAggregateInputType = {
    link_id?: true
    test_plan_id?: true
    set_id?: true
    sequence?: true
    created_at?: true
  }

  export type Test_plan_question_setsMaxAggregateInputType = {
    link_id?: true
    test_plan_id?: true
    set_id?: true
    sequence?: true
    created_at?: true
  }

  export type Test_plan_question_setsCountAggregateInputType = {
    link_id?: true
    test_plan_id?: true
    set_id?: true
    sequence?: true
    created_at?: true
    _all?: true
  }

  export type Test_plan_question_setsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plan_question_sets to aggregate.
     */
    where?: test_plan_question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_question_sets to fetch.
     */
    orderBy?: test_plan_question_setsOrderByWithRelationInput | test_plan_question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_plan_question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_question_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_plan_question_sets
    **/
    _count?: true | Test_plan_question_setsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_plan_question_setsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_plan_question_setsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_plan_question_setsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_plan_question_setsMaxAggregateInputType
  }

  export type GetTest_plan_question_setsAggregateType<T extends Test_plan_question_setsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_plan_question_sets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_plan_question_sets[P]>
      : GetScalarType<T[P], AggregateTest_plan_question_sets[P]>
  }




  export type test_plan_question_setsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_question_setsWhereInput
    orderBy?: test_plan_question_setsOrderByWithAggregationInput | test_plan_question_setsOrderByWithAggregationInput[]
    by: Test_plan_question_setsScalarFieldEnum[] | Test_plan_question_setsScalarFieldEnum
    having?: test_plan_question_setsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_plan_question_setsCountAggregateInputType | true
    _avg?: Test_plan_question_setsAvgAggregateInputType
    _sum?: Test_plan_question_setsSumAggregateInputType
    _min?: Test_plan_question_setsMinAggregateInputType
    _max?: Test_plan_question_setsMaxAggregateInputType
  }

  export type Test_plan_question_setsGroupByOutputType = {
    link_id: bigint
    test_plan_id: bigint
    set_id: bigint
    sequence: number
    created_at: Date
    _count: Test_plan_question_setsCountAggregateOutputType | null
    _avg: Test_plan_question_setsAvgAggregateOutputType | null
    _sum: Test_plan_question_setsSumAggregateOutputType | null
    _min: Test_plan_question_setsMinAggregateOutputType | null
    _max: Test_plan_question_setsMaxAggregateOutputType | null
  }

  type GetTest_plan_question_setsGroupByPayload<T extends test_plan_question_setsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_plan_question_setsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_plan_question_setsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_plan_question_setsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_plan_question_setsGroupByOutputType[P]>
        }
      >
    >


  export type test_plan_question_setsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    link_id?: boolean
    test_plan_id?: boolean
    set_id?: boolean
    sequence?: boolean
    created_at?: boolean
    test_plan?: boolean | test_plansDefaultArgs<ExtArgs>
    question_set?: boolean | question_setsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_plan_question_sets"]>


  export type test_plan_question_setsSelectScalar = {
    link_id?: boolean
    test_plan_id?: boolean
    set_id?: boolean
    sequence?: boolean
    created_at?: boolean
  }

  export type test_plan_question_setsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plan?: boolean | test_plansDefaultArgs<ExtArgs>
    question_set?: boolean | question_setsDefaultArgs<ExtArgs>
  }

  export type $test_plan_question_setsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_plan_question_sets"
    objects: {
      test_plan: Prisma.$test_plansPayload<ExtArgs>
      question_set: Prisma.$question_setsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      link_id: bigint
      test_plan_id: bigint
      set_id: bigint
      sequence: number
      created_at: Date
    }, ExtArgs["result"]["test_plan_question_sets"]>
    composites: {}
  }

  type test_plan_question_setsGetPayload<S extends boolean | null | undefined | test_plan_question_setsDefaultArgs> = $Result.GetResult<Prisma.$test_plan_question_setsPayload, S>

  type test_plan_question_setsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<test_plan_question_setsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Test_plan_question_setsCountAggregateInputType | true
    }

  export interface test_plan_question_setsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_plan_question_sets'], meta: { name: 'test_plan_question_sets' } }
    /**
     * Find zero or one Test_plan_question_sets that matches the filter.
     * @param {test_plan_question_setsFindUniqueArgs} args - Arguments to find a Test_plan_question_sets
     * @example
     * // Get one Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_plan_question_setsFindUniqueArgs>(args: SelectSubset<T, test_plan_question_setsFindUniqueArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Test_plan_question_sets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {test_plan_question_setsFindUniqueOrThrowArgs} args - Arguments to find a Test_plan_question_sets
     * @example
     * // Get one Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_plan_question_setsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_plan_question_setsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Test_plan_question_sets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_question_setsFindFirstArgs} args - Arguments to find a Test_plan_question_sets
     * @example
     * // Get one Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_plan_question_setsFindFirstArgs>(args?: SelectSubset<T, test_plan_question_setsFindFirstArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Test_plan_question_sets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_question_setsFindFirstOrThrowArgs} args - Arguments to find a Test_plan_question_sets
     * @example
     * // Get one Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_plan_question_setsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_plan_question_setsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Test_plan_question_sets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_question_setsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.findMany()
     * 
     * // Get first 10 Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.findMany({ take: 10 })
     * 
     * // Only select the `link_id`
     * const test_plan_question_setsWithLink_idOnly = await prisma.test_plan_question_sets.findMany({ select: { link_id: true } })
     * 
     */
    findMany<T extends test_plan_question_setsFindManyArgs>(args?: SelectSubset<T, test_plan_question_setsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Test_plan_question_sets.
     * @param {test_plan_question_setsCreateArgs} args - Arguments to create a Test_plan_question_sets.
     * @example
     * // Create one Test_plan_question_sets
     * const Test_plan_question_sets = await prisma.test_plan_question_sets.create({
     *   data: {
     *     // ... data to create a Test_plan_question_sets
     *   }
     * })
     * 
     */
    create<T extends test_plan_question_setsCreateArgs>(args: SelectSubset<T, test_plan_question_setsCreateArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Test_plan_question_sets.
     * @param {test_plan_question_setsCreateManyArgs} args - Arguments to create many Test_plan_question_sets.
     * @example
     * // Create many Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_plan_question_setsCreateManyArgs>(args?: SelectSubset<T, test_plan_question_setsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_plan_question_sets.
     * @param {test_plan_question_setsDeleteArgs} args - Arguments to delete one Test_plan_question_sets.
     * @example
     * // Delete one Test_plan_question_sets
     * const Test_plan_question_sets = await prisma.test_plan_question_sets.delete({
     *   where: {
     *     // ... filter to delete one Test_plan_question_sets
     *   }
     * })
     * 
     */
    delete<T extends test_plan_question_setsDeleteArgs>(args: SelectSubset<T, test_plan_question_setsDeleteArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Test_plan_question_sets.
     * @param {test_plan_question_setsUpdateArgs} args - Arguments to update one Test_plan_question_sets.
     * @example
     * // Update one Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_plan_question_setsUpdateArgs>(args: SelectSubset<T, test_plan_question_setsUpdateArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Test_plan_question_sets.
     * @param {test_plan_question_setsDeleteManyArgs} args - Arguments to filter Test_plan_question_sets to delete.
     * @example
     * // Delete a few Test_plan_question_sets
     * const { count } = await prisma.test_plan_question_sets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_plan_question_setsDeleteManyArgs>(args?: SelectSubset<T, test_plan_question_setsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_plan_question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_question_setsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_plan_question_setsUpdateManyArgs>(args: SelectSubset<T, test_plan_question_setsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_plan_question_sets.
     * @param {test_plan_question_setsUpsertArgs} args - Arguments to update or create a Test_plan_question_sets.
     * @example
     * // Update or create a Test_plan_question_sets
     * const test_plan_question_sets = await prisma.test_plan_question_sets.upsert({
     *   create: {
     *     // ... data to create a Test_plan_question_sets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_plan_question_sets we want to update
     *   }
     * })
     */
    upsert<T extends test_plan_question_setsUpsertArgs>(args: SelectSubset<T, test_plan_question_setsUpsertArgs<ExtArgs>>): Prisma__test_plan_question_setsClient<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Test_plan_question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_question_setsCountArgs} args - Arguments to filter Test_plan_question_sets to count.
     * @example
     * // Count the number of Test_plan_question_sets
     * const count = await prisma.test_plan_question_sets.count({
     *   where: {
     *     // ... the filter for the Test_plan_question_sets we want to count
     *   }
     * })
    **/
    count<T extends test_plan_question_setsCountArgs>(
      args?: Subset<T, test_plan_question_setsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_plan_question_setsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_plan_question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_plan_question_setsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_plan_question_setsAggregateArgs>(args: Subset<T, Test_plan_question_setsAggregateArgs>): Prisma.PrismaPromise<GetTest_plan_question_setsAggregateType<T>>

    /**
     * Group by Test_plan_question_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_question_setsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_plan_question_setsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_plan_question_setsGroupByArgs['orderBy'] }
        : { orderBy?: test_plan_question_setsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_plan_question_setsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_plan_question_setsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_plan_question_sets model
   */
  readonly fields: test_plan_question_setsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_plan_question_sets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_plan_question_setsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_plan<T extends test_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_plansDefaultArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question_set<T extends question_setsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, question_setsDefaultArgs<ExtArgs>>): Prisma__question_setsClient<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_plan_question_sets model
   */ 
  interface test_plan_question_setsFieldRefs {
    readonly link_id: FieldRef<"test_plan_question_sets", 'BigInt'>
    readonly test_plan_id: FieldRef<"test_plan_question_sets", 'BigInt'>
    readonly set_id: FieldRef<"test_plan_question_sets", 'BigInt'>
    readonly sequence: FieldRef<"test_plan_question_sets", 'Int'>
    readonly created_at: FieldRef<"test_plan_question_sets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_plan_question_sets findUnique
   */
  export type test_plan_question_setsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_question_sets to fetch.
     */
    where: test_plan_question_setsWhereUniqueInput
  }

  /**
   * test_plan_question_sets findUniqueOrThrow
   */
  export type test_plan_question_setsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_question_sets to fetch.
     */
    where: test_plan_question_setsWhereUniqueInput
  }

  /**
   * test_plan_question_sets findFirst
   */
  export type test_plan_question_setsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_question_sets to fetch.
     */
    where?: test_plan_question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_question_sets to fetch.
     */
    orderBy?: test_plan_question_setsOrderByWithRelationInput | test_plan_question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plan_question_sets.
     */
    cursor?: test_plan_question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_question_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plan_question_sets.
     */
    distinct?: Test_plan_question_setsScalarFieldEnum | Test_plan_question_setsScalarFieldEnum[]
  }

  /**
   * test_plan_question_sets findFirstOrThrow
   */
  export type test_plan_question_setsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_question_sets to fetch.
     */
    where?: test_plan_question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_question_sets to fetch.
     */
    orderBy?: test_plan_question_setsOrderByWithRelationInput | test_plan_question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plan_question_sets.
     */
    cursor?: test_plan_question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_question_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plan_question_sets.
     */
    distinct?: Test_plan_question_setsScalarFieldEnum | Test_plan_question_setsScalarFieldEnum[]
  }

  /**
   * test_plan_question_sets findMany
   */
  export type test_plan_question_setsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_question_sets to fetch.
     */
    where?: test_plan_question_setsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_question_sets to fetch.
     */
    orderBy?: test_plan_question_setsOrderByWithRelationInput | test_plan_question_setsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_plan_question_sets.
     */
    cursor?: test_plan_question_setsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_question_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_question_sets.
     */
    skip?: number
    distinct?: Test_plan_question_setsScalarFieldEnum | Test_plan_question_setsScalarFieldEnum[]
  }

  /**
   * test_plan_question_sets create
   */
  export type test_plan_question_setsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_plan_question_sets.
     */
    data: XOR<test_plan_question_setsCreateInput, test_plan_question_setsUncheckedCreateInput>
  }

  /**
   * test_plan_question_sets createMany
   */
  export type test_plan_question_setsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_plan_question_sets.
     */
    data: test_plan_question_setsCreateManyInput | test_plan_question_setsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_plan_question_sets update
   */
  export type test_plan_question_setsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_plan_question_sets.
     */
    data: XOR<test_plan_question_setsUpdateInput, test_plan_question_setsUncheckedUpdateInput>
    /**
     * Choose, which test_plan_question_sets to update.
     */
    where: test_plan_question_setsWhereUniqueInput
  }

  /**
   * test_plan_question_sets updateMany
   */
  export type test_plan_question_setsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_plan_question_sets.
     */
    data: XOR<test_plan_question_setsUpdateManyMutationInput, test_plan_question_setsUncheckedUpdateManyInput>
    /**
     * Filter which test_plan_question_sets to update
     */
    where?: test_plan_question_setsWhereInput
  }

  /**
   * test_plan_question_sets upsert
   */
  export type test_plan_question_setsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_plan_question_sets to update in case it exists.
     */
    where: test_plan_question_setsWhereUniqueInput
    /**
     * In case the test_plan_question_sets found by the `where` argument doesn't exist, create a new test_plan_question_sets with this data.
     */
    create: XOR<test_plan_question_setsCreateInput, test_plan_question_setsUncheckedCreateInput>
    /**
     * In case the test_plan_question_sets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_plan_question_setsUpdateInput, test_plan_question_setsUncheckedUpdateInput>
  }

  /**
   * test_plan_question_sets delete
   */
  export type test_plan_question_setsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    /**
     * Filter which test_plan_question_sets to delete.
     */
    where: test_plan_question_setsWhereUniqueInput
  }

  /**
   * test_plan_question_sets deleteMany
   */
  export type test_plan_question_setsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plan_question_sets to delete
     */
    where?: test_plan_question_setsWhereInput
  }

  /**
   * test_plan_question_sets without action
   */
  export type test_plan_question_setsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
  }


  /**
   * Model test_plans
   */

  export type AggregateTest_plans = {
    _count: Test_plansCountAggregateOutputType | null
    _avg: Test_plansAvgAggregateOutputType | null
    _sum: Test_plansSumAggregateOutputType | null
    _min: Test_plansMinAggregateOutputType | null
    _max: Test_plansMaxAggregateOutputType | null
  }

  export type Test_plansAvgAggregateOutputType = {
    test_plan_id: number | null
    template_id: number | null
    board_id: number | null
    time_limit: number | null
    student_id: number | null
    planned_by: number | null
  }

  export type Test_plansSumAggregateOutputType = {
    test_plan_id: bigint | null
    template_id: bigint | null
    board_id: number | null
    time_limit: number | null
    student_id: bigint | null
    planned_by: bigint | null
  }

  export type Test_plansMinAggregateOutputType = {
    test_plan_id: bigint | null
    template_id: bigint | null
    board_id: number | null
    test_type: $Enums.test_plans_test_type | null
    timing_type: $Enums.test_plans_timing_type | null
    time_limit: number | null
    student_id: bigint | null
    planned_by: bigint | null
    planned_at: Date | null
    configuration: string | null
  }

  export type Test_plansMaxAggregateOutputType = {
    test_plan_id: bigint | null
    template_id: bigint | null
    board_id: number | null
    test_type: $Enums.test_plans_test_type | null
    timing_type: $Enums.test_plans_timing_type | null
    time_limit: number | null
    student_id: bigint | null
    planned_by: bigint | null
    planned_at: Date | null
    configuration: string | null
  }

  export type Test_plansCountAggregateOutputType = {
    test_plan_id: number
    template_id: number
    board_id: number
    test_type: number
    timing_type: number
    time_limit: number
    student_id: number
    planned_by: number
    planned_at: number
    configuration: number
    _all: number
  }


  export type Test_plansAvgAggregateInputType = {
    test_plan_id?: true
    template_id?: true
    board_id?: true
    time_limit?: true
    student_id?: true
    planned_by?: true
  }

  export type Test_plansSumAggregateInputType = {
    test_plan_id?: true
    template_id?: true
    board_id?: true
    time_limit?: true
    student_id?: true
    planned_by?: true
  }

  export type Test_plansMinAggregateInputType = {
    test_plan_id?: true
    template_id?: true
    board_id?: true
    test_type?: true
    timing_type?: true
    time_limit?: true
    student_id?: true
    planned_by?: true
    planned_at?: true
    configuration?: true
  }

  export type Test_plansMaxAggregateInputType = {
    test_plan_id?: true
    template_id?: true
    board_id?: true
    test_type?: true
    timing_type?: true
    time_limit?: true
    student_id?: true
    planned_by?: true
    planned_at?: true
    configuration?: true
  }

  export type Test_plansCountAggregateInputType = {
    test_plan_id?: true
    template_id?: true
    board_id?: true
    test_type?: true
    timing_type?: true
    time_limit?: true
    student_id?: true
    planned_by?: true
    planned_at?: true
    configuration?: true
    _all?: true
  }

  export type Test_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plans to aggregate.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_plans
    **/
    _count?: true | Test_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_plansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_plansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_plansMaxAggregateInputType
  }

  export type GetTest_plansAggregateType<T extends Test_plansAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_plans[P]>
      : GetScalarType<T[P], AggregateTest_plans[P]>
  }




  export type test_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithAggregationInput | test_plansOrderByWithAggregationInput[]
    by: Test_plansScalarFieldEnum[] | Test_plansScalarFieldEnum
    having?: test_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_plansCountAggregateInputType | true
    _avg?: Test_plansAvgAggregateInputType
    _sum?: Test_plansSumAggregateInputType
    _min?: Test_plansMinAggregateInputType
    _max?: Test_plansMaxAggregateInputType
  }

  export type Test_plansGroupByOutputType = {
    test_plan_id: bigint
    template_id: bigint | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit: number | null
    student_id: bigint
    planned_by: bigint
    planned_at: Date | null
    configuration: string
    _count: Test_plansCountAggregateOutputType | null
    _avg: Test_plansAvgAggregateOutputType | null
    _sum: Test_plansSumAggregateOutputType | null
    _min: Test_plansMinAggregateOutputType | null
    _max: Test_plansMaxAggregateOutputType | null
  }

  type GetTest_plansGroupByPayload<T extends test_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Test_plansGroupByOutputType[P]>
        }
      >
    >


  export type test_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_plan_id?: boolean
    template_id?: boolean
    board_id?: boolean
    test_type?: boolean
    timing_type?: boolean
    time_limit?: boolean
    student_id?: boolean
    planned_by?: boolean
    planned_at?: boolean
    configuration?: boolean
    test_executions?: boolean | test_plans$test_executionsArgs<ExtArgs>
    test_templates?: boolean | test_plans$test_templatesArgs<ExtArgs>
    exam_boards?: boolean | exam_boardsDefaultArgs<ExtArgs>
    student?: boolean | usersDefaultArgs<ExtArgs>
    planner?: boolean | usersDefaultArgs<ExtArgs>
    study_groups?: boolean | test_plans$study_groupsArgs<ExtArgs>
    assignments?: boolean | test_plans$assignmentsArgs<ExtArgs>
    question_set_links?: boolean | test_plans$question_set_linksArgs<ExtArgs>
    _count?: boolean | Test_plansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_plans"]>


  export type test_plansSelectScalar = {
    test_plan_id?: boolean
    template_id?: boolean
    board_id?: boolean
    test_type?: boolean
    timing_type?: boolean
    time_limit?: boolean
    student_id?: boolean
    planned_by?: boolean
    planned_at?: boolean
    configuration?: boolean
  }

  export type test_plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_executions?: boolean | test_plans$test_executionsArgs<ExtArgs>
    test_templates?: boolean | test_plans$test_templatesArgs<ExtArgs>
    exam_boards?: boolean | exam_boardsDefaultArgs<ExtArgs>
    student?: boolean | usersDefaultArgs<ExtArgs>
    planner?: boolean | usersDefaultArgs<ExtArgs>
    study_groups?: boolean | test_plans$study_groupsArgs<ExtArgs>
    assignments?: boolean | test_plans$assignmentsArgs<ExtArgs>
    question_set_links?: boolean | test_plans$question_set_linksArgs<ExtArgs>
    _count?: boolean | Test_plansCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_plans"
    objects: {
      test_executions: Prisma.$test_executionsPayload<ExtArgs>[]
      test_templates: Prisma.$test_templatesPayload<ExtArgs> | null
      exam_boards: Prisma.$exam_boardsPayload<ExtArgs>
      student: Prisma.$usersPayload<ExtArgs>
      planner: Prisma.$usersPayload<ExtArgs>
      study_groups: Prisma.$study_groupsPayload<ExtArgs>[]
      assignments: Prisma.$test_assignmentsPayload<ExtArgs>[]
      question_set_links: Prisma.$test_plan_question_setsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      test_plan_id: bigint
      template_id: bigint | null
      board_id: number
      test_type: $Enums.test_plans_test_type
      timing_type: $Enums.test_plans_timing_type
      time_limit: number | null
      student_id: bigint
      planned_by: bigint
      planned_at: Date | null
      configuration: string
    }, ExtArgs["result"]["test_plans"]>
    composites: {}
  }

  type test_plansGetPayload<S extends boolean | null | undefined | test_plansDefaultArgs> = $Result.GetResult<Prisma.$test_plansPayload, S>

  type test_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<test_plansFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Test_plansCountAggregateInputType | true
    }

  export interface test_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_plans'], meta: { name: 'test_plans' } }
    /**
     * Find zero or one Test_plans that matches the filter.
     * @param {test_plansFindUniqueArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_plansFindUniqueArgs>(args: SelectSubset<T, test_plansFindUniqueArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Test_plans that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {test_plansFindUniqueOrThrowArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, test_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Test_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansFindFirstArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_plansFindFirstArgs>(args?: SelectSubset<T, test_plansFindFirstArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Test_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansFindFirstOrThrowArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, test_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Test_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_plans
     * const test_plans = await prisma.test_plans.findMany()
     * 
     * // Get first 10 Test_plans
     * const test_plans = await prisma.test_plans.findMany({ take: 10 })
     * 
     * // Only select the `test_plan_id`
     * const test_plansWithTest_plan_idOnly = await prisma.test_plans.findMany({ select: { test_plan_id: true } })
     * 
     */
    findMany<T extends test_plansFindManyArgs>(args?: SelectSubset<T, test_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Test_plans.
     * @param {test_plansCreateArgs} args - Arguments to create a Test_plans.
     * @example
     * // Create one Test_plans
     * const Test_plans = await prisma.test_plans.create({
     *   data: {
     *     // ... data to create a Test_plans
     *   }
     * })
     * 
     */
    create<T extends test_plansCreateArgs>(args: SelectSubset<T, test_plansCreateArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Test_plans.
     * @param {test_plansCreateManyArgs} args - Arguments to create many Test_plans.
     * @example
     * // Create many Test_plans
     * const test_plans = await prisma.test_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_plansCreateManyArgs>(args?: SelectSubset<T, test_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_plans.
     * @param {test_plansDeleteArgs} args - Arguments to delete one Test_plans.
     * @example
     * // Delete one Test_plans
     * const Test_plans = await prisma.test_plans.delete({
     *   where: {
     *     // ... filter to delete one Test_plans
     *   }
     * })
     * 
     */
    delete<T extends test_plansDeleteArgs>(args: SelectSubset<T, test_plansDeleteArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Test_plans.
     * @param {test_plansUpdateArgs} args - Arguments to update one Test_plans.
     * @example
     * // Update one Test_plans
     * const test_plans = await prisma.test_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_plansUpdateArgs>(args: SelectSubset<T, test_plansUpdateArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Test_plans.
     * @param {test_plansDeleteManyArgs} args - Arguments to filter Test_plans to delete.
     * @example
     * // Delete a few Test_plans
     * const { count } = await prisma.test_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_plansDeleteManyArgs>(args?: SelectSubset<T, test_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_plans
     * const test_plans = await prisma.test_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_plansUpdateManyArgs>(args: SelectSubset<T, test_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_plans.
     * @param {test_plansUpsertArgs} args - Arguments to update or create a Test_plans.
     * @example
     * // Update or create a Test_plans
     * const test_plans = await prisma.test_plans.upsert({
     *   create: {
     *     // ... data to create a Test_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_plans we want to update
     *   }
     * })
     */
    upsert<T extends test_plansUpsertArgs>(args: SelectSubset<T, test_plansUpsertArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansCountArgs} args - Arguments to filter Test_plans to count.
     * @example
     * // Count the number of Test_plans
     * const count = await prisma.test_plans.count({
     *   where: {
     *     // ... the filter for the Test_plans we want to count
     *   }
     * })
    **/
    count<T extends test_plansCountArgs>(
      args?: Subset<T, test_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_plansAggregateArgs>(args: Subset<T, Test_plansAggregateArgs>): Prisma.PrismaPromise<GetTest_plansAggregateType<T>>

    /**
     * Group by Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_plansGroupByArgs['orderBy'] }
        : { orderBy?: test_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_plans model
   */
  readonly fields: test_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_executions<T extends test_plans$test_executionsArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$test_executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findMany"> | Null>
    test_templates<T extends test_plans$test_templatesArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$test_templatesArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    exam_boards<T extends exam_boardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, exam_boardsDefaultArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    planner<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    study_groups<T extends test_plans$study_groupsArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$study_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends test_plans$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findMany"> | Null>
    question_set_links<T extends test_plans$question_set_linksArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$question_set_linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_question_setsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_plans model
   */ 
  interface test_plansFieldRefs {
    readonly test_plan_id: FieldRef<"test_plans", 'BigInt'>
    readonly template_id: FieldRef<"test_plans", 'BigInt'>
    readonly board_id: FieldRef<"test_plans", 'Int'>
    readonly test_type: FieldRef<"test_plans", 'test_plans_test_type'>
    readonly timing_type: FieldRef<"test_plans", 'test_plans_timing_type'>
    readonly time_limit: FieldRef<"test_plans", 'Int'>
    readonly student_id: FieldRef<"test_plans", 'BigInt'>
    readonly planned_by: FieldRef<"test_plans", 'BigInt'>
    readonly planned_at: FieldRef<"test_plans", 'DateTime'>
    readonly configuration: FieldRef<"test_plans", 'String'>
  }
    

  // Custom InputTypes
  /**
   * test_plans findUnique
   */
  export type test_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans findUniqueOrThrow
   */
  export type test_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans findFirst
   */
  export type test_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plans.
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plans.
     */
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_plans findFirstOrThrow
   */
  export type test_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plans.
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plans.
     */
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_plans findMany
   */
  export type test_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_plans.
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_plans create
   */
  export type test_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * The data needed to create a test_plans.
     */
    data: XOR<test_plansCreateInput, test_plansUncheckedCreateInput>
  }

  /**
   * test_plans createMany
   */
  export type test_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_plans.
     */
    data: test_plansCreateManyInput | test_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_plans update
   */
  export type test_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * The data needed to update a test_plans.
     */
    data: XOR<test_plansUpdateInput, test_plansUncheckedUpdateInput>
    /**
     * Choose, which test_plans to update.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans updateMany
   */
  export type test_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_plans.
     */
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyInput>
    /**
     * Filter which test_plans to update
     */
    where?: test_plansWhereInput
  }

  /**
   * test_plans upsert
   */
  export type test_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * The filter to search for the test_plans to update in case it exists.
     */
    where: test_plansWhereUniqueInput
    /**
     * In case the test_plans found by the `where` argument doesn't exist, create a new test_plans with this data.
     */
    create: XOR<test_plansCreateInput, test_plansUncheckedCreateInput>
    /**
     * In case the test_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_plansUpdateInput, test_plansUncheckedUpdateInput>
  }

  /**
   * test_plans delete
   */
  export type test_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter which test_plans to delete.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans deleteMany
   */
  export type test_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plans to delete
     */
    where?: test_plansWhereInput
  }

  /**
   * test_plans.test_executions
   */
  export type test_plans$test_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    where?: test_executionsWhereInput
    orderBy?: test_executionsOrderByWithRelationInput | test_executionsOrderByWithRelationInput[]
    cursor?: test_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_executionsScalarFieldEnum | Test_executionsScalarFieldEnum[]
  }

  /**
   * test_plans.test_templates
   */
  export type test_plans$test_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    where?: test_templatesWhereInput
  }

  /**
   * test_plans.study_groups
   */
  export type test_plans$study_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    where?: study_groupsWhereInput
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    cursor?: study_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_groupsScalarFieldEnum | Study_groupsScalarFieldEnum[]
  }

  /**
   * test_plans.assignments
   */
  export type test_plans$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    where?: test_assignmentsWhereInput
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    cursor?: test_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * test_plans.question_set_links
   */
  export type test_plans$question_set_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_question_sets
     */
    select?: test_plan_question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_question_setsInclude<ExtArgs> | null
    where?: test_plan_question_setsWhereInput
    orderBy?: test_plan_question_setsOrderByWithRelationInput | test_plan_question_setsOrderByWithRelationInput[]
    cursor?: test_plan_question_setsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plan_question_setsScalarFieldEnum | Test_plan_question_setsScalarFieldEnum[]
  }

  /**
   * test_plans without action
   */
  export type test_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
  }


  /**
   * Model test_templates
   */

  export type AggregateTest_templates = {
    _count: Test_templatesCountAggregateOutputType | null
    _avg: Test_templatesAvgAggregateOutputType | null
    _sum: Test_templatesSumAggregateOutputType | null
    _min: Test_templatesMinAggregateOutputType | null
    _max: Test_templatesMaxAggregateOutputType | null
  }

  export type Test_templatesAvgAggregateOutputType = {
    template_id: number | null
    created_by: number | null
    board_id: number | null
    time_limit: number | null
  }

  export type Test_templatesSumAggregateOutputType = {
    template_id: bigint | null
    created_by: bigint | null
    board_id: number | null
    time_limit: number | null
  }

  export type Test_templatesMinAggregateOutputType = {
    template_id: bigint | null
    template_name: string | null
    source: $Enums.test_templates_source | null
    created_by: bigint | null
    created_at: Date | null
    board_id: number | null
    test_type: $Enums.test_templates_test_type | null
    timing_type: $Enums.test_templates_timing_type | null
    time_limit: number | null
    configuration: string | null
    active: boolean | null
  }

  export type Test_templatesMaxAggregateOutputType = {
    template_id: bigint | null
    template_name: string | null
    source: $Enums.test_templates_source | null
    created_by: bigint | null
    created_at: Date | null
    board_id: number | null
    test_type: $Enums.test_templates_test_type | null
    timing_type: $Enums.test_templates_timing_type | null
    time_limit: number | null
    configuration: string | null
    active: boolean | null
  }

  export type Test_templatesCountAggregateOutputType = {
    template_id: number
    template_name: number
    source: number
    created_by: number
    created_at: number
    board_id: number
    test_type: number
    timing_type: number
    time_limit: number
    configuration: number
    active: number
    _all: number
  }


  export type Test_templatesAvgAggregateInputType = {
    template_id?: true
    created_by?: true
    board_id?: true
    time_limit?: true
  }

  export type Test_templatesSumAggregateInputType = {
    template_id?: true
    created_by?: true
    board_id?: true
    time_limit?: true
  }

  export type Test_templatesMinAggregateInputType = {
    template_id?: true
    template_name?: true
    source?: true
    created_by?: true
    created_at?: true
    board_id?: true
    test_type?: true
    timing_type?: true
    time_limit?: true
    configuration?: true
    active?: true
  }

  export type Test_templatesMaxAggregateInputType = {
    template_id?: true
    template_name?: true
    source?: true
    created_by?: true
    created_at?: true
    board_id?: true
    test_type?: true
    timing_type?: true
    time_limit?: true
    configuration?: true
    active?: true
  }

  export type Test_templatesCountAggregateInputType = {
    template_id?: true
    template_name?: true
    source?: true
    created_by?: true
    created_at?: true
    board_id?: true
    test_type?: true
    timing_type?: true
    time_limit?: true
    configuration?: true
    active?: true
    _all?: true
  }

  export type Test_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_templates to aggregate.
     */
    where?: test_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_templates to fetch.
     */
    orderBy?: test_templatesOrderByWithRelationInput | test_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_templates
    **/
    _count?: true | Test_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_templatesMaxAggregateInputType
  }

  export type GetTest_templatesAggregateType<T extends Test_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_templates[P]>
      : GetScalarType<T[P], AggregateTest_templates[P]>
  }




  export type test_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_templatesWhereInput
    orderBy?: test_templatesOrderByWithAggregationInput | test_templatesOrderByWithAggregationInput[]
    by: Test_templatesScalarFieldEnum[] | Test_templatesScalarFieldEnum
    having?: test_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_templatesCountAggregateInputType | true
    _avg?: Test_templatesAvgAggregateInputType
    _sum?: Test_templatesSumAggregateInputType
    _min?: Test_templatesMinAggregateInputType
    _max?: Test_templatesMaxAggregateInputType
  }

  export type Test_templatesGroupByOutputType = {
    template_id: bigint
    template_name: string
    source: $Enums.test_templates_source
    created_by: bigint
    created_at: Date | null
    board_id: number
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit: number | null
    configuration: string
    active: boolean | null
    _count: Test_templatesCountAggregateOutputType | null
    _avg: Test_templatesAvgAggregateOutputType | null
    _sum: Test_templatesSumAggregateOutputType | null
    _min: Test_templatesMinAggregateOutputType | null
    _max: Test_templatesMaxAggregateOutputType | null
  }

  type GetTest_templatesGroupByPayload<T extends test_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Test_templatesGroupByOutputType[P]>
        }
      >
    >


  export type test_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    template_id?: boolean
    template_name?: boolean
    source?: boolean
    created_by?: boolean
    created_at?: boolean
    board_id?: boolean
    test_type?: boolean
    timing_type?: boolean
    time_limit?: boolean
    configuration?: boolean
    active?: boolean
    test_plans?: boolean | test_templates$test_plansArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    exam_boards?: boolean | exam_boardsDefaultArgs<ExtArgs>
    _count?: boolean | Test_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_templates"]>


  export type test_templatesSelectScalar = {
    template_id?: boolean
    template_name?: boolean
    source?: boolean
    created_by?: boolean
    created_at?: boolean
    board_id?: boolean
    test_type?: boolean
    timing_type?: boolean
    time_limit?: boolean
    configuration?: boolean
    active?: boolean
  }

  export type test_templatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plans?: boolean | test_templates$test_plansArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    exam_boards?: boolean | exam_boardsDefaultArgs<ExtArgs>
    _count?: boolean | Test_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_templates"
    objects: {
      test_plans: Prisma.$test_plansPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      exam_boards: Prisma.$exam_boardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      template_id: bigint
      template_name: string
      source: $Enums.test_templates_source
      created_by: bigint
      created_at: Date | null
      board_id: number
      test_type: $Enums.test_templates_test_type
      timing_type: $Enums.test_templates_timing_type
      time_limit: number | null
      configuration: string
      active: boolean | null
    }, ExtArgs["result"]["test_templates"]>
    composites: {}
  }

  type test_templatesGetPayload<S extends boolean | null | undefined | test_templatesDefaultArgs> = $Result.GetResult<Prisma.$test_templatesPayload, S>

  type test_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<test_templatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Test_templatesCountAggregateInputType | true
    }

  export interface test_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_templates'], meta: { name: 'test_templates' } }
    /**
     * Find zero or one Test_templates that matches the filter.
     * @param {test_templatesFindUniqueArgs} args - Arguments to find a Test_templates
     * @example
     * // Get one Test_templates
     * const test_templates = await prisma.test_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_templatesFindUniqueArgs>(args: SelectSubset<T, test_templatesFindUniqueArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Test_templates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {test_templatesFindUniqueOrThrowArgs} args - Arguments to find a Test_templates
     * @example
     * // Get one Test_templates
     * const test_templates = await prisma.test_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, test_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Test_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_templatesFindFirstArgs} args - Arguments to find a Test_templates
     * @example
     * // Get one Test_templates
     * const test_templates = await prisma.test_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_templatesFindFirstArgs>(args?: SelectSubset<T, test_templatesFindFirstArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Test_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_templatesFindFirstOrThrowArgs} args - Arguments to find a Test_templates
     * @example
     * // Get one Test_templates
     * const test_templates = await prisma.test_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, test_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Test_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_templates
     * const test_templates = await prisma.test_templates.findMany()
     * 
     * // Get first 10 Test_templates
     * const test_templates = await prisma.test_templates.findMany({ take: 10 })
     * 
     * // Only select the `template_id`
     * const test_templatesWithTemplate_idOnly = await prisma.test_templates.findMany({ select: { template_id: true } })
     * 
     */
    findMany<T extends test_templatesFindManyArgs>(args?: SelectSubset<T, test_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Test_templates.
     * @param {test_templatesCreateArgs} args - Arguments to create a Test_templates.
     * @example
     * // Create one Test_templates
     * const Test_templates = await prisma.test_templates.create({
     *   data: {
     *     // ... data to create a Test_templates
     *   }
     * })
     * 
     */
    create<T extends test_templatesCreateArgs>(args: SelectSubset<T, test_templatesCreateArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Test_templates.
     * @param {test_templatesCreateManyArgs} args - Arguments to create many Test_templates.
     * @example
     * // Create many Test_templates
     * const test_templates = await prisma.test_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_templatesCreateManyArgs>(args?: SelectSubset<T, test_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_templates.
     * @param {test_templatesDeleteArgs} args - Arguments to delete one Test_templates.
     * @example
     * // Delete one Test_templates
     * const Test_templates = await prisma.test_templates.delete({
     *   where: {
     *     // ... filter to delete one Test_templates
     *   }
     * })
     * 
     */
    delete<T extends test_templatesDeleteArgs>(args: SelectSubset<T, test_templatesDeleteArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Test_templates.
     * @param {test_templatesUpdateArgs} args - Arguments to update one Test_templates.
     * @example
     * // Update one Test_templates
     * const test_templates = await prisma.test_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_templatesUpdateArgs>(args: SelectSubset<T, test_templatesUpdateArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Test_templates.
     * @param {test_templatesDeleteManyArgs} args - Arguments to filter Test_templates to delete.
     * @example
     * // Delete a few Test_templates
     * const { count } = await prisma.test_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_templatesDeleteManyArgs>(args?: SelectSubset<T, test_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_templates
     * const test_templates = await prisma.test_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_templatesUpdateManyArgs>(args: SelectSubset<T, test_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_templates.
     * @param {test_templatesUpsertArgs} args - Arguments to update or create a Test_templates.
     * @example
     * // Update or create a Test_templates
     * const test_templates = await prisma.test_templates.upsert({
     *   create: {
     *     // ... data to create a Test_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_templates we want to update
     *   }
     * })
     */
    upsert<T extends test_templatesUpsertArgs>(args: SelectSubset<T, test_templatesUpsertArgs<ExtArgs>>): Prisma__test_templatesClient<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Test_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_templatesCountArgs} args - Arguments to filter Test_templates to count.
     * @example
     * // Count the number of Test_templates
     * const count = await prisma.test_templates.count({
     *   where: {
     *     // ... the filter for the Test_templates we want to count
     *   }
     * })
    **/
    count<T extends test_templatesCountArgs>(
      args?: Subset<T, test_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_templatesAggregateArgs>(args: Subset<T, Test_templatesAggregateArgs>): Prisma.PrismaPromise<GetTest_templatesAggregateType<T>>

    /**
     * Group by Test_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_templatesGroupByArgs['orderBy'] }
        : { orderBy?: test_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_templates model
   */
  readonly fields: test_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_plans<T extends test_templates$test_plansArgs<ExtArgs> = {}>(args?: Subset<T, test_templates$test_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exam_boards<T extends exam_boardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, exam_boardsDefaultArgs<ExtArgs>>): Prisma__exam_boardsClient<$Result.GetResult<Prisma.$exam_boardsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_templates model
   */ 
  interface test_templatesFieldRefs {
    readonly template_id: FieldRef<"test_templates", 'BigInt'>
    readonly template_name: FieldRef<"test_templates", 'String'>
    readonly source: FieldRef<"test_templates", 'test_templates_source'>
    readonly created_by: FieldRef<"test_templates", 'BigInt'>
    readonly created_at: FieldRef<"test_templates", 'DateTime'>
    readonly board_id: FieldRef<"test_templates", 'Int'>
    readonly test_type: FieldRef<"test_templates", 'test_templates_test_type'>
    readonly timing_type: FieldRef<"test_templates", 'test_templates_timing_type'>
    readonly time_limit: FieldRef<"test_templates", 'Int'>
    readonly configuration: FieldRef<"test_templates", 'String'>
    readonly active: FieldRef<"test_templates", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * test_templates findUnique
   */
  export type test_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * Filter, which test_templates to fetch.
     */
    where: test_templatesWhereUniqueInput
  }

  /**
   * test_templates findUniqueOrThrow
   */
  export type test_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * Filter, which test_templates to fetch.
     */
    where: test_templatesWhereUniqueInput
  }

  /**
   * test_templates findFirst
   */
  export type test_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * Filter, which test_templates to fetch.
     */
    where?: test_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_templates to fetch.
     */
    orderBy?: test_templatesOrderByWithRelationInput | test_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_templates.
     */
    cursor?: test_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_templates.
     */
    distinct?: Test_templatesScalarFieldEnum | Test_templatesScalarFieldEnum[]
  }

  /**
   * test_templates findFirstOrThrow
   */
  export type test_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * Filter, which test_templates to fetch.
     */
    where?: test_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_templates to fetch.
     */
    orderBy?: test_templatesOrderByWithRelationInput | test_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_templates.
     */
    cursor?: test_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_templates.
     */
    distinct?: Test_templatesScalarFieldEnum | Test_templatesScalarFieldEnum[]
  }

  /**
   * test_templates findMany
   */
  export type test_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * Filter, which test_templates to fetch.
     */
    where?: test_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_templates to fetch.
     */
    orderBy?: test_templatesOrderByWithRelationInput | test_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_templates.
     */
    cursor?: test_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_templates.
     */
    skip?: number
    distinct?: Test_templatesScalarFieldEnum | Test_templatesScalarFieldEnum[]
  }

  /**
   * test_templates create
   */
  export type test_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * The data needed to create a test_templates.
     */
    data: XOR<test_templatesCreateInput, test_templatesUncheckedCreateInput>
  }

  /**
   * test_templates createMany
   */
  export type test_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_templates.
     */
    data: test_templatesCreateManyInput | test_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_templates update
   */
  export type test_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * The data needed to update a test_templates.
     */
    data: XOR<test_templatesUpdateInput, test_templatesUncheckedUpdateInput>
    /**
     * Choose, which test_templates to update.
     */
    where: test_templatesWhereUniqueInput
  }

  /**
   * test_templates updateMany
   */
  export type test_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_templates.
     */
    data: XOR<test_templatesUpdateManyMutationInput, test_templatesUncheckedUpdateManyInput>
    /**
     * Filter which test_templates to update
     */
    where?: test_templatesWhereInput
  }

  /**
   * test_templates upsert
   */
  export type test_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * The filter to search for the test_templates to update in case it exists.
     */
    where: test_templatesWhereUniqueInput
    /**
     * In case the test_templates found by the `where` argument doesn't exist, create a new test_templates with this data.
     */
    create: XOR<test_templatesCreateInput, test_templatesUncheckedCreateInput>
    /**
     * In case the test_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_templatesUpdateInput, test_templatesUncheckedUpdateInput>
  }

  /**
   * test_templates delete
   */
  export type test_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    /**
     * Filter which test_templates to delete.
     */
    where: test_templatesWhereUniqueInput
  }

  /**
   * test_templates deleteMany
   */
  export type test_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_templates to delete
     */
    where?: test_templatesWhereInput
  }

  /**
   * test_templates.test_plans
   */
  export type test_templates$test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    cursor?: test_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_templates without action
   */
  export type test_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
  }


  /**
   * Model topics
   */

  export type AggregateTopics = {
    _count: TopicsCountAggregateOutputType | null
    _avg: TopicsAvgAggregateOutputType | null
    _sum: TopicsSumAggregateOutputType | null
    _min: TopicsMinAggregateOutputType | null
    _max: TopicsMaxAggregateOutputType | null
  }

  export type TopicsAvgAggregateOutputType = {
    topic_id: number | null
    subject_id: number | null
  }

  export type TopicsSumAggregateOutputType = {
    topic_id: number | null
    subject_id: number | null
  }

  export type TopicsMinAggregateOutputType = {
    topic_id: number | null
    subject_id: number | null
    topic_name: string | null
    description: string | null
  }

  export type TopicsMaxAggregateOutputType = {
    topic_id: number | null
    subject_id: number | null
    topic_name: string | null
    description: string | null
  }

  export type TopicsCountAggregateOutputType = {
    topic_id: number
    subject_id: number
    topic_name: number
    description: number
    _all: number
  }


  export type TopicsAvgAggregateInputType = {
    topic_id?: true
    subject_id?: true
  }

  export type TopicsSumAggregateInputType = {
    topic_id?: true
    subject_id?: true
  }

  export type TopicsMinAggregateInputType = {
    topic_id?: true
    subject_id?: true
    topic_name?: true
    description?: true
  }

  export type TopicsMaxAggregateInputType = {
    topic_id?: true
    subject_id?: true
    topic_name?: true
    description?: true
  }

  export type TopicsCountAggregateInputType = {
    topic_id?: true
    subject_id?: true
    topic_name?: true
    description?: true
    _all?: true
  }

  export type TopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which topics to aggregate.
     */
    where?: topicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicsOrderByWithRelationInput | topicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: topicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned topics
    **/
    _count?: true | TopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicsMaxAggregateInputType
  }

  export type GetTopicsAggregateType<T extends TopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopics[P]>
      : GetScalarType<T[P], AggregateTopics[P]>
  }




  export type topicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: topicsWhereInput
    orderBy?: topicsOrderByWithAggregationInput | topicsOrderByWithAggregationInput[]
    by: TopicsScalarFieldEnum[] | TopicsScalarFieldEnum
    having?: topicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicsCountAggregateInputType | true
    _avg?: TopicsAvgAggregateInputType
    _sum?: TopicsSumAggregateInputType
    _min?: TopicsMinAggregateInputType
    _max?: TopicsMaxAggregateInputType
  }

  export type TopicsGroupByOutputType = {
    topic_id: number
    subject_id: number
    topic_name: string
    description: string | null
    _count: TopicsCountAggregateOutputType | null
    _avg: TopicsAvgAggregateOutputType | null
    _sum: TopicsSumAggregateOutputType | null
    _min: TopicsMinAggregateOutputType | null
    _max: TopicsMaxAggregateOutputType | null
  }

  type GetTopicsGroupByPayload<T extends topicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicsGroupByOutputType[P]>
            : GetScalarType<T[P], TopicsGroupByOutputType[P]>
        }
      >
    >


  export type topicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topic_id?: boolean
    subject_id?: boolean
    topic_name?: boolean
    description?: boolean
    subtopics?: boolean | topics$subtopicsArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | TopicsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topics"]>


  export type topicsSelectScalar = {
    topic_id?: boolean
    subject_id?: boolean
    topic_name?: boolean
    description?: boolean
  }

  export type topicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtopics?: boolean | topics$subtopicsArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | TopicsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $topicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "topics"
    objects: {
      subtopics: Prisma.$subtopicsPayload<ExtArgs>[]
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      topic_id: number
      subject_id: number
      topic_name: string
      description: string | null
    }, ExtArgs["result"]["topics"]>
    composites: {}
  }

  type topicsGetPayload<S extends boolean | null | undefined | topicsDefaultArgs> = $Result.GetResult<Prisma.$topicsPayload, S>

  type topicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<topicsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicsCountAggregateInputType | true
    }

  export interface topicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['topics'], meta: { name: 'topics' } }
    /**
     * Find zero or one Topics that matches the filter.
     * @param {topicsFindUniqueArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends topicsFindUniqueArgs>(args: SelectSubset<T, topicsFindUniqueArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {topicsFindUniqueOrThrowArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends topicsFindUniqueOrThrowArgs>(args: SelectSubset<T, topicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicsFindFirstArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends topicsFindFirstArgs>(args?: SelectSubset<T, topicsFindFirstArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicsFindFirstOrThrowArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends topicsFindFirstOrThrowArgs>(args?: SelectSubset<T, topicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topics.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topics.findMany({ take: 10 })
     * 
     * // Only select the `topic_id`
     * const topicsWithTopic_idOnly = await prisma.topics.findMany({ select: { topic_id: true } })
     * 
     */
    findMany<T extends topicsFindManyArgs>(args?: SelectSubset<T, topicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topics.
     * @param {topicsCreateArgs} args - Arguments to create a Topics.
     * @example
     * // Create one Topics
     * const Topics = await prisma.topics.create({
     *   data: {
     *     // ... data to create a Topics
     *   }
     * })
     * 
     */
    create<T extends topicsCreateArgs>(args: SelectSubset<T, topicsCreateArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {topicsCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topics = await prisma.topics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends topicsCreateManyArgs>(args?: SelectSubset<T, topicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Topics.
     * @param {topicsDeleteArgs} args - Arguments to delete one Topics.
     * @example
     * // Delete one Topics
     * const Topics = await prisma.topics.delete({
     *   where: {
     *     // ... filter to delete one Topics
     *   }
     * })
     * 
     */
    delete<T extends topicsDeleteArgs>(args: SelectSubset<T, topicsDeleteArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topics.
     * @param {topicsUpdateArgs} args - Arguments to update one Topics.
     * @example
     * // Update one Topics
     * const topics = await prisma.topics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends topicsUpdateArgs>(args: SelectSubset<T, topicsUpdateArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {topicsDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends topicsDeleteManyArgs>(args?: SelectSubset<T, topicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topics = await prisma.topics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends topicsUpdateManyArgs>(args: SelectSubset<T, topicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topics.
     * @param {topicsUpsertArgs} args - Arguments to update or create a Topics.
     * @example
     * // Update or create a Topics
     * const topics = await prisma.topics.upsert({
     *   create: {
     *     // ... data to create a Topics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topics we want to update
     *   }
     * })
     */
    upsert<T extends topicsUpsertArgs>(args: SelectSubset<T, topicsUpsertArgs<ExtArgs>>): Prisma__topicsClient<$Result.GetResult<Prisma.$topicsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicsCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topics.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends topicsCountArgs>(
      args?: Subset<T, topicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicsAggregateArgs>(args: Subset<T, TopicsAggregateArgs>): Prisma.PrismaPromise<GetTopicsAggregateType<T>>

    /**
     * Group by Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends topicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: topicsGroupByArgs['orderBy'] }
        : { orderBy?: topicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, topicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the topics model
   */
  readonly fields: topicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for topics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__topicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subtopics<T extends topics$subtopicsArgs<ExtArgs> = {}>(args?: Subset<T, topics$subtopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subtopicsPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the topics model
   */ 
  interface topicsFieldRefs {
    readonly topic_id: FieldRef<"topics", 'Int'>
    readonly subject_id: FieldRef<"topics", 'Int'>
    readonly topic_name: FieldRef<"topics", 'String'>
    readonly description: FieldRef<"topics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * topics findUnique
   */
  export type topicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * Filter, which topics to fetch.
     */
    where: topicsWhereUniqueInput
  }

  /**
   * topics findUniqueOrThrow
   */
  export type topicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * Filter, which topics to fetch.
     */
    where: topicsWhereUniqueInput
  }

  /**
   * topics findFirst
   */
  export type topicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * Filter, which topics to fetch.
     */
    where?: topicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicsOrderByWithRelationInput | topicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topics.
     */
    cursor?: topicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topics.
     */
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * topics findFirstOrThrow
   */
  export type topicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * Filter, which topics to fetch.
     */
    where?: topicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicsOrderByWithRelationInput | topicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topics.
     */
    cursor?: topicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topics.
     */
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * topics findMany
   */
  export type topicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * Filter, which topics to fetch.
     */
    where?: topicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     */
    orderBy?: topicsOrderByWithRelationInput | topicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing topics.
     */
    cursor?: topicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     */
    skip?: number
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * topics create
   */
  export type topicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * The data needed to create a topics.
     */
    data: XOR<topicsCreateInput, topicsUncheckedCreateInput>
  }

  /**
   * topics createMany
   */
  export type topicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many topics.
     */
    data: topicsCreateManyInput | topicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * topics update
   */
  export type topicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * The data needed to update a topics.
     */
    data: XOR<topicsUpdateInput, topicsUncheckedUpdateInput>
    /**
     * Choose, which topics to update.
     */
    where: topicsWhereUniqueInput
  }

  /**
   * topics updateMany
   */
  export type topicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update topics.
     */
    data: XOR<topicsUpdateManyMutationInput, topicsUncheckedUpdateManyInput>
    /**
     * Filter which topics to update
     */
    where?: topicsWhereInput
  }

  /**
   * topics upsert
   */
  export type topicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * The filter to search for the topics to update in case it exists.
     */
    where: topicsWhereUniqueInput
    /**
     * In case the topics found by the `where` argument doesn't exist, create a new topics with this data.
     */
    create: XOR<topicsCreateInput, topicsUncheckedCreateInput>
    /**
     * In case the topics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<topicsUpdateInput, topicsUncheckedUpdateInput>
  }

  /**
   * topics delete
   */
  export type topicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
    /**
     * Filter which topics to delete.
     */
    where: topicsWhereUniqueInput
  }

  /**
   * topics deleteMany
   */
  export type topicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which topics to delete
     */
    where?: topicsWhereInput
  }

  /**
   * topics.subtopics
   */
  export type topics$subtopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subtopics
     */
    select?: subtopicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtopicsInclude<ExtArgs> | null
    where?: subtopicsWhereInput
    orderBy?: subtopicsOrderByWithRelationInput | subtopicsOrderByWithRelationInput[]
    cursor?: subtopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtopicsScalarFieldEnum | SubtopicsScalarFieldEnum[]
  }

  /**
   * topics without action
   */
  export type topicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the topics
     */
    select?: topicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: topicsInclude<ExtArgs> | null
  }


  /**
   * Model user_roles
   */

  export type AggregateUser_roles = {
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  export type User_rolesAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type User_rolesSumAggregateOutputType = {
    user_id: bigint | null
    role_id: number | null
  }

  export type User_rolesMinAggregateOutputType = {
    user_id: bigint | null
    role_id: number | null
  }

  export type User_rolesMaxAggregateOutputType = {
    user_id: bigint | null
    role_id: number | null
  }

  export type User_rolesCountAggregateOutputType = {
    user_id: number
    role_id: number
    _all: number
  }


  export type User_rolesAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesMinAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesMaxAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesCountAggregateInputType = {
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to aggregate.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_rolesMaxAggregateInputType
  }

  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_roles[P]>
      : GetScalarType<T[P], AggregateUser_roles[P]>
  }




  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]
    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum
    having?: user_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_rolesCountAggregateInputType | true
    _avg?: User_rolesAvgAggregateInputType
    _sum?: User_rolesSumAggregateInputType
    _min?: User_rolesMinAggregateInputType
    _max?: User_rolesMaxAggregateInputType
  }

  export type User_rolesGroupByOutputType = {
    user_id: bigint
    role_id: number
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
        }
      >
    >


  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>


  export type user_rolesSelectScalar = {
    user_id?: boolean
    role_id?: boolean
  }

  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_roles"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      role_id: number
    }, ExtArgs["result"]["user_roles"]>
    composites: {}
  }

  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>

  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_rolesCountAggregateInputType | true
    }

  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }
    /**
     * Find zero or one User_roles that matches the filter.
     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_roles.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_roles.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_rolesWithUser_idOnly = await prisma.user_roles.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_roles.
     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.
     * @example
     * // Create one User_roles
     * const User_roles = await prisma.user_roles.create({
     *   data: {
     *     // ... data to create a User_roles
     *   }
     * })
     * 
     */
    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_roles.
     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_roles.
     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.
     * @example
     * // Delete one User_roles
     * const User_roles = await prisma.user_roles.delete({
     *   where: {
     *     // ... filter to delete one User_roles
     *   }
     * })
     * 
     */
    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_roles.
     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.
     * @example
     * // Update one User_roles
     * const user_roles = await prisma.user_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_roles.
     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_roles.
     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.
     * @example
     * // Update or create a User_roles
     * const user_roles = await prisma.user_roles.upsert({
     *   create: {
     *     // ... data to create a User_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_roles we want to update
     *   }
     * })
     */
    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_roles.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_rolesCountArgs>(
      args?: Subset<T, user_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>

    /**
     * Group by User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_rolesGroupByArgs['orderBy'] }
        : { orderBy?: user_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_roles model
   */
  readonly fields: user_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_roles model
   */ 
  interface user_rolesFieldRefs {
    readonly user_id: FieldRef<"user_roles", 'BigInt'>
    readonly role_id: FieldRef<"user_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user_roles findUnique
   */
  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findUniqueOrThrow
   */
  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findFirst
   */
  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findFirstOrThrow
   */
  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findMany
   */
  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles create
   */
  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_roles.
     */
    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
  }

  /**
   * user_roles createMany
   */
  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_roles update
   */
  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_roles.
     */
    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
    /**
     * Choose, which user_roles to update.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles updateMany
   */
  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
  }

  /**
   * user_roles upsert
   */
  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_roles to update in case it exists.
     */
    where: user_rolesWhereUniqueInput
    /**
     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.
     */
    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
    /**
     * In case the user_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
  }

  /**
   * user_roles delete
   */
  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter which user_roles to delete.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles deleteMany
   */
  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_rolesWhereInput
  }

  /**
   * user_roles without action
   */
  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: bigint | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    last_login: Date | null
    active: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: bigint | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    last_login: Date | null
    active: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    email: number
    password: number
    first_name: number
    last_name: number
    created_at: number
    last_login: number
    active: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_id?: true
  }

  export type UsersSumAggregateInputType = {
    user_id?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    created_at?: true
    last_login?: true
    active?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    created_at?: true
    last_login?: true
    active?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    created_at?: true
    last_login?: true
    active?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: bigint
    email: string
    password: string
    first_name: string
    last_name: string
    created_at: Date
    last_login: Date | null
    active: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    last_login?: boolean
    active?: boolean
    questions?: boolean | users$questionsArgs<ExtArgs>
    created_question_sets?: boolean | users$created_question_setsArgs<ExtArgs>
    test_executions?: boolean | users$test_executionsArgs<ExtArgs>
    assigned_test_plans?: boolean | users$assigned_test_plansArgs<ExtArgs>
    planned_test_plans?: boolean | users$planned_test_plansArgs<ExtArgs>
    test_templates?: boolean | users$test_templatesArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    achievements_earned?: boolean | users$achievements_earnedArgs<ExtArgs>
    tutor_groups?: boolean | users$tutor_groupsArgs<ExtArgs>
    student_groups?: boolean | users$student_groupsArgs<ExtArgs>
    group_memberships?: boolean | users$group_membershipsArgs<ExtArgs>
    subject_mastery?: boolean | users$subject_masteryArgs<ExtArgs>
    student_progress?: boolean | users$student_progressArgs<ExtArgs>
    activity_logs?: boolean | users$activity_logsArgs<ExtArgs>
    student_rewards?: boolean | users$student_rewardsArgs<ExtArgs>
    guardian_relationships?: boolean | users$guardian_relationshipsArgs<ExtArgs>
    student_relationships?: boolean | users$student_relationshipsArgs<ExtArgs>
    assignments_created?: boolean | users$assignments_createdArgs<ExtArgs>
    assignments_received?: boolean | users$assignments_receivedArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    user_id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    last_login?: boolean
    active?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | users$questionsArgs<ExtArgs>
    created_question_sets?: boolean | users$created_question_setsArgs<ExtArgs>
    test_executions?: boolean | users$test_executionsArgs<ExtArgs>
    assigned_test_plans?: boolean | users$assigned_test_plansArgs<ExtArgs>
    planned_test_plans?: boolean | users$planned_test_plansArgs<ExtArgs>
    test_templates?: boolean | users$test_templatesArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    achievements_earned?: boolean | users$achievements_earnedArgs<ExtArgs>
    tutor_groups?: boolean | users$tutor_groupsArgs<ExtArgs>
    student_groups?: boolean | users$student_groupsArgs<ExtArgs>
    group_memberships?: boolean | users$group_membershipsArgs<ExtArgs>
    subject_mastery?: boolean | users$subject_masteryArgs<ExtArgs>
    student_progress?: boolean | users$student_progressArgs<ExtArgs>
    activity_logs?: boolean | users$activity_logsArgs<ExtArgs>
    student_rewards?: boolean | users$student_rewardsArgs<ExtArgs>
    guardian_relationships?: boolean | users$guardian_relationshipsArgs<ExtArgs>
    student_relationships?: boolean | users$student_relationshipsArgs<ExtArgs>
    assignments_created?: boolean | users$assignments_createdArgs<ExtArgs>
    assignments_received?: boolean | users$assignments_receivedArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
      created_question_sets: Prisma.$question_setsPayload<ExtArgs>[]
      test_executions: Prisma.$test_executionsPayload<ExtArgs>[]
      assigned_test_plans: Prisma.$test_plansPayload<ExtArgs>[]
      planned_test_plans: Prisma.$test_plansPayload<ExtArgs>[]
      test_templates: Prisma.$test_templatesPayload<ExtArgs>[]
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
      achievements_earned: Prisma.$student_achievementsPayload<ExtArgs>[]
      tutor_groups: Prisma.$study_groupsPayload<ExtArgs>[]
      student_groups: Prisma.$study_groupsPayload<ExtArgs>[]
      group_memberships: Prisma.$group_membersPayload<ExtArgs>[]
      subject_mastery: Prisma.$subject_masteryPayload<ExtArgs>[]
      student_progress: Prisma.$student_progressPayload<ExtArgs> | null
      activity_logs: Prisma.$activity_logPayload<ExtArgs>[]
      student_rewards: Prisma.$student_rewardsPayload<ExtArgs>[]
      guardian_relationships: Prisma.$student_guardiansPayload<ExtArgs>[]
      student_relationships: Prisma.$student_guardiansPayload<ExtArgs>[]
      assignments_created: Prisma.$test_assignmentsPayload<ExtArgs>[]
      assignments_received: Prisma.$test_assignmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      email: string
      password: string
      first_name: string
      last_name: string
      created_at: Date
      last_login: Date | null
      active: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends users$questionsArgs<ExtArgs> = {}>(args?: Subset<T, users$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    created_question_sets<T extends users$created_question_setsArgs<ExtArgs> = {}>(args?: Subset<T, users$created_question_setsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_setsPayload<ExtArgs>, T, "findMany"> | Null>
    test_executions<T extends users$test_executionsArgs<ExtArgs> = {}>(args?: Subset<T, users$test_executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_executionsPayload<ExtArgs>, T, "findMany"> | Null>
    assigned_test_plans<T extends users$assigned_test_plansArgs<ExtArgs> = {}>(args?: Subset<T, users$assigned_test_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany"> | Null>
    planned_test_plans<T extends users$planned_test_plansArgs<ExtArgs> = {}>(args?: Subset<T, users$planned_test_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany"> | Null>
    test_templates<T extends users$test_templatesArgs<ExtArgs> = {}>(args?: Subset<T, users$test_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_templatesPayload<ExtArgs>, T, "findMany"> | Null>
    user_roles<T extends users$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    achievements_earned<T extends users$achievements_earnedArgs<ExtArgs> = {}>(args?: Subset<T, users$achievements_earnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findMany"> | Null>
    tutor_groups<T extends users$tutor_groupsArgs<ExtArgs> = {}>(args?: Subset<T, users$tutor_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findMany"> | Null>
    student_groups<T extends users$student_groupsArgs<ExtArgs> = {}>(args?: Subset<T, users$student_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findMany"> | Null>
    group_memberships<T extends users$group_membershipsArgs<ExtArgs> = {}>(args?: Subset<T, users$group_membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findMany"> | Null>
    subject_mastery<T extends users$subject_masteryArgs<ExtArgs> = {}>(args?: Subset<T, users$subject_masteryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findMany"> | Null>
    student_progress<T extends users$student_progressArgs<ExtArgs> = {}>(args?: Subset<T, users$student_progressArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    activity_logs<T extends users$activity_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$activity_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "findMany"> | Null>
    student_rewards<T extends users$student_rewardsArgs<ExtArgs> = {}>(args?: Subset<T, users$student_rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findMany"> | Null>
    guardian_relationships<T extends users$guardian_relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, users$guardian_relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findMany"> | Null>
    student_relationships<T extends users$student_relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, users$student_relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findMany"> | Null>
    assignments_created<T extends users$assignments_createdArgs<ExtArgs> = {}>(args?: Subset<T, users$assignments_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findMany"> | Null>
    assignments_received<T extends users$assignments_receivedArgs<ExtArgs> = {}>(args?: Subset<T, users$assignments_receivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'BigInt'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly last_login: FieldRef<"users", 'DateTime'>
    readonly active: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.questions
   */
  export type users$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * users.created_question_sets
   */
  export type users$created_question_setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_sets
     */
    select?: question_setsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_setsInclude<ExtArgs> | null
    where?: question_setsWhereInput
    orderBy?: question_setsOrderByWithRelationInput | question_setsOrderByWithRelationInput[]
    cursor?: question_setsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Question_setsScalarFieldEnum | Question_setsScalarFieldEnum[]
  }

  /**
   * users.test_executions
   */
  export type users$test_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_executions
     */
    select?: test_executionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_executionsInclude<ExtArgs> | null
    where?: test_executionsWhereInput
    orderBy?: test_executionsOrderByWithRelationInput | test_executionsOrderByWithRelationInput[]
    cursor?: test_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_executionsScalarFieldEnum | Test_executionsScalarFieldEnum[]
  }

  /**
   * users.assigned_test_plans
   */
  export type users$assigned_test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    cursor?: test_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * users.planned_test_plans
   */
  export type users$planned_test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    cursor?: test_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * users.test_templates
   */
  export type users$test_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_templates
     */
    select?: test_templatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_templatesInclude<ExtArgs> | null
    where?: test_templatesWhereInput
    orderBy?: test_templatesOrderByWithRelationInput | test_templatesOrderByWithRelationInput[]
    cursor?: test_templatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_templatesScalarFieldEnum | Test_templatesScalarFieldEnum[]
  }

  /**
   * users.user_roles
   */
  export type users$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * users.achievements_earned
   */
  export type users$achievements_earnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    where?: student_achievementsWhereInput
    orderBy?: student_achievementsOrderByWithRelationInput | student_achievementsOrderByWithRelationInput[]
    cursor?: student_achievementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_achievementsScalarFieldEnum | Student_achievementsScalarFieldEnum[]
  }

  /**
   * users.tutor_groups
   */
  export type users$tutor_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    where?: study_groupsWhereInput
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    cursor?: study_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_groupsScalarFieldEnum | Study_groupsScalarFieldEnum[]
  }

  /**
   * users.student_groups
   */
  export type users$student_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    where?: study_groupsWhereInput
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    cursor?: study_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_groupsScalarFieldEnum | Study_groupsScalarFieldEnum[]
  }

  /**
   * users.group_memberships
   */
  export type users$group_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    where?: group_membersWhereInput
    orderBy?: group_membersOrderByWithRelationInput | group_membersOrderByWithRelationInput[]
    cursor?: group_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Group_membersScalarFieldEnum | Group_membersScalarFieldEnum[]
  }

  /**
   * users.subject_mastery
   */
  export type users$subject_masteryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    where?: subject_masteryWhereInput
    orderBy?: subject_masteryOrderByWithRelationInput | subject_masteryOrderByWithRelationInput[]
    cursor?: subject_masteryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Subject_masteryScalarFieldEnum | Subject_masteryScalarFieldEnum[]
  }

  /**
   * users.student_progress
   */
  export type users$student_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    where?: student_progressWhereInput
  }

  /**
   * users.activity_logs
   */
  export type users$activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    where?: activity_logWhereInput
    orderBy?: activity_logOrderByWithRelationInput | activity_logOrderByWithRelationInput[]
    cursor?: activity_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Activity_logScalarFieldEnum | Activity_logScalarFieldEnum[]
  }

  /**
   * users.student_rewards
   */
  export type users$student_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    where?: student_rewardsWhereInput
    orderBy?: student_rewardsOrderByWithRelationInput | student_rewardsOrderByWithRelationInput[]
    cursor?: student_rewardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_rewardsScalarFieldEnum | Student_rewardsScalarFieldEnum[]
  }

  /**
   * users.guardian_relationships
   */
  export type users$guardian_relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    where?: student_guardiansWhereInput
    orderBy?: student_guardiansOrderByWithRelationInput | student_guardiansOrderByWithRelationInput[]
    cursor?: student_guardiansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_guardiansScalarFieldEnum | Student_guardiansScalarFieldEnum[]
  }

  /**
   * users.student_relationships
   */
  export type users$student_relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    where?: student_guardiansWhereInput
    orderBy?: student_guardiansOrderByWithRelationInput | student_guardiansOrderByWithRelationInput[]
    cursor?: student_guardiansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_guardiansScalarFieldEnum | Student_guardiansScalarFieldEnum[]
  }

  /**
   * users.assignments_created
   */
  export type users$assignments_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    where?: test_assignmentsWhereInput
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    cursor?: test_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * users.assignments_received
   */
  export type users$assignments_receivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    where?: test_assignmentsWhereInput
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    cursor?: test_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model difficulty_levels
   */

  export type AggregateDifficulty_levels = {
    _count: Difficulty_levelsCountAggregateOutputType | null
    _avg: Difficulty_levelsAvgAggregateOutputType | null
    _sum: Difficulty_levelsSumAggregateOutputType | null
    _min: Difficulty_levelsMinAggregateOutputType | null
    _max: Difficulty_levelsMaxAggregateOutputType | null
  }

  export type Difficulty_levelsAvgAggregateOutputType = {
    level_id: number | null
    level_value: number | null
    subject_id: number | null
  }

  export type Difficulty_levelsSumAggregateOutputType = {
    level_id: number | null
    level_value: number | null
    subject_id: number | null
  }

  export type Difficulty_levelsMinAggregateOutputType = {
    level_id: number | null
    level_name: string | null
    level_value: number | null
    subject_id: number | null
    purpose: string | null
    characteristics: string | null
    focus_area: string | null
    steps_required: string | null
    created_at: Date | null
    active: boolean | null
  }

  export type Difficulty_levelsMaxAggregateOutputType = {
    level_id: number | null
    level_name: string | null
    level_value: number | null
    subject_id: number | null
    purpose: string | null
    characteristics: string | null
    focus_area: string | null
    steps_required: string | null
    created_at: Date | null
    active: boolean | null
  }

  export type Difficulty_levelsCountAggregateOutputType = {
    level_id: number
    level_name: number
    level_value: number
    subject_id: number
    purpose: number
    characteristics: number
    focus_area: number
    steps_required: number
    created_at: number
    active: number
    _all: number
  }


  export type Difficulty_levelsAvgAggregateInputType = {
    level_id?: true
    level_value?: true
    subject_id?: true
  }

  export type Difficulty_levelsSumAggregateInputType = {
    level_id?: true
    level_value?: true
    subject_id?: true
  }

  export type Difficulty_levelsMinAggregateInputType = {
    level_id?: true
    level_name?: true
    level_value?: true
    subject_id?: true
    purpose?: true
    characteristics?: true
    focus_area?: true
    steps_required?: true
    created_at?: true
    active?: true
  }

  export type Difficulty_levelsMaxAggregateInputType = {
    level_id?: true
    level_name?: true
    level_value?: true
    subject_id?: true
    purpose?: true
    characteristics?: true
    focus_area?: true
    steps_required?: true
    created_at?: true
    active?: true
  }

  export type Difficulty_levelsCountAggregateInputType = {
    level_id?: true
    level_name?: true
    level_value?: true
    subject_id?: true
    purpose?: true
    characteristics?: true
    focus_area?: true
    steps_required?: true
    created_at?: true
    active?: true
    _all?: true
  }

  export type Difficulty_levelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which difficulty_levels to aggregate.
     */
    where?: difficulty_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of difficulty_levels to fetch.
     */
    orderBy?: difficulty_levelsOrderByWithRelationInput | difficulty_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: difficulty_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` difficulty_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` difficulty_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned difficulty_levels
    **/
    _count?: true | Difficulty_levelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Difficulty_levelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Difficulty_levelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Difficulty_levelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Difficulty_levelsMaxAggregateInputType
  }

  export type GetDifficulty_levelsAggregateType<T extends Difficulty_levelsAggregateArgs> = {
        [P in keyof T & keyof AggregateDifficulty_levels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDifficulty_levels[P]>
      : GetScalarType<T[P], AggregateDifficulty_levels[P]>
  }




  export type difficulty_levelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: difficulty_levelsWhereInput
    orderBy?: difficulty_levelsOrderByWithAggregationInput | difficulty_levelsOrderByWithAggregationInput[]
    by: Difficulty_levelsScalarFieldEnum[] | Difficulty_levelsScalarFieldEnum
    having?: difficulty_levelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Difficulty_levelsCountAggregateInputType | true
    _avg?: Difficulty_levelsAvgAggregateInputType
    _sum?: Difficulty_levelsSumAggregateInputType
    _min?: Difficulty_levelsMinAggregateInputType
    _max?: Difficulty_levelsMaxAggregateInputType
  }

  export type Difficulty_levelsGroupByOutputType = {
    level_id: number
    level_name: string
    level_value: number
    subject_id: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required: string | null
    created_at: Date | null
    active: boolean | null
    _count: Difficulty_levelsCountAggregateOutputType | null
    _avg: Difficulty_levelsAvgAggregateOutputType | null
    _sum: Difficulty_levelsSumAggregateOutputType | null
    _min: Difficulty_levelsMinAggregateOutputType | null
    _max: Difficulty_levelsMaxAggregateOutputType | null
  }

  type GetDifficulty_levelsGroupByPayload<T extends difficulty_levelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Difficulty_levelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Difficulty_levelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Difficulty_levelsGroupByOutputType[P]>
            : GetScalarType<T[P], Difficulty_levelsGroupByOutputType[P]>
        }
      >
    >


  export type difficulty_levelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    level_id?: boolean
    level_name?: boolean
    level_value?: boolean
    subject_id?: boolean
    purpose?: boolean
    characteristics?: boolean
    focus_area?: boolean
    steps_required?: boolean
    created_at?: boolean
    active?: boolean
    subject?: boolean | subjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["difficulty_levels"]>


  export type difficulty_levelsSelectScalar = {
    level_id?: boolean
    level_name?: boolean
    level_value?: boolean
    subject_id?: boolean
    purpose?: boolean
    characteristics?: boolean
    focus_area?: boolean
    steps_required?: boolean
    created_at?: boolean
    active?: boolean
  }

  export type difficulty_levelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | subjectsDefaultArgs<ExtArgs>
  }

  export type $difficulty_levelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "difficulty_levels"
    objects: {
      subject: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      level_id: number
      level_name: string
      level_value: number
      subject_id: number
      purpose: string
      characteristics: string
      focus_area: string
      steps_required: string | null
      created_at: Date | null
      active: boolean | null
    }, ExtArgs["result"]["difficulty_levels"]>
    composites: {}
  }

  type difficulty_levelsGetPayload<S extends boolean | null | undefined | difficulty_levelsDefaultArgs> = $Result.GetResult<Prisma.$difficulty_levelsPayload, S>

  type difficulty_levelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<difficulty_levelsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Difficulty_levelsCountAggregateInputType | true
    }

  export interface difficulty_levelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['difficulty_levels'], meta: { name: 'difficulty_levels' } }
    /**
     * Find zero or one Difficulty_levels that matches the filter.
     * @param {difficulty_levelsFindUniqueArgs} args - Arguments to find a Difficulty_levels
     * @example
     * // Get one Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends difficulty_levelsFindUniqueArgs>(args: SelectSubset<T, difficulty_levelsFindUniqueArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Difficulty_levels that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {difficulty_levelsFindUniqueOrThrowArgs} args - Arguments to find a Difficulty_levels
     * @example
     * // Get one Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends difficulty_levelsFindUniqueOrThrowArgs>(args: SelectSubset<T, difficulty_levelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Difficulty_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {difficulty_levelsFindFirstArgs} args - Arguments to find a Difficulty_levels
     * @example
     * // Get one Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends difficulty_levelsFindFirstArgs>(args?: SelectSubset<T, difficulty_levelsFindFirstArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Difficulty_levels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {difficulty_levelsFindFirstOrThrowArgs} args - Arguments to find a Difficulty_levels
     * @example
     * // Get one Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends difficulty_levelsFindFirstOrThrowArgs>(args?: SelectSubset<T, difficulty_levelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Difficulty_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {difficulty_levelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.findMany()
     * 
     * // Get first 10 Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.findMany({ take: 10 })
     * 
     * // Only select the `level_id`
     * const difficulty_levelsWithLevel_idOnly = await prisma.difficulty_levels.findMany({ select: { level_id: true } })
     * 
     */
    findMany<T extends difficulty_levelsFindManyArgs>(args?: SelectSubset<T, difficulty_levelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Difficulty_levels.
     * @param {difficulty_levelsCreateArgs} args - Arguments to create a Difficulty_levels.
     * @example
     * // Create one Difficulty_levels
     * const Difficulty_levels = await prisma.difficulty_levels.create({
     *   data: {
     *     // ... data to create a Difficulty_levels
     *   }
     * })
     * 
     */
    create<T extends difficulty_levelsCreateArgs>(args: SelectSubset<T, difficulty_levelsCreateArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Difficulty_levels.
     * @param {difficulty_levelsCreateManyArgs} args - Arguments to create many Difficulty_levels.
     * @example
     * // Create many Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends difficulty_levelsCreateManyArgs>(args?: SelectSubset<T, difficulty_levelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Difficulty_levels.
     * @param {difficulty_levelsDeleteArgs} args - Arguments to delete one Difficulty_levels.
     * @example
     * // Delete one Difficulty_levels
     * const Difficulty_levels = await prisma.difficulty_levels.delete({
     *   where: {
     *     // ... filter to delete one Difficulty_levels
     *   }
     * })
     * 
     */
    delete<T extends difficulty_levelsDeleteArgs>(args: SelectSubset<T, difficulty_levelsDeleteArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Difficulty_levels.
     * @param {difficulty_levelsUpdateArgs} args - Arguments to update one Difficulty_levels.
     * @example
     * // Update one Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends difficulty_levelsUpdateArgs>(args: SelectSubset<T, difficulty_levelsUpdateArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Difficulty_levels.
     * @param {difficulty_levelsDeleteManyArgs} args - Arguments to filter Difficulty_levels to delete.
     * @example
     * // Delete a few Difficulty_levels
     * const { count } = await prisma.difficulty_levels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends difficulty_levelsDeleteManyArgs>(args?: SelectSubset<T, difficulty_levelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Difficulty_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {difficulty_levelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends difficulty_levelsUpdateManyArgs>(args: SelectSubset<T, difficulty_levelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Difficulty_levels.
     * @param {difficulty_levelsUpsertArgs} args - Arguments to update or create a Difficulty_levels.
     * @example
     * // Update or create a Difficulty_levels
     * const difficulty_levels = await prisma.difficulty_levels.upsert({
     *   create: {
     *     // ... data to create a Difficulty_levels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Difficulty_levels we want to update
     *   }
     * })
     */
    upsert<T extends difficulty_levelsUpsertArgs>(args: SelectSubset<T, difficulty_levelsUpsertArgs<ExtArgs>>): Prisma__difficulty_levelsClient<$Result.GetResult<Prisma.$difficulty_levelsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Difficulty_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {difficulty_levelsCountArgs} args - Arguments to filter Difficulty_levels to count.
     * @example
     * // Count the number of Difficulty_levels
     * const count = await prisma.difficulty_levels.count({
     *   where: {
     *     // ... the filter for the Difficulty_levels we want to count
     *   }
     * })
    **/
    count<T extends difficulty_levelsCountArgs>(
      args?: Subset<T, difficulty_levelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Difficulty_levelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Difficulty_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Difficulty_levelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Difficulty_levelsAggregateArgs>(args: Subset<T, Difficulty_levelsAggregateArgs>): Prisma.PrismaPromise<GetDifficulty_levelsAggregateType<T>>

    /**
     * Group by Difficulty_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {difficulty_levelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends difficulty_levelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: difficulty_levelsGroupByArgs['orderBy'] }
        : { orderBy?: difficulty_levelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, difficulty_levelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDifficulty_levelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the difficulty_levels model
   */
  readonly fields: difficulty_levelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for difficulty_levels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__difficulty_levelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the difficulty_levels model
   */ 
  interface difficulty_levelsFieldRefs {
    readonly level_id: FieldRef<"difficulty_levels", 'Int'>
    readonly level_name: FieldRef<"difficulty_levels", 'String'>
    readonly level_value: FieldRef<"difficulty_levels", 'Int'>
    readonly subject_id: FieldRef<"difficulty_levels", 'Int'>
    readonly purpose: FieldRef<"difficulty_levels", 'String'>
    readonly characteristics: FieldRef<"difficulty_levels", 'String'>
    readonly focus_area: FieldRef<"difficulty_levels", 'String'>
    readonly steps_required: FieldRef<"difficulty_levels", 'String'>
    readonly created_at: FieldRef<"difficulty_levels", 'DateTime'>
    readonly active: FieldRef<"difficulty_levels", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * difficulty_levels findUnique
   */
  export type difficulty_levelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * Filter, which difficulty_levels to fetch.
     */
    where: difficulty_levelsWhereUniqueInput
  }

  /**
   * difficulty_levels findUniqueOrThrow
   */
  export type difficulty_levelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * Filter, which difficulty_levels to fetch.
     */
    where: difficulty_levelsWhereUniqueInput
  }

  /**
   * difficulty_levels findFirst
   */
  export type difficulty_levelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * Filter, which difficulty_levels to fetch.
     */
    where?: difficulty_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of difficulty_levels to fetch.
     */
    orderBy?: difficulty_levelsOrderByWithRelationInput | difficulty_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for difficulty_levels.
     */
    cursor?: difficulty_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` difficulty_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` difficulty_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of difficulty_levels.
     */
    distinct?: Difficulty_levelsScalarFieldEnum | Difficulty_levelsScalarFieldEnum[]
  }

  /**
   * difficulty_levels findFirstOrThrow
   */
  export type difficulty_levelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * Filter, which difficulty_levels to fetch.
     */
    where?: difficulty_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of difficulty_levels to fetch.
     */
    orderBy?: difficulty_levelsOrderByWithRelationInput | difficulty_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for difficulty_levels.
     */
    cursor?: difficulty_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` difficulty_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` difficulty_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of difficulty_levels.
     */
    distinct?: Difficulty_levelsScalarFieldEnum | Difficulty_levelsScalarFieldEnum[]
  }

  /**
   * difficulty_levels findMany
   */
  export type difficulty_levelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * Filter, which difficulty_levels to fetch.
     */
    where?: difficulty_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of difficulty_levels to fetch.
     */
    orderBy?: difficulty_levelsOrderByWithRelationInput | difficulty_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing difficulty_levels.
     */
    cursor?: difficulty_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` difficulty_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` difficulty_levels.
     */
    skip?: number
    distinct?: Difficulty_levelsScalarFieldEnum | Difficulty_levelsScalarFieldEnum[]
  }

  /**
   * difficulty_levels create
   */
  export type difficulty_levelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * The data needed to create a difficulty_levels.
     */
    data: XOR<difficulty_levelsCreateInput, difficulty_levelsUncheckedCreateInput>
  }

  /**
   * difficulty_levels createMany
   */
  export type difficulty_levelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many difficulty_levels.
     */
    data: difficulty_levelsCreateManyInput | difficulty_levelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * difficulty_levels update
   */
  export type difficulty_levelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * The data needed to update a difficulty_levels.
     */
    data: XOR<difficulty_levelsUpdateInput, difficulty_levelsUncheckedUpdateInput>
    /**
     * Choose, which difficulty_levels to update.
     */
    where: difficulty_levelsWhereUniqueInput
  }

  /**
   * difficulty_levels updateMany
   */
  export type difficulty_levelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update difficulty_levels.
     */
    data: XOR<difficulty_levelsUpdateManyMutationInput, difficulty_levelsUncheckedUpdateManyInput>
    /**
     * Filter which difficulty_levels to update
     */
    where?: difficulty_levelsWhereInput
  }

  /**
   * difficulty_levels upsert
   */
  export type difficulty_levelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * The filter to search for the difficulty_levels to update in case it exists.
     */
    where: difficulty_levelsWhereUniqueInput
    /**
     * In case the difficulty_levels found by the `where` argument doesn't exist, create a new difficulty_levels with this data.
     */
    create: XOR<difficulty_levelsCreateInput, difficulty_levelsUncheckedCreateInput>
    /**
     * In case the difficulty_levels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<difficulty_levelsUpdateInput, difficulty_levelsUncheckedUpdateInput>
  }

  /**
   * difficulty_levels delete
   */
  export type difficulty_levelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
    /**
     * Filter which difficulty_levels to delete.
     */
    where: difficulty_levelsWhereUniqueInput
  }

  /**
   * difficulty_levels deleteMany
   */
  export type difficulty_levelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which difficulty_levels to delete
     */
    where?: difficulty_levelsWhereInput
  }

  /**
   * difficulty_levels without action
   */
  export type difficulty_levelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the difficulty_levels
     */
    select?: difficulty_levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: difficulty_levelsInclude<ExtArgs> | null
  }


  /**
   * Model student_progress
   */

  export type AggregateStudent_progress = {
    _count: Student_progressCountAggregateOutputType | null
    _avg: Student_progressAvgAggregateOutputType | null
    _sum: Student_progressSumAggregateOutputType | null
    _min: Student_progressMinAggregateOutputType | null
    _max: Student_progressMaxAggregateOutputType | null
  }

  export type Student_progressAvgAggregateOutputType = {
    user_id: number | null
    level: number | null
    current_xp: number | null
    next_level_xp: number | null
    streak_days: number | null
    total_points: number | null
  }

  export type Student_progressSumAggregateOutputType = {
    user_id: bigint | null
    level: number | null
    current_xp: number | null
    next_level_xp: number | null
    streak_days: number | null
    total_points: number | null
  }

  export type Student_progressMinAggregateOutputType = {
    user_id: bigint | null
    level: number | null
    current_xp: number | null
    next_level_xp: number | null
    streak_days: number | null
    last_activity_date: Date | null
    total_points: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_progressMaxAggregateOutputType = {
    user_id: bigint | null
    level: number | null
    current_xp: number | null
    next_level_xp: number | null
    streak_days: number | null
    last_activity_date: Date | null
    total_points: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_progressCountAggregateOutputType = {
    user_id: number
    level: number
    current_xp: number
    next_level_xp: number
    streak_days: number
    last_activity_date: number
    total_points: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Student_progressAvgAggregateInputType = {
    user_id?: true
    level?: true
    current_xp?: true
    next_level_xp?: true
    streak_days?: true
    total_points?: true
  }

  export type Student_progressSumAggregateInputType = {
    user_id?: true
    level?: true
    current_xp?: true
    next_level_xp?: true
    streak_days?: true
    total_points?: true
  }

  export type Student_progressMinAggregateInputType = {
    user_id?: true
    level?: true
    current_xp?: true
    next_level_xp?: true
    streak_days?: true
    last_activity_date?: true
    total_points?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_progressMaxAggregateInputType = {
    user_id?: true
    level?: true
    current_xp?: true
    next_level_xp?: true
    streak_days?: true
    last_activity_date?: true
    total_points?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_progressCountAggregateInputType = {
    user_id?: true
    level?: true
    current_xp?: true
    next_level_xp?: true
    streak_days?: true
    last_activity_date?: true
    total_points?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Student_progressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_progress to aggregate.
     */
    where?: student_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_progresses to fetch.
     */
    orderBy?: student_progressOrderByWithRelationInput | student_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_progresses
    **/
    _count?: true | Student_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_progressMaxAggregateInputType
  }

  export type GetStudent_progressAggregateType<T extends Student_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_progress[P]>
      : GetScalarType<T[P], AggregateStudent_progress[P]>
  }




  export type student_progressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_progressWhereInput
    orderBy?: student_progressOrderByWithAggregationInput | student_progressOrderByWithAggregationInput[]
    by: Student_progressScalarFieldEnum[] | Student_progressScalarFieldEnum
    having?: student_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_progressCountAggregateInputType | true
    _avg?: Student_progressAvgAggregateInputType
    _sum?: Student_progressSumAggregateInputType
    _min?: Student_progressMinAggregateInputType
    _max?: Student_progressMaxAggregateInputType
  }

  export type Student_progressGroupByOutputType = {
    user_id: bigint
    level: number
    current_xp: number
    next_level_xp: number
    streak_days: number
    last_activity_date: Date | null
    total_points: number
    created_at: Date | null
    updated_at: Date | null
    _count: Student_progressCountAggregateOutputType | null
    _avg: Student_progressAvgAggregateOutputType | null
    _sum: Student_progressSumAggregateOutputType | null
    _min: Student_progressMinAggregateOutputType | null
    _max: Student_progressMaxAggregateOutputType | null
  }

  type GetStudent_progressGroupByPayload<T extends student_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Student_progressGroupByOutputType[P]>
        }
      >
    >


  export type student_progressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    level?: boolean
    current_xp?: boolean
    next_level_xp?: boolean
    streak_days?: boolean
    last_activity_date?: boolean
    total_points?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_progress"]>


  export type student_progressSelectScalar = {
    user_id?: boolean
    level?: boolean
    current_xp?: boolean
    next_level_xp?: boolean
    streak_days?: boolean
    last_activity_date?: boolean
    total_points?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type student_progressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $student_progressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_progress"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      level: number
      current_xp: number
      next_level_xp: number
      streak_days: number
      last_activity_date: Date | null
      total_points: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["student_progress"]>
    composites: {}
  }

  type student_progressGetPayload<S extends boolean | null | undefined | student_progressDefaultArgs> = $Result.GetResult<Prisma.$student_progressPayload, S>

  type student_progressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<student_progressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_progressCountAggregateInputType | true
    }

  export interface student_progressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_progress'], meta: { name: 'student_progress' } }
    /**
     * Find zero or one Student_progress that matches the filter.
     * @param {student_progressFindUniqueArgs} args - Arguments to find a Student_progress
     * @example
     * // Get one Student_progress
     * const student_progress = await prisma.student_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_progressFindUniqueArgs>(args: SelectSubset<T, student_progressFindUniqueArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_progress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {student_progressFindUniqueOrThrowArgs} args - Arguments to find a Student_progress
     * @example
     * // Get one Student_progress
     * const student_progress = await prisma.student_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_progressFindUniqueOrThrowArgs>(args: SelectSubset<T, student_progressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_progressFindFirstArgs} args - Arguments to find a Student_progress
     * @example
     * // Get one Student_progress
     * const student_progress = await prisma.student_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_progressFindFirstArgs>(args?: SelectSubset<T, student_progressFindFirstArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_progressFindFirstOrThrowArgs} args - Arguments to find a Student_progress
     * @example
     * // Get one Student_progress
     * const student_progress = await prisma.student_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_progressFindFirstOrThrowArgs>(args?: SelectSubset<T, student_progressFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_progressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_progresses
     * const student_progresses = await prisma.student_progress.findMany()
     * 
     * // Get first 10 Student_progresses
     * const student_progresses = await prisma.student_progress.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const student_progressWithUser_idOnly = await prisma.student_progress.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends student_progressFindManyArgs>(args?: SelectSubset<T, student_progressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_progress.
     * @param {student_progressCreateArgs} args - Arguments to create a Student_progress.
     * @example
     * // Create one Student_progress
     * const Student_progress = await prisma.student_progress.create({
     *   data: {
     *     // ... data to create a Student_progress
     *   }
     * })
     * 
     */
    create<T extends student_progressCreateArgs>(args: SelectSubset<T, student_progressCreateArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_progresses.
     * @param {student_progressCreateManyArgs} args - Arguments to create many Student_progresses.
     * @example
     * // Create many Student_progresses
     * const student_progress = await prisma.student_progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_progressCreateManyArgs>(args?: SelectSubset<T, student_progressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_progress.
     * @param {student_progressDeleteArgs} args - Arguments to delete one Student_progress.
     * @example
     * // Delete one Student_progress
     * const Student_progress = await prisma.student_progress.delete({
     *   where: {
     *     // ... filter to delete one Student_progress
     *   }
     * })
     * 
     */
    delete<T extends student_progressDeleteArgs>(args: SelectSubset<T, student_progressDeleteArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_progress.
     * @param {student_progressUpdateArgs} args - Arguments to update one Student_progress.
     * @example
     * // Update one Student_progress
     * const student_progress = await prisma.student_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_progressUpdateArgs>(args: SelectSubset<T, student_progressUpdateArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_progresses.
     * @param {student_progressDeleteManyArgs} args - Arguments to filter Student_progresses to delete.
     * @example
     * // Delete a few Student_progresses
     * const { count } = await prisma.student_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_progressDeleteManyArgs>(args?: SelectSubset<T, student_progressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_progresses
     * const student_progress = await prisma.student_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_progressUpdateManyArgs>(args: SelectSubset<T, student_progressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_progress.
     * @param {student_progressUpsertArgs} args - Arguments to update or create a Student_progress.
     * @example
     * // Update or create a Student_progress
     * const student_progress = await prisma.student_progress.upsert({
     *   create: {
     *     // ... data to create a Student_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_progress we want to update
     *   }
     * })
     */
    upsert<T extends student_progressUpsertArgs>(args: SelectSubset<T, student_progressUpsertArgs<ExtArgs>>): Prisma__student_progressClient<$Result.GetResult<Prisma.$student_progressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_progressCountArgs} args - Arguments to filter Student_progresses to count.
     * @example
     * // Count the number of Student_progresses
     * const count = await prisma.student_progress.count({
     *   where: {
     *     // ... the filter for the Student_progresses we want to count
     *   }
     * })
    **/
    count<T extends student_progressCountArgs>(
      args?: Subset<T, student_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_progressAggregateArgs>(args: Subset<T, Student_progressAggregateArgs>): Prisma.PrismaPromise<GetStudent_progressAggregateType<T>>

    /**
     * Group by Student_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_progressGroupByArgs['orderBy'] }
        : { orderBy?: student_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_progress model
   */
  readonly fields: student_progressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_progressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_progress model
   */ 
  interface student_progressFieldRefs {
    readonly user_id: FieldRef<"student_progress", 'BigInt'>
    readonly level: FieldRef<"student_progress", 'Int'>
    readonly current_xp: FieldRef<"student_progress", 'Int'>
    readonly next_level_xp: FieldRef<"student_progress", 'Int'>
    readonly streak_days: FieldRef<"student_progress", 'Int'>
    readonly last_activity_date: FieldRef<"student_progress", 'DateTime'>
    readonly total_points: FieldRef<"student_progress", 'Int'>
    readonly created_at: FieldRef<"student_progress", 'DateTime'>
    readonly updated_at: FieldRef<"student_progress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_progress findUnique
   */
  export type student_progressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * Filter, which student_progress to fetch.
     */
    where: student_progressWhereUniqueInput
  }

  /**
   * student_progress findUniqueOrThrow
   */
  export type student_progressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * Filter, which student_progress to fetch.
     */
    where: student_progressWhereUniqueInput
  }

  /**
   * student_progress findFirst
   */
  export type student_progressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * Filter, which student_progress to fetch.
     */
    where?: student_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_progresses to fetch.
     */
    orderBy?: student_progressOrderByWithRelationInput | student_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_progresses.
     */
    cursor?: student_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_progresses.
     */
    distinct?: Student_progressScalarFieldEnum | Student_progressScalarFieldEnum[]
  }

  /**
   * student_progress findFirstOrThrow
   */
  export type student_progressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * Filter, which student_progress to fetch.
     */
    where?: student_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_progresses to fetch.
     */
    orderBy?: student_progressOrderByWithRelationInput | student_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_progresses.
     */
    cursor?: student_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_progresses.
     */
    distinct?: Student_progressScalarFieldEnum | Student_progressScalarFieldEnum[]
  }

  /**
   * student_progress findMany
   */
  export type student_progressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * Filter, which student_progresses to fetch.
     */
    where?: student_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_progresses to fetch.
     */
    orderBy?: student_progressOrderByWithRelationInput | student_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_progresses.
     */
    cursor?: student_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_progresses.
     */
    skip?: number
    distinct?: Student_progressScalarFieldEnum | Student_progressScalarFieldEnum[]
  }

  /**
   * student_progress create
   */
  export type student_progressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * The data needed to create a student_progress.
     */
    data: XOR<student_progressCreateInput, student_progressUncheckedCreateInput>
  }

  /**
   * student_progress createMany
   */
  export type student_progressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_progresses.
     */
    data: student_progressCreateManyInput | student_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_progress update
   */
  export type student_progressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * The data needed to update a student_progress.
     */
    data: XOR<student_progressUpdateInput, student_progressUncheckedUpdateInput>
    /**
     * Choose, which student_progress to update.
     */
    where: student_progressWhereUniqueInput
  }

  /**
   * student_progress updateMany
   */
  export type student_progressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_progresses.
     */
    data: XOR<student_progressUpdateManyMutationInput, student_progressUncheckedUpdateManyInput>
    /**
     * Filter which student_progresses to update
     */
    where?: student_progressWhereInput
  }

  /**
   * student_progress upsert
   */
  export type student_progressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * The filter to search for the student_progress to update in case it exists.
     */
    where: student_progressWhereUniqueInput
    /**
     * In case the student_progress found by the `where` argument doesn't exist, create a new student_progress with this data.
     */
    create: XOR<student_progressCreateInput, student_progressUncheckedCreateInput>
    /**
     * In case the student_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_progressUpdateInput, student_progressUncheckedUpdateInput>
  }

  /**
   * student_progress delete
   */
  export type student_progressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
    /**
     * Filter which student_progress to delete.
     */
    where: student_progressWhereUniqueInput
  }

  /**
   * student_progress deleteMany
   */
  export type student_progressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_progresses to delete
     */
    where?: student_progressWhereInput
  }

  /**
   * student_progress without action
   */
  export type student_progressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_progress
     */
    select?: student_progressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_progressInclude<ExtArgs> | null
  }


  /**
   * Model achievements
   */

  export type AggregateAchievements = {
    _count: AchievementsCountAggregateOutputType | null
    _avg: AchievementsAvgAggregateOutputType | null
    _sum: AchievementsSumAggregateOutputType | null
    _min: AchievementsMinAggregateOutputType | null
    _max: AchievementsMaxAggregateOutputType | null
  }

  export type AchievementsAvgAggregateOutputType = {
    achievement_id: number | null
    points: number | null
  }

  export type AchievementsSumAggregateOutputType = {
    achievement_id: bigint | null
    points: number | null
  }

  export type AchievementsMinAggregateOutputType = {
    achievement_id: bigint | null
    title: string | null
    description: string | null
    category: string | null
    points: number | null
    icon: string | null
    required_criteria: string | null
    created_at: Date | null
  }

  export type AchievementsMaxAggregateOutputType = {
    achievement_id: bigint | null
    title: string | null
    description: string | null
    category: string | null
    points: number | null
    icon: string | null
    required_criteria: string | null
    created_at: Date | null
  }

  export type AchievementsCountAggregateOutputType = {
    achievement_id: number
    title: number
    description: number
    category: number
    points: number
    icon: number
    required_criteria: number
    created_at: number
    _all: number
  }


  export type AchievementsAvgAggregateInputType = {
    achievement_id?: true
    points?: true
  }

  export type AchievementsSumAggregateInputType = {
    achievement_id?: true
    points?: true
  }

  export type AchievementsMinAggregateInputType = {
    achievement_id?: true
    title?: true
    description?: true
    category?: true
    points?: true
    icon?: true
    required_criteria?: true
    created_at?: true
  }

  export type AchievementsMaxAggregateInputType = {
    achievement_id?: true
    title?: true
    description?: true
    category?: true
    points?: true
    icon?: true
    required_criteria?: true
    created_at?: true
  }

  export type AchievementsCountAggregateInputType = {
    achievement_id?: true
    title?: true
    description?: true
    category?: true
    points?: true
    icon?: true
    required_criteria?: true
    created_at?: true
    _all?: true
  }

  export type AchievementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which achievements to aggregate.
     */
    where?: achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementsOrderByWithRelationInput | achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned achievements
    **/
    _count?: true | AchievementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementsMaxAggregateInputType
  }

  export type GetAchievementsAggregateType<T extends AchievementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievements[P]>
      : GetScalarType<T[P], AggregateAchievements[P]>
  }




  export type achievementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: achievementsWhereInput
    orderBy?: achievementsOrderByWithAggregationInput | achievementsOrderByWithAggregationInput[]
    by: AchievementsScalarFieldEnum[] | AchievementsScalarFieldEnum
    having?: achievementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementsCountAggregateInputType | true
    _avg?: AchievementsAvgAggregateInputType
    _sum?: AchievementsSumAggregateInputType
    _min?: AchievementsMinAggregateInputType
    _max?: AchievementsMaxAggregateInputType
  }

  export type AchievementsGroupByOutputType = {
    achievement_id: bigint
    title: string
    description: string
    category: string
    points: number
    icon: string | null
    required_criteria: string
    created_at: Date | null
    _count: AchievementsCountAggregateOutputType | null
    _avg: AchievementsAvgAggregateOutputType | null
    _sum: AchievementsSumAggregateOutputType | null
    _min: AchievementsMinAggregateOutputType | null
    _max: AchievementsMaxAggregateOutputType | null
  }

  type GetAchievementsGroupByPayload<T extends achievementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementsGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementsGroupByOutputType[P]>
        }
      >
    >


  export type achievementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    achievement_id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    points?: boolean
    icon?: boolean
    required_criteria?: boolean
    created_at?: boolean
    student_achievements?: boolean | achievements$student_achievementsArgs<ExtArgs>
    _count?: boolean | AchievementsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievements"]>


  export type achievementsSelectScalar = {
    achievement_id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    points?: boolean
    icon?: boolean
    required_criteria?: boolean
    created_at?: boolean
  }

  export type achievementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_achievements?: boolean | achievements$student_achievementsArgs<ExtArgs>
    _count?: boolean | AchievementsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $achievementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "achievements"
    objects: {
      student_achievements: Prisma.$student_achievementsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      achievement_id: bigint
      title: string
      description: string
      category: string
      points: number
      icon: string | null
      required_criteria: string
      created_at: Date | null
    }, ExtArgs["result"]["achievements"]>
    composites: {}
  }

  type achievementsGetPayload<S extends boolean | null | undefined | achievementsDefaultArgs> = $Result.GetResult<Prisma.$achievementsPayload, S>

  type achievementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<achievementsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementsCountAggregateInputType | true
    }

  export interface achievementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['achievements'], meta: { name: 'achievements' } }
    /**
     * Find zero or one Achievements that matches the filter.
     * @param {achievementsFindUniqueArgs} args - Arguments to find a Achievements
     * @example
     * // Get one Achievements
     * const achievements = await prisma.achievements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends achievementsFindUniqueArgs>(args: SelectSubset<T, achievementsFindUniqueArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievements that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {achievementsFindUniqueOrThrowArgs} args - Arguments to find a Achievements
     * @example
     * // Get one Achievements
     * const achievements = await prisma.achievements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends achievementsFindUniqueOrThrowArgs>(args: SelectSubset<T, achievementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementsFindFirstArgs} args - Arguments to find a Achievements
     * @example
     * // Get one Achievements
     * const achievements = await prisma.achievements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends achievementsFindFirstArgs>(args?: SelectSubset<T, achievementsFindFirstArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementsFindFirstOrThrowArgs} args - Arguments to find a Achievements
     * @example
     * // Get one Achievements
     * const achievements = await prisma.achievements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends achievementsFindFirstOrThrowArgs>(args?: SelectSubset<T, achievementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievements.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievements.findMany({ take: 10 })
     * 
     * // Only select the `achievement_id`
     * const achievementsWithAchievement_idOnly = await prisma.achievements.findMany({ select: { achievement_id: true } })
     * 
     */
    findMany<T extends achievementsFindManyArgs>(args?: SelectSubset<T, achievementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievements.
     * @param {achievementsCreateArgs} args - Arguments to create a Achievements.
     * @example
     * // Create one Achievements
     * const Achievements = await prisma.achievements.create({
     *   data: {
     *     // ... data to create a Achievements
     *   }
     * })
     * 
     */
    create<T extends achievementsCreateArgs>(args: SelectSubset<T, achievementsCreateArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {achievementsCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievements = await prisma.achievements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends achievementsCreateManyArgs>(args?: SelectSubset<T, achievementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Achievements.
     * @param {achievementsDeleteArgs} args - Arguments to delete one Achievements.
     * @example
     * // Delete one Achievements
     * const Achievements = await prisma.achievements.delete({
     *   where: {
     *     // ... filter to delete one Achievements
     *   }
     * })
     * 
     */
    delete<T extends achievementsDeleteArgs>(args: SelectSubset<T, achievementsDeleteArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievements.
     * @param {achievementsUpdateArgs} args - Arguments to update one Achievements.
     * @example
     * // Update one Achievements
     * const achievements = await prisma.achievements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends achievementsUpdateArgs>(args: SelectSubset<T, achievementsUpdateArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {achievementsDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends achievementsDeleteManyArgs>(args?: SelectSubset<T, achievementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievements = await prisma.achievements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends achievementsUpdateManyArgs>(args: SelectSubset<T, achievementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievements.
     * @param {achievementsUpsertArgs} args - Arguments to update or create a Achievements.
     * @example
     * // Update or create a Achievements
     * const achievements = await prisma.achievements.upsert({
     *   create: {
     *     // ... data to create a Achievements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievements we want to update
     *   }
     * })
     */
    upsert<T extends achievementsUpsertArgs>(args: SelectSubset<T, achievementsUpsertArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementsCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievements.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends achievementsCountArgs>(
      args?: Subset<T, achievementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementsAggregateArgs>(args: Subset<T, AchievementsAggregateArgs>): Prisma.PrismaPromise<GetAchievementsAggregateType<T>>

    /**
     * Group by Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends achievementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: achievementsGroupByArgs['orderBy'] }
        : { orderBy?: achievementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, achievementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the achievements model
   */
  readonly fields: achievementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for achievements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__achievementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student_achievements<T extends achievements$student_achievementsArgs<ExtArgs> = {}>(args?: Subset<T, achievements$student_achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the achievements model
   */ 
  interface achievementsFieldRefs {
    readonly achievement_id: FieldRef<"achievements", 'BigInt'>
    readonly title: FieldRef<"achievements", 'String'>
    readonly description: FieldRef<"achievements", 'String'>
    readonly category: FieldRef<"achievements", 'String'>
    readonly points: FieldRef<"achievements", 'Int'>
    readonly icon: FieldRef<"achievements", 'String'>
    readonly required_criteria: FieldRef<"achievements", 'String'>
    readonly created_at: FieldRef<"achievements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * achievements findUnique
   */
  export type achievementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where: achievementsWhereUniqueInput
  }

  /**
   * achievements findUniqueOrThrow
   */
  export type achievementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where: achievementsWhereUniqueInput
  }

  /**
   * achievements findFirst
   */
  export type achievementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where?: achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementsOrderByWithRelationInput | achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for achievements.
     */
    cursor?: achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of achievements.
     */
    distinct?: AchievementsScalarFieldEnum | AchievementsScalarFieldEnum[]
  }

  /**
   * achievements findFirstOrThrow
   */
  export type achievementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where?: achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementsOrderByWithRelationInput | achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for achievements.
     */
    cursor?: achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of achievements.
     */
    distinct?: AchievementsScalarFieldEnum | AchievementsScalarFieldEnum[]
  }

  /**
   * achievements findMany
   */
  export type achievementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where?: achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementsOrderByWithRelationInput | achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing achievements.
     */
    cursor?: achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    distinct?: AchievementsScalarFieldEnum | AchievementsScalarFieldEnum[]
  }

  /**
   * achievements create
   */
  export type achievementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * The data needed to create a achievements.
     */
    data: XOR<achievementsCreateInput, achievementsUncheckedCreateInput>
  }

  /**
   * achievements createMany
   */
  export type achievementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many achievements.
     */
    data: achievementsCreateManyInput | achievementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * achievements update
   */
  export type achievementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * The data needed to update a achievements.
     */
    data: XOR<achievementsUpdateInput, achievementsUncheckedUpdateInput>
    /**
     * Choose, which achievements to update.
     */
    where: achievementsWhereUniqueInput
  }

  /**
   * achievements updateMany
   */
  export type achievementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update achievements.
     */
    data: XOR<achievementsUpdateManyMutationInput, achievementsUncheckedUpdateManyInput>
    /**
     * Filter which achievements to update
     */
    where?: achievementsWhereInput
  }

  /**
   * achievements upsert
   */
  export type achievementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * The filter to search for the achievements to update in case it exists.
     */
    where: achievementsWhereUniqueInput
    /**
     * In case the achievements found by the `where` argument doesn't exist, create a new achievements with this data.
     */
    create: XOR<achievementsCreateInput, achievementsUncheckedCreateInput>
    /**
     * In case the achievements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<achievementsUpdateInput, achievementsUncheckedUpdateInput>
  }

  /**
   * achievements delete
   */
  export type achievementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
    /**
     * Filter which achievements to delete.
     */
    where: achievementsWhereUniqueInput
  }

  /**
   * achievements deleteMany
   */
  export type achievementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which achievements to delete
     */
    where?: achievementsWhereInput
  }

  /**
   * achievements.student_achievements
   */
  export type achievements$student_achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    where?: student_achievementsWhereInput
    orderBy?: student_achievementsOrderByWithRelationInput | student_achievementsOrderByWithRelationInput[]
    cursor?: student_achievementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_achievementsScalarFieldEnum | Student_achievementsScalarFieldEnum[]
  }

  /**
   * achievements without action
   */
  export type achievementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievements
     */
    select?: achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementsInclude<ExtArgs> | null
  }


  /**
   * Model student_achievements
   */

  export type AggregateStudent_achievements = {
    _count: Student_achievementsCountAggregateOutputType | null
    _avg: Student_achievementsAvgAggregateOutputType | null
    _sum: Student_achievementsSumAggregateOutputType | null
    _min: Student_achievementsMinAggregateOutputType | null
    _max: Student_achievementsMaxAggregateOutputType | null
  }

  export type Student_achievementsAvgAggregateOutputType = {
    user_id: number | null
    achievement_id: number | null
    progress: number | null
  }

  export type Student_achievementsSumAggregateOutputType = {
    user_id: bigint | null
    achievement_id: bigint | null
    progress: number | null
  }

  export type Student_achievementsMinAggregateOutputType = {
    user_id: bigint | null
    achievement_id: bigint | null
    unlocked_at: Date | null
    progress: number | null
  }

  export type Student_achievementsMaxAggregateOutputType = {
    user_id: bigint | null
    achievement_id: bigint | null
    unlocked_at: Date | null
    progress: number | null
  }

  export type Student_achievementsCountAggregateOutputType = {
    user_id: number
    achievement_id: number
    unlocked_at: number
    progress: number
    _all: number
  }


  export type Student_achievementsAvgAggregateInputType = {
    user_id?: true
    achievement_id?: true
    progress?: true
  }

  export type Student_achievementsSumAggregateInputType = {
    user_id?: true
    achievement_id?: true
    progress?: true
  }

  export type Student_achievementsMinAggregateInputType = {
    user_id?: true
    achievement_id?: true
    unlocked_at?: true
    progress?: true
  }

  export type Student_achievementsMaxAggregateInputType = {
    user_id?: true
    achievement_id?: true
    unlocked_at?: true
    progress?: true
  }

  export type Student_achievementsCountAggregateInputType = {
    user_id?: true
    achievement_id?: true
    unlocked_at?: true
    progress?: true
    _all?: true
  }

  export type Student_achievementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_achievements to aggregate.
     */
    where?: student_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_achievements to fetch.
     */
    orderBy?: student_achievementsOrderByWithRelationInput | student_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_achievements
    **/
    _count?: true | Student_achievementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_achievementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_achievementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_achievementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_achievementsMaxAggregateInputType
  }

  export type GetStudent_achievementsAggregateType<T extends Student_achievementsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_achievements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_achievements[P]>
      : GetScalarType<T[P], AggregateStudent_achievements[P]>
  }




  export type student_achievementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_achievementsWhereInput
    orderBy?: student_achievementsOrderByWithAggregationInput | student_achievementsOrderByWithAggregationInput[]
    by: Student_achievementsScalarFieldEnum[] | Student_achievementsScalarFieldEnum
    having?: student_achievementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_achievementsCountAggregateInputType | true
    _avg?: Student_achievementsAvgAggregateInputType
    _sum?: Student_achievementsSumAggregateInputType
    _min?: Student_achievementsMinAggregateInputType
    _max?: Student_achievementsMaxAggregateInputType
  }

  export type Student_achievementsGroupByOutputType = {
    user_id: bigint
    achievement_id: bigint
    unlocked_at: Date | null
    progress: number
    _count: Student_achievementsCountAggregateOutputType | null
    _avg: Student_achievementsAvgAggregateOutputType | null
    _sum: Student_achievementsSumAggregateOutputType | null
    _min: Student_achievementsMinAggregateOutputType | null
    _max: Student_achievementsMaxAggregateOutputType | null
  }

  type GetStudent_achievementsGroupByPayload<T extends student_achievementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_achievementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_achievementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_achievementsGroupByOutputType[P]>
            : GetScalarType<T[P], Student_achievementsGroupByOutputType[P]>
        }
      >
    >


  export type student_achievementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    achievement_id?: boolean
    unlocked_at?: boolean
    progress?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    achievements?: boolean | achievementsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_achievements"]>


  export type student_achievementsSelectScalar = {
    user_id?: boolean
    achievement_id?: boolean
    unlocked_at?: boolean
    progress?: boolean
  }

  export type student_achievementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    achievements?: boolean | achievementsDefaultArgs<ExtArgs>
  }

  export type $student_achievementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_achievements"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      achievements: Prisma.$achievementsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      achievement_id: bigint
      unlocked_at: Date | null
      progress: number
    }, ExtArgs["result"]["student_achievements"]>
    composites: {}
  }

  type student_achievementsGetPayload<S extends boolean | null | undefined | student_achievementsDefaultArgs> = $Result.GetResult<Prisma.$student_achievementsPayload, S>

  type student_achievementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<student_achievementsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_achievementsCountAggregateInputType | true
    }

  export interface student_achievementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_achievements'], meta: { name: 'student_achievements' } }
    /**
     * Find zero or one Student_achievements that matches the filter.
     * @param {student_achievementsFindUniqueArgs} args - Arguments to find a Student_achievements
     * @example
     * // Get one Student_achievements
     * const student_achievements = await prisma.student_achievements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_achievementsFindUniqueArgs>(args: SelectSubset<T, student_achievementsFindUniqueArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_achievements that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {student_achievementsFindUniqueOrThrowArgs} args - Arguments to find a Student_achievements
     * @example
     * // Get one Student_achievements
     * const student_achievements = await prisma.student_achievements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_achievementsFindUniqueOrThrowArgs>(args: SelectSubset<T, student_achievementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_achievementsFindFirstArgs} args - Arguments to find a Student_achievements
     * @example
     * // Get one Student_achievements
     * const student_achievements = await prisma.student_achievements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_achievementsFindFirstArgs>(args?: SelectSubset<T, student_achievementsFindFirstArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_achievements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_achievementsFindFirstOrThrowArgs} args - Arguments to find a Student_achievements
     * @example
     * // Get one Student_achievements
     * const student_achievements = await prisma.student_achievements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_achievementsFindFirstOrThrowArgs>(args?: SelectSubset<T, student_achievementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_achievementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_achievements
     * const student_achievements = await prisma.student_achievements.findMany()
     * 
     * // Get first 10 Student_achievements
     * const student_achievements = await prisma.student_achievements.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const student_achievementsWithUser_idOnly = await prisma.student_achievements.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends student_achievementsFindManyArgs>(args?: SelectSubset<T, student_achievementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_achievements.
     * @param {student_achievementsCreateArgs} args - Arguments to create a Student_achievements.
     * @example
     * // Create one Student_achievements
     * const Student_achievements = await prisma.student_achievements.create({
     *   data: {
     *     // ... data to create a Student_achievements
     *   }
     * })
     * 
     */
    create<T extends student_achievementsCreateArgs>(args: SelectSubset<T, student_achievementsCreateArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_achievements.
     * @param {student_achievementsCreateManyArgs} args - Arguments to create many Student_achievements.
     * @example
     * // Create many Student_achievements
     * const student_achievements = await prisma.student_achievements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_achievementsCreateManyArgs>(args?: SelectSubset<T, student_achievementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_achievements.
     * @param {student_achievementsDeleteArgs} args - Arguments to delete one Student_achievements.
     * @example
     * // Delete one Student_achievements
     * const Student_achievements = await prisma.student_achievements.delete({
     *   where: {
     *     // ... filter to delete one Student_achievements
     *   }
     * })
     * 
     */
    delete<T extends student_achievementsDeleteArgs>(args: SelectSubset<T, student_achievementsDeleteArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_achievements.
     * @param {student_achievementsUpdateArgs} args - Arguments to update one Student_achievements.
     * @example
     * // Update one Student_achievements
     * const student_achievements = await prisma.student_achievements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_achievementsUpdateArgs>(args: SelectSubset<T, student_achievementsUpdateArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_achievements.
     * @param {student_achievementsDeleteManyArgs} args - Arguments to filter Student_achievements to delete.
     * @example
     * // Delete a few Student_achievements
     * const { count } = await prisma.student_achievements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_achievementsDeleteManyArgs>(args?: SelectSubset<T, student_achievementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_achievementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_achievements
     * const student_achievements = await prisma.student_achievements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_achievementsUpdateManyArgs>(args: SelectSubset<T, student_achievementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_achievements.
     * @param {student_achievementsUpsertArgs} args - Arguments to update or create a Student_achievements.
     * @example
     * // Update or create a Student_achievements
     * const student_achievements = await prisma.student_achievements.upsert({
     *   create: {
     *     // ... data to create a Student_achievements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_achievements we want to update
     *   }
     * })
     */
    upsert<T extends student_achievementsUpsertArgs>(args: SelectSubset<T, student_achievementsUpsertArgs<ExtArgs>>): Prisma__student_achievementsClient<$Result.GetResult<Prisma.$student_achievementsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_achievementsCountArgs} args - Arguments to filter Student_achievements to count.
     * @example
     * // Count the number of Student_achievements
     * const count = await prisma.student_achievements.count({
     *   where: {
     *     // ... the filter for the Student_achievements we want to count
     *   }
     * })
    **/
    count<T extends student_achievementsCountArgs>(
      args?: Subset<T, student_achievementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_achievementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_achievementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_achievementsAggregateArgs>(args: Subset<T, Student_achievementsAggregateArgs>): Prisma.PrismaPromise<GetStudent_achievementsAggregateType<T>>

    /**
     * Group by Student_achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_achievementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_achievementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_achievementsGroupByArgs['orderBy'] }
        : { orderBy?: student_achievementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_achievementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_achievementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_achievements model
   */
  readonly fields: student_achievementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_achievements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_achievementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievements<T extends achievementsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, achievementsDefaultArgs<ExtArgs>>): Prisma__achievementsClient<$Result.GetResult<Prisma.$achievementsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_achievements model
   */ 
  interface student_achievementsFieldRefs {
    readonly user_id: FieldRef<"student_achievements", 'BigInt'>
    readonly achievement_id: FieldRef<"student_achievements", 'BigInt'>
    readonly unlocked_at: FieldRef<"student_achievements", 'DateTime'>
    readonly progress: FieldRef<"student_achievements", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * student_achievements findUnique
   */
  export type student_achievementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * Filter, which student_achievements to fetch.
     */
    where: student_achievementsWhereUniqueInput
  }

  /**
   * student_achievements findUniqueOrThrow
   */
  export type student_achievementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * Filter, which student_achievements to fetch.
     */
    where: student_achievementsWhereUniqueInput
  }

  /**
   * student_achievements findFirst
   */
  export type student_achievementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * Filter, which student_achievements to fetch.
     */
    where?: student_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_achievements to fetch.
     */
    orderBy?: student_achievementsOrderByWithRelationInput | student_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_achievements.
     */
    cursor?: student_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_achievements.
     */
    distinct?: Student_achievementsScalarFieldEnum | Student_achievementsScalarFieldEnum[]
  }

  /**
   * student_achievements findFirstOrThrow
   */
  export type student_achievementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * Filter, which student_achievements to fetch.
     */
    where?: student_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_achievements to fetch.
     */
    orderBy?: student_achievementsOrderByWithRelationInput | student_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_achievements.
     */
    cursor?: student_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_achievements.
     */
    distinct?: Student_achievementsScalarFieldEnum | Student_achievementsScalarFieldEnum[]
  }

  /**
   * student_achievements findMany
   */
  export type student_achievementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * Filter, which student_achievements to fetch.
     */
    where?: student_achievementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_achievements to fetch.
     */
    orderBy?: student_achievementsOrderByWithRelationInput | student_achievementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_achievements.
     */
    cursor?: student_achievementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_achievements.
     */
    skip?: number
    distinct?: Student_achievementsScalarFieldEnum | Student_achievementsScalarFieldEnum[]
  }

  /**
   * student_achievements create
   */
  export type student_achievementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * The data needed to create a student_achievements.
     */
    data: XOR<student_achievementsCreateInput, student_achievementsUncheckedCreateInput>
  }

  /**
   * student_achievements createMany
   */
  export type student_achievementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_achievements.
     */
    data: student_achievementsCreateManyInput | student_achievementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_achievements update
   */
  export type student_achievementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * The data needed to update a student_achievements.
     */
    data: XOR<student_achievementsUpdateInput, student_achievementsUncheckedUpdateInput>
    /**
     * Choose, which student_achievements to update.
     */
    where: student_achievementsWhereUniqueInput
  }

  /**
   * student_achievements updateMany
   */
  export type student_achievementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_achievements.
     */
    data: XOR<student_achievementsUpdateManyMutationInput, student_achievementsUncheckedUpdateManyInput>
    /**
     * Filter which student_achievements to update
     */
    where?: student_achievementsWhereInput
  }

  /**
   * student_achievements upsert
   */
  export type student_achievementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * The filter to search for the student_achievements to update in case it exists.
     */
    where: student_achievementsWhereUniqueInput
    /**
     * In case the student_achievements found by the `where` argument doesn't exist, create a new student_achievements with this data.
     */
    create: XOR<student_achievementsCreateInput, student_achievementsUncheckedCreateInput>
    /**
     * In case the student_achievements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_achievementsUpdateInput, student_achievementsUncheckedUpdateInput>
  }

  /**
   * student_achievements delete
   */
  export type student_achievementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
    /**
     * Filter which student_achievements to delete.
     */
    where: student_achievementsWhereUniqueInput
  }

  /**
   * student_achievements deleteMany
   */
  export type student_achievementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_achievements to delete
     */
    where?: student_achievementsWhereInput
  }

  /**
   * student_achievements without action
   */
  export type student_achievementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_achievements
     */
    select?: student_achievementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_achievementsInclude<ExtArgs> | null
  }


  /**
   * Model rewards
   */

  export type AggregateRewards = {
    _count: RewardsCountAggregateOutputType | null
    _avg: RewardsAvgAggregateOutputType | null
    _sum: RewardsSumAggregateOutputType | null
    _min: RewardsMinAggregateOutputType | null
    _max: RewardsMaxAggregateOutputType | null
  }

  export type RewardsAvgAggregateOutputType = {
    reward_id: number | null
    cost: number | null
  }

  export type RewardsSumAggregateOutputType = {
    reward_id: bigint | null
    cost: number | null
  }

  export type RewardsMinAggregateOutputType = {
    reward_id: bigint | null
    title: string | null
    description: string | null
    category: string | null
    cost: number | null
    icon: string | null
    created_at: Date | null
  }

  export type RewardsMaxAggregateOutputType = {
    reward_id: bigint | null
    title: string | null
    description: string | null
    category: string | null
    cost: number | null
    icon: string | null
    created_at: Date | null
  }

  export type RewardsCountAggregateOutputType = {
    reward_id: number
    title: number
    description: number
    category: number
    cost: number
    icon: number
    created_at: number
    _all: number
  }


  export type RewardsAvgAggregateInputType = {
    reward_id?: true
    cost?: true
  }

  export type RewardsSumAggregateInputType = {
    reward_id?: true
    cost?: true
  }

  export type RewardsMinAggregateInputType = {
    reward_id?: true
    title?: true
    description?: true
    category?: true
    cost?: true
    icon?: true
    created_at?: true
  }

  export type RewardsMaxAggregateInputType = {
    reward_id?: true
    title?: true
    description?: true
    category?: true
    cost?: true
    icon?: true
    created_at?: true
  }

  export type RewardsCountAggregateInputType = {
    reward_id?: true
    title?: true
    description?: true
    category?: true
    cost?: true
    icon?: true
    created_at?: true
    _all?: true
  }

  export type RewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewards to aggregate.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rewards
    **/
    _count?: true | RewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardsMaxAggregateInputType
  }

  export type GetRewardsAggregateType<T extends RewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateRewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewards[P]>
      : GetScalarType<T[P], AggregateRewards[P]>
  }




  export type rewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rewardsWhereInput
    orderBy?: rewardsOrderByWithAggregationInput | rewardsOrderByWithAggregationInput[]
    by: RewardsScalarFieldEnum[] | RewardsScalarFieldEnum
    having?: rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardsCountAggregateInputType | true
    _avg?: RewardsAvgAggregateInputType
    _sum?: RewardsSumAggregateInputType
    _min?: RewardsMinAggregateInputType
    _max?: RewardsMaxAggregateInputType
  }

  export type RewardsGroupByOutputType = {
    reward_id: bigint
    title: string
    description: string
    category: string
    cost: number
    icon: string | null
    created_at: Date | null
    _count: RewardsCountAggregateOutputType | null
    _avg: RewardsAvgAggregateOutputType | null
    _sum: RewardsSumAggregateOutputType | null
    _min: RewardsMinAggregateOutputType | null
    _max: RewardsMaxAggregateOutputType | null
  }

  type GetRewardsGroupByPayload<T extends rewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardsGroupByOutputType[P]>
            : GetScalarType<T[P], RewardsGroupByOutputType[P]>
        }
      >
    >


  export type rewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reward_id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    cost?: boolean
    icon?: boolean
    created_at?: boolean
    student_rewards?: boolean | rewards$student_rewardsArgs<ExtArgs>
    _count?: boolean | RewardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewards"]>


  export type rewardsSelectScalar = {
    reward_id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    cost?: boolean
    icon?: boolean
    created_at?: boolean
  }

  export type rewardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_rewards?: boolean | rewards$student_rewardsArgs<ExtArgs>
    _count?: boolean | RewardsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rewards"
    objects: {
      student_rewards: Prisma.$student_rewardsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      reward_id: bigint
      title: string
      description: string
      category: string
      cost: number
      icon: string | null
      created_at: Date | null
    }, ExtArgs["result"]["rewards"]>
    composites: {}
  }

  type rewardsGetPayload<S extends boolean | null | undefined | rewardsDefaultArgs> = $Result.GetResult<Prisma.$rewardsPayload, S>

  type rewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rewardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardsCountAggregateInputType | true
    }

  export interface rewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rewards'], meta: { name: 'rewards' } }
    /**
     * Find zero or one Rewards that matches the filter.
     * @param {rewardsFindUniqueArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rewardsFindUniqueArgs>(args: SelectSubset<T, rewardsFindUniqueArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rewards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rewardsFindUniqueOrThrowArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, rewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsFindFirstArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rewardsFindFirstArgs>(args?: SelectSubset<T, rewardsFindFirstArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsFindFirstOrThrowArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, rewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.rewards.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.rewards.findMany({ take: 10 })
     * 
     * // Only select the `reward_id`
     * const rewardsWithReward_idOnly = await prisma.rewards.findMany({ select: { reward_id: true } })
     * 
     */
    findMany<T extends rewardsFindManyArgs>(args?: SelectSubset<T, rewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rewards.
     * @param {rewardsCreateArgs} args - Arguments to create a Rewards.
     * @example
     * // Create one Rewards
     * const Rewards = await prisma.rewards.create({
     *   data: {
     *     // ... data to create a Rewards
     *   }
     * })
     * 
     */
    create<T extends rewardsCreateArgs>(args: SelectSubset<T, rewardsCreateArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rewards.
     * @param {rewardsCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const rewards = await prisma.rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rewardsCreateManyArgs>(args?: SelectSubset<T, rewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rewards.
     * @param {rewardsDeleteArgs} args - Arguments to delete one Rewards.
     * @example
     * // Delete one Rewards
     * const Rewards = await prisma.rewards.delete({
     *   where: {
     *     // ... filter to delete one Rewards
     *   }
     * })
     * 
     */
    delete<T extends rewardsDeleteArgs>(args: SelectSubset<T, rewardsDeleteArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rewards.
     * @param {rewardsUpdateArgs} args - Arguments to update one Rewards.
     * @example
     * // Update one Rewards
     * const rewards = await prisma.rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rewardsUpdateArgs>(args: SelectSubset<T, rewardsUpdateArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rewards.
     * @param {rewardsDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rewardsDeleteManyArgs>(args?: SelectSubset<T, rewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const rewards = await prisma.rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rewardsUpdateManyArgs>(args: SelectSubset<T, rewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rewards.
     * @param {rewardsUpsertArgs} args - Arguments to update or create a Rewards.
     * @example
     * // Update or create a Rewards
     * const rewards = await prisma.rewards.upsert({
     *   create: {
     *     // ... data to create a Rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rewards we want to update
     *   }
     * })
     */
    upsert<T extends rewardsUpsertArgs>(args: SelectSubset<T, rewardsUpsertArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.rewards.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends rewardsCountArgs>(
      args?: Subset<T, rewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardsAggregateArgs>(args: Subset<T, RewardsAggregateArgs>): Prisma.PrismaPromise<GetRewardsAggregateType<T>>

    /**
     * Group by Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rewardsGroupByArgs['orderBy'] }
        : { orderBy?: rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rewards model
   */
  readonly fields: rewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student_rewards<T extends rewards$student_rewardsArgs<ExtArgs> = {}>(args?: Subset<T, rewards$student_rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rewards model
   */ 
  interface rewardsFieldRefs {
    readonly reward_id: FieldRef<"rewards", 'BigInt'>
    readonly title: FieldRef<"rewards", 'String'>
    readonly description: FieldRef<"rewards", 'String'>
    readonly category: FieldRef<"rewards", 'String'>
    readonly cost: FieldRef<"rewards", 'Int'>
    readonly icon: FieldRef<"rewards", 'String'>
    readonly created_at: FieldRef<"rewards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rewards findUnique
   */
  export type rewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards findUniqueOrThrow
   */
  export type rewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards findFirst
   */
  export type rewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * rewards findFirstOrThrow
   */
  export type rewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * rewards findMany
   */
  export type rewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rewards.
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * rewards create
   */
  export type rewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * The data needed to create a rewards.
     */
    data: XOR<rewardsCreateInput, rewardsUncheckedCreateInput>
  }

  /**
   * rewards createMany
   */
  export type rewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rewards.
     */
    data: rewardsCreateManyInput | rewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rewards update
   */
  export type rewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * The data needed to update a rewards.
     */
    data: XOR<rewardsUpdateInput, rewardsUncheckedUpdateInput>
    /**
     * Choose, which rewards to update.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards updateMany
   */
  export type rewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rewards.
     */
    data: XOR<rewardsUpdateManyMutationInput, rewardsUncheckedUpdateManyInput>
    /**
     * Filter which rewards to update
     */
    where?: rewardsWhereInput
  }

  /**
   * rewards upsert
   */
  export type rewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * The filter to search for the rewards to update in case it exists.
     */
    where: rewardsWhereUniqueInput
    /**
     * In case the rewards found by the `where` argument doesn't exist, create a new rewards with this data.
     */
    create: XOR<rewardsCreateInput, rewardsUncheckedCreateInput>
    /**
     * In case the rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rewardsUpdateInput, rewardsUncheckedUpdateInput>
  }

  /**
   * rewards delete
   */
  export type rewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
    /**
     * Filter which rewards to delete.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards deleteMany
   */
  export type rewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewards to delete
     */
    where?: rewardsWhereInput
  }

  /**
   * rewards.student_rewards
   */
  export type rewards$student_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    where?: student_rewardsWhereInput
    orderBy?: student_rewardsOrderByWithRelationInput | student_rewardsOrderByWithRelationInput[]
    cursor?: student_rewardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_rewardsScalarFieldEnum | Student_rewardsScalarFieldEnum[]
  }

  /**
   * rewards without action
   */
  export type rewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardsInclude<ExtArgs> | null
  }


  /**
   * Model student_rewards
   */

  export type AggregateStudent_rewards = {
    _count: Student_rewardsCountAggregateOutputType | null
    _avg: Student_rewardsAvgAggregateOutputType | null
    _sum: Student_rewardsSumAggregateOutputType | null
    _min: Student_rewardsMinAggregateOutputType | null
    _max: Student_rewardsMaxAggregateOutputType | null
  }

  export type Student_rewardsAvgAggregateOutputType = {
    user_id: number | null
    reward_id: number | null
  }

  export type Student_rewardsSumAggregateOutputType = {
    user_id: bigint | null
    reward_id: bigint | null
  }

  export type Student_rewardsMinAggregateOutputType = {
    user_id: bigint | null
    reward_id: bigint | null
    purchased_at: Date | null
  }

  export type Student_rewardsMaxAggregateOutputType = {
    user_id: bigint | null
    reward_id: bigint | null
    purchased_at: Date | null
  }

  export type Student_rewardsCountAggregateOutputType = {
    user_id: number
    reward_id: number
    purchased_at: number
    _all: number
  }


  export type Student_rewardsAvgAggregateInputType = {
    user_id?: true
    reward_id?: true
  }

  export type Student_rewardsSumAggregateInputType = {
    user_id?: true
    reward_id?: true
  }

  export type Student_rewardsMinAggregateInputType = {
    user_id?: true
    reward_id?: true
    purchased_at?: true
  }

  export type Student_rewardsMaxAggregateInputType = {
    user_id?: true
    reward_id?: true
    purchased_at?: true
  }

  export type Student_rewardsCountAggregateInputType = {
    user_id?: true
    reward_id?: true
    purchased_at?: true
    _all?: true
  }

  export type Student_rewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_rewards to aggregate.
     */
    where?: student_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_rewards to fetch.
     */
    orderBy?: student_rewardsOrderByWithRelationInput | student_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_rewards
    **/
    _count?: true | Student_rewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_rewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_rewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_rewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_rewardsMaxAggregateInputType
  }

  export type GetStudent_rewardsAggregateType<T extends Student_rewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_rewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_rewards[P]>
      : GetScalarType<T[P], AggregateStudent_rewards[P]>
  }




  export type student_rewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_rewardsWhereInput
    orderBy?: student_rewardsOrderByWithAggregationInput | student_rewardsOrderByWithAggregationInput[]
    by: Student_rewardsScalarFieldEnum[] | Student_rewardsScalarFieldEnum
    having?: student_rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_rewardsCountAggregateInputType | true
    _avg?: Student_rewardsAvgAggregateInputType
    _sum?: Student_rewardsSumAggregateInputType
    _min?: Student_rewardsMinAggregateInputType
    _max?: Student_rewardsMaxAggregateInputType
  }

  export type Student_rewardsGroupByOutputType = {
    user_id: bigint
    reward_id: bigint
    purchased_at: Date | null
    _count: Student_rewardsCountAggregateOutputType | null
    _avg: Student_rewardsAvgAggregateOutputType | null
    _sum: Student_rewardsSumAggregateOutputType | null
    _min: Student_rewardsMinAggregateOutputType | null
    _max: Student_rewardsMaxAggregateOutputType | null
  }

  type GetStudent_rewardsGroupByPayload<T extends student_rewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_rewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_rewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_rewardsGroupByOutputType[P]>
            : GetScalarType<T[P], Student_rewardsGroupByOutputType[P]>
        }
      >
    >


  export type student_rewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    reward_id?: boolean
    purchased_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    rewards?: boolean | rewardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_rewards"]>


  export type student_rewardsSelectScalar = {
    user_id?: boolean
    reward_id?: boolean
    purchased_at?: boolean
  }

  export type student_rewardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    rewards?: boolean | rewardsDefaultArgs<ExtArgs>
  }

  export type $student_rewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_rewards"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      rewards: Prisma.$rewardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      reward_id: bigint
      purchased_at: Date | null
    }, ExtArgs["result"]["student_rewards"]>
    composites: {}
  }

  type student_rewardsGetPayload<S extends boolean | null | undefined | student_rewardsDefaultArgs> = $Result.GetResult<Prisma.$student_rewardsPayload, S>

  type student_rewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<student_rewardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_rewardsCountAggregateInputType | true
    }

  export interface student_rewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_rewards'], meta: { name: 'student_rewards' } }
    /**
     * Find zero or one Student_rewards that matches the filter.
     * @param {student_rewardsFindUniqueArgs} args - Arguments to find a Student_rewards
     * @example
     * // Get one Student_rewards
     * const student_rewards = await prisma.student_rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_rewardsFindUniqueArgs>(args: SelectSubset<T, student_rewardsFindUniqueArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_rewards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {student_rewardsFindUniqueOrThrowArgs} args - Arguments to find a Student_rewards
     * @example
     * // Get one Student_rewards
     * const student_rewards = await prisma.student_rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_rewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, student_rewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_rewardsFindFirstArgs} args - Arguments to find a Student_rewards
     * @example
     * // Get one Student_rewards
     * const student_rewards = await prisma.student_rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_rewardsFindFirstArgs>(args?: SelectSubset<T, student_rewardsFindFirstArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_rewardsFindFirstOrThrowArgs} args - Arguments to find a Student_rewards
     * @example
     * // Get one Student_rewards
     * const student_rewards = await prisma.student_rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_rewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, student_rewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_rewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_rewards
     * const student_rewards = await prisma.student_rewards.findMany()
     * 
     * // Get first 10 Student_rewards
     * const student_rewards = await prisma.student_rewards.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const student_rewardsWithUser_idOnly = await prisma.student_rewards.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends student_rewardsFindManyArgs>(args?: SelectSubset<T, student_rewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_rewards.
     * @param {student_rewardsCreateArgs} args - Arguments to create a Student_rewards.
     * @example
     * // Create one Student_rewards
     * const Student_rewards = await prisma.student_rewards.create({
     *   data: {
     *     // ... data to create a Student_rewards
     *   }
     * })
     * 
     */
    create<T extends student_rewardsCreateArgs>(args: SelectSubset<T, student_rewardsCreateArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_rewards.
     * @param {student_rewardsCreateManyArgs} args - Arguments to create many Student_rewards.
     * @example
     * // Create many Student_rewards
     * const student_rewards = await prisma.student_rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_rewardsCreateManyArgs>(args?: SelectSubset<T, student_rewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_rewards.
     * @param {student_rewardsDeleteArgs} args - Arguments to delete one Student_rewards.
     * @example
     * // Delete one Student_rewards
     * const Student_rewards = await prisma.student_rewards.delete({
     *   where: {
     *     // ... filter to delete one Student_rewards
     *   }
     * })
     * 
     */
    delete<T extends student_rewardsDeleteArgs>(args: SelectSubset<T, student_rewardsDeleteArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_rewards.
     * @param {student_rewardsUpdateArgs} args - Arguments to update one Student_rewards.
     * @example
     * // Update one Student_rewards
     * const student_rewards = await prisma.student_rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_rewardsUpdateArgs>(args: SelectSubset<T, student_rewardsUpdateArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_rewards.
     * @param {student_rewardsDeleteManyArgs} args - Arguments to filter Student_rewards to delete.
     * @example
     * // Delete a few Student_rewards
     * const { count } = await prisma.student_rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_rewardsDeleteManyArgs>(args?: SelectSubset<T, student_rewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_rewards
     * const student_rewards = await prisma.student_rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_rewardsUpdateManyArgs>(args: SelectSubset<T, student_rewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_rewards.
     * @param {student_rewardsUpsertArgs} args - Arguments to update or create a Student_rewards.
     * @example
     * // Update or create a Student_rewards
     * const student_rewards = await prisma.student_rewards.upsert({
     *   create: {
     *     // ... data to create a Student_rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_rewards we want to update
     *   }
     * })
     */
    upsert<T extends student_rewardsUpsertArgs>(args: SelectSubset<T, student_rewardsUpsertArgs<ExtArgs>>): Prisma__student_rewardsClient<$Result.GetResult<Prisma.$student_rewardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_rewardsCountArgs} args - Arguments to filter Student_rewards to count.
     * @example
     * // Count the number of Student_rewards
     * const count = await prisma.student_rewards.count({
     *   where: {
     *     // ... the filter for the Student_rewards we want to count
     *   }
     * })
    **/
    count<T extends student_rewardsCountArgs>(
      args?: Subset<T, student_rewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_rewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_rewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_rewardsAggregateArgs>(args: Subset<T, Student_rewardsAggregateArgs>): Prisma.PrismaPromise<GetStudent_rewardsAggregateType<T>>

    /**
     * Group by Student_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_rewardsGroupByArgs['orderBy'] }
        : { orderBy?: student_rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_rewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_rewards model
   */
  readonly fields: student_rewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_rewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rewards<T extends rewardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rewardsDefaultArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_rewards model
   */ 
  interface student_rewardsFieldRefs {
    readonly user_id: FieldRef<"student_rewards", 'BigInt'>
    readonly reward_id: FieldRef<"student_rewards", 'BigInt'>
    readonly purchased_at: FieldRef<"student_rewards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_rewards findUnique
   */
  export type student_rewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * Filter, which student_rewards to fetch.
     */
    where: student_rewardsWhereUniqueInput
  }

  /**
   * student_rewards findUniqueOrThrow
   */
  export type student_rewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * Filter, which student_rewards to fetch.
     */
    where: student_rewardsWhereUniqueInput
  }

  /**
   * student_rewards findFirst
   */
  export type student_rewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * Filter, which student_rewards to fetch.
     */
    where?: student_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_rewards to fetch.
     */
    orderBy?: student_rewardsOrderByWithRelationInput | student_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_rewards.
     */
    cursor?: student_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_rewards.
     */
    distinct?: Student_rewardsScalarFieldEnum | Student_rewardsScalarFieldEnum[]
  }

  /**
   * student_rewards findFirstOrThrow
   */
  export type student_rewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * Filter, which student_rewards to fetch.
     */
    where?: student_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_rewards to fetch.
     */
    orderBy?: student_rewardsOrderByWithRelationInput | student_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_rewards.
     */
    cursor?: student_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_rewards.
     */
    distinct?: Student_rewardsScalarFieldEnum | Student_rewardsScalarFieldEnum[]
  }

  /**
   * student_rewards findMany
   */
  export type student_rewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * Filter, which student_rewards to fetch.
     */
    where?: student_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_rewards to fetch.
     */
    orderBy?: student_rewardsOrderByWithRelationInput | student_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_rewards.
     */
    cursor?: student_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_rewards.
     */
    skip?: number
    distinct?: Student_rewardsScalarFieldEnum | Student_rewardsScalarFieldEnum[]
  }

  /**
   * student_rewards create
   */
  export type student_rewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * The data needed to create a student_rewards.
     */
    data: XOR<student_rewardsCreateInput, student_rewardsUncheckedCreateInput>
  }

  /**
   * student_rewards createMany
   */
  export type student_rewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_rewards.
     */
    data: student_rewardsCreateManyInput | student_rewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_rewards update
   */
  export type student_rewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * The data needed to update a student_rewards.
     */
    data: XOR<student_rewardsUpdateInput, student_rewardsUncheckedUpdateInput>
    /**
     * Choose, which student_rewards to update.
     */
    where: student_rewardsWhereUniqueInput
  }

  /**
   * student_rewards updateMany
   */
  export type student_rewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_rewards.
     */
    data: XOR<student_rewardsUpdateManyMutationInput, student_rewardsUncheckedUpdateManyInput>
    /**
     * Filter which student_rewards to update
     */
    where?: student_rewardsWhereInput
  }

  /**
   * student_rewards upsert
   */
  export type student_rewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * The filter to search for the student_rewards to update in case it exists.
     */
    where: student_rewardsWhereUniqueInput
    /**
     * In case the student_rewards found by the `where` argument doesn't exist, create a new student_rewards with this data.
     */
    create: XOR<student_rewardsCreateInput, student_rewardsUncheckedCreateInput>
    /**
     * In case the student_rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_rewardsUpdateInput, student_rewardsUncheckedUpdateInput>
  }

  /**
   * student_rewards delete
   */
  export type student_rewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
    /**
     * Filter which student_rewards to delete.
     */
    where: student_rewardsWhereUniqueInput
  }

  /**
   * student_rewards deleteMany
   */
  export type student_rewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_rewards to delete
     */
    where?: student_rewardsWhereInput
  }

  /**
   * student_rewards without action
   */
  export type student_rewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_rewards
     */
    select?: student_rewardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_rewardsInclude<ExtArgs> | null
  }


  /**
   * Model subject_mastery
   */

  export type AggregateSubject_mastery = {
    _count: Subject_masteryCountAggregateOutputType | null
    _avg: Subject_masteryAvgAggregateOutputType | null
    _sum: Subject_masterySumAggregateOutputType | null
    _min: Subject_masteryMinAggregateOutputType | null
    _max: Subject_masteryMaxAggregateOutputType | null
  }

  export type Subject_masteryAvgAggregateOutputType = {
    user_id: number | null
    subject_id: number | null
    mastery_level: number | null
    total_questions_attempted: number | null
    correct_answers: number | null
  }

  export type Subject_masterySumAggregateOutputType = {
    user_id: bigint | null
    subject_id: number | null
    mastery_level: number | null
    total_questions_attempted: number | null
    correct_answers: number | null
  }

  export type Subject_masteryMinAggregateOutputType = {
    user_id: bigint | null
    subject_id: number | null
    mastery_level: number | null
    total_questions_attempted: number | null
    correct_answers: number | null
    last_test_date: Date | null
  }

  export type Subject_masteryMaxAggregateOutputType = {
    user_id: bigint | null
    subject_id: number | null
    mastery_level: number | null
    total_questions_attempted: number | null
    correct_answers: number | null
    last_test_date: Date | null
  }

  export type Subject_masteryCountAggregateOutputType = {
    user_id: number
    subject_id: number
    mastery_level: number
    total_questions_attempted: number
    correct_answers: number
    last_test_date: number
    _all: number
  }


  export type Subject_masteryAvgAggregateInputType = {
    user_id?: true
    subject_id?: true
    mastery_level?: true
    total_questions_attempted?: true
    correct_answers?: true
  }

  export type Subject_masterySumAggregateInputType = {
    user_id?: true
    subject_id?: true
    mastery_level?: true
    total_questions_attempted?: true
    correct_answers?: true
  }

  export type Subject_masteryMinAggregateInputType = {
    user_id?: true
    subject_id?: true
    mastery_level?: true
    total_questions_attempted?: true
    correct_answers?: true
    last_test_date?: true
  }

  export type Subject_masteryMaxAggregateInputType = {
    user_id?: true
    subject_id?: true
    mastery_level?: true
    total_questions_attempted?: true
    correct_answers?: true
    last_test_date?: true
  }

  export type Subject_masteryCountAggregateInputType = {
    user_id?: true
    subject_id?: true
    mastery_level?: true
    total_questions_attempted?: true
    correct_answers?: true
    last_test_date?: true
    _all?: true
  }

  export type Subject_masteryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject_mastery to aggregate.
     */
    where?: subject_masteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_masteries to fetch.
     */
    orderBy?: subject_masteryOrderByWithRelationInput | subject_masteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subject_masteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_masteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_masteries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subject_masteries
    **/
    _count?: true | Subject_masteryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subject_masteryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subject_masterySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subject_masteryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subject_masteryMaxAggregateInputType
  }

  export type GetSubject_masteryAggregateType<T extends Subject_masteryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject_mastery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject_mastery[P]>
      : GetScalarType<T[P], AggregateSubject_mastery[P]>
  }




  export type subject_masteryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_masteryWhereInput
    orderBy?: subject_masteryOrderByWithAggregationInput | subject_masteryOrderByWithAggregationInput[]
    by: Subject_masteryScalarFieldEnum[] | Subject_masteryScalarFieldEnum
    having?: subject_masteryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subject_masteryCountAggregateInputType | true
    _avg?: Subject_masteryAvgAggregateInputType
    _sum?: Subject_masterySumAggregateInputType
    _min?: Subject_masteryMinAggregateInputType
    _max?: Subject_masteryMaxAggregateInputType
  }

  export type Subject_masteryGroupByOutputType = {
    user_id: bigint
    subject_id: number
    mastery_level: number
    total_questions_attempted: number
    correct_answers: number
    last_test_date: Date | null
    _count: Subject_masteryCountAggregateOutputType | null
    _avg: Subject_masteryAvgAggregateOutputType | null
    _sum: Subject_masterySumAggregateOutputType | null
    _min: Subject_masteryMinAggregateOutputType | null
    _max: Subject_masteryMaxAggregateOutputType | null
  }

  type GetSubject_masteryGroupByPayload<T extends subject_masteryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Subject_masteryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subject_masteryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subject_masteryGroupByOutputType[P]>
            : GetScalarType<T[P], Subject_masteryGroupByOutputType[P]>
        }
      >
    >


  export type subject_masterySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    subject_id?: boolean
    mastery_level?: boolean
    total_questions_attempted?: boolean
    correct_answers?: boolean
    last_test_date?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject_mastery"]>


  export type subject_masterySelectScalar = {
    user_id?: boolean
    subject_id?: boolean
    mastery_level?: boolean
    total_questions_attempted?: boolean
    correct_answers?: boolean
    last_test_date?: boolean
  }

  export type subject_masteryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }

  export type $subject_masteryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subject_mastery"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      subject_id: number
      mastery_level: number
      total_questions_attempted: number
      correct_answers: number
      last_test_date: Date | null
    }, ExtArgs["result"]["subject_mastery"]>
    composites: {}
  }

  type subject_masteryGetPayload<S extends boolean | null | undefined | subject_masteryDefaultArgs> = $Result.GetResult<Prisma.$subject_masteryPayload, S>

  type subject_masteryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<subject_masteryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Subject_masteryCountAggregateInputType | true
    }

  export interface subject_masteryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subject_mastery'], meta: { name: 'subject_mastery' } }
    /**
     * Find zero or one Subject_mastery that matches the filter.
     * @param {subject_masteryFindUniqueArgs} args - Arguments to find a Subject_mastery
     * @example
     * // Get one Subject_mastery
     * const subject_mastery = await prisma.subject_mastery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subject_masteryFindUniqueArgs>(args: SelectSubset<T, subject_masteryFindUniqueArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subject_mastery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {subject_masteryFindUniqueOrThrowArgs} args - Arguments to find a Subject_mastery
     * @example
     * // Get one Subject_mastery
     * const subject_mastery = await prisma.subject_mastery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subject_masteryFindUniqueOrThrowArgs>(args: SelectSubset<T, subject_masteryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subject_mastery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_masteryFindFirstArgs} args - Arguments to find a Subject_mastery
     * @example
     * // Get one Subject_mastery
     * const subject_mastery = await prisma.subject_mastery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subject_masteryFindFirstArgs>(args?: SelectSubset<T, subject_masteryFindFirstArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subject_mastery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_masteryFindFirstOrThrowArgs} args - Arguments to find a Subject_mastery
     * @example
     * // Get one Subject_mastery
     * const subject_mastery = await prisma.subject_mastery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subject_masteryFindFirstOrThrowArgs>(args?: SelectSubset<T, subject_masteryFindFirstOrThrowArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subject_masteries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_masteryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subject_masteries
     * const subject_masteries = await prisma.subject_mastery.findMany()
     * 
     * // Get first 10 Subject_masteries
     * const subject_masteries = await prisma.subject_mastery.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const subject_masteryWithUser_idOnly = await prisma.subject_mastery.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends subject_masteryFindManyArgs>(args?: SelectSubset<T, subject_masteryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subject_mastery.
     * @param {subject_masteryCreateArgs} args - Arguments to create a Subject_mastery.
     * @example
     * // Create one Subject_mastery
     * const Subject_mastery = await prisma.subject_mastery.create({
     *   data: {
     *     // ... data to create a Subject_mastery
     *   }
     * })
     * 
     */
    create<T extends subject_masteryCreateArgs>(args: SelectSubset<T, subject_masteryCreateArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subject_masteries.
     * @param {subject_masteryCreateManyArgs} args - Arguments to create many Subject_masteries.
     * @example
     * // Create many Subject_masteries
     * const subject_mastery = await prisma.subject_mastery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subject_masteryCreateManyArgs>(args?: SelectSubset<T, subject_masteryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject_mastery.
     * @param {subject_masteryDeleteArgs} args - Arguments to delete one Subject_mastery.
     * @example
     * // Delete one Subject_mastery
     * const Subject_mastery = await prisma.subject_mastery.delete({
     *   where: {
     *     // ... filter to delete one Subject_mastery
     *   }
     * })
     * 
     */
    delete<T extends subject_masteryDeleteArgs>(args: SelectSubset<T, subject_masteryDeleteArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subject_mastery.
     * @param {subject_masteryUpdateArgs} args - Arguments to update one Subject_mastery.
     * @example
     * // Update one Subject_mastery
     * const subject_mastery = await prisma.subject_mastery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subject_masteryUpdateArgs>(args: SelectSubset<T, subject_masteryUpdateArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subject_masteries.
     * @param {subject_masteryDeleteManyArgs} args - Arguments to filter Subject_masteries to delete.
     * @example
     * // Delete a few Subject_masteries
     * const { count } = await prisma.subject_mastery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subject_masteryDeleteManyArgs>(args?: SelectSubset<T, subject_masteryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subject_masteries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_masteryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subject_masteries
     * const subject_mastery = await prisma.subject_mastery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subject_masteryUpdateManyArgs>(args: SelectSubset<T, subject_masteryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject_mastery.
     * @param {subject_masteryUpsertArgs} args - Arguments to update or create a Subject_mastery.
     * @example
     * // Update or create a Subject_mastery
     * const subject_mastery = await prisma.subject_mastery.upsert({
     *   create: {
     *     // ... data to create a Subject_mastery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject_mastery we want to update
     *   }
     * })
     */
    upsert<T extends subject_masteryUpsertArgs>(args: SelectSubset<T, subject_masteryUpsertArgs<ExtArgs>>): Prisma__subject_masteryClient<$Result.GetResult<Prisma.$subject_masteryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subject_masteries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_masteryCountArgs} args - Arguments to filter Subject_masteries to count.
     * @example
     * // Count the number of Subject_masteries
     * const count = await prisma.subject_mastery.count({
     *   where: {
     *     // ... the filter for the Subject_masteries we want to count
     *   }
     * })
    **/
    count<T extends subject_masteryCountArgs>(
      args?: Subset<T, subject_masteryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subject_masteryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject_mastery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_masteryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subject_masteryAggregateArgs>(args: Subset<T, Subject_masteryAggregateArgs>): Prisma.PrismaPromise<GetSubject_masteryAggregateType<T>>

    /**
     * Group by Subject_mastery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_masteryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subject_masteryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subject_masteryGroupByArgs['orderBy'] }
        : { orderBy?: subject_masteryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subject_masteryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubject_masteryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subject_mastery model
   */
  readonly fields: subject_masteryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject_mastery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subject_masteryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subject_mastery model
   */ 
  interface subject_masteryFieldRefs {
    readonly user_id: FieldRef<"subject_mastery", 'BigInt'>
    readonly subject_id: FieldRef<"subject_mastery", 'Int'>
    readonly mastery_level: FieldRef<"subject_mastery", 'Int'>
    readonly total_questions_attempted: FieldRef<"subject_mastery", 'Int'>
    readonly correct_answers: FieldRef<"subject_mastery", 'Int'>
    readonly last_test_date: FieldRef<"subject_mastery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subject_mastery findUnique
   */
  export type subject_masteryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * Filter, which subject_mastery to fetch.
     */
    where: subject_masteryWhereUniqueInput
  }

  /**
   * subject_mastery findUniqueOrThrow
   */
  export type subject_masteryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * Filter, which subject_mastery to fetch.
     */
    where: subject_masteryWhereUniqueInput
  }

  /**
   * subject_mastery findFirst
   */
  export type subject_masteryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * Filter, which subject_mastery to fetch.
     */
    where?: subject_masteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_masteries to fetch.
     */
    orderBy?: subject_masteryOrderByWithRelationInput | subject_masteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_masteries.
     */
    cursor?: subject_masteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_masteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_masteries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_masteries.
     */
    distinct?: Subject_masteryScalarFieldEnum | Subject_masteryScalarFieldEnum[]
  }

  /**
   * subject_mastery findFirstOrThrow
   */
  export type subject_masteryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * Filter, which subject_mastery to fetch.
     */
    where?: subject_masteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_masteries to fetch.
     */
    orderBy?: subject_masteryOrderByWithRelationInput | subject_masteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_masteries.
     */
    cursor?: subject_masteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_masteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_masteries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_masteries.
     */
    distinct?: Subject_masteryScalarFieldEnum | Subject_masteryScalarFieldEnum[]
  }

  /**
   * subject_mastery findMany
   */
  export type subject_masteryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * Filter, which subject_masteries to fetch.
     */
    where?: subject_masteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_masteries to fetch.
     */
    orderBy?: subject_masteryOrderByWithRelationInput | subject_masteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subject_masteries.
     */
    cursor?: subject_masteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_masteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_masteries.
     */
    skip?: number
    distinct?: Subject_masteryScalarFieldEnum | Subject_masteryScalarFieldEnum[]
  }

  /**
   * subject_mastery create
   */
  export type subject_masteryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * The data needed to create a subject_mastery.
     */
    data: XOR<subject_masteryCreateInput, subject_masteryUncheckedCreateInput>
  }

  /**
   * subject_mastery createMany
   */
  export type subject_masteryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subject_masteries.
     */
    data: subject_masteryCreateManyInput | subject_masteryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subject_mastery update
   */
  export type subject_masteryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * The data needed to update a subject_mastery.
     */
    data: XOR<subject_masteryUpdateInput, subject_masteryUncheckedUpdateInput>
    /**
     * Choose, which subject_mastery to update.
     */
    where: subject_masteryWhereUniqueInput
  }

  /**
   * subject_mastery updateMany
   */
  export type subject_masteryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subject_masteries.
     */
    data: XOR<subject_masteryUpdateManyMutationInput, subject_masteryUncheckedUpdateManyInput>
    /**
     * Filter which subject_masteries to update
     */
    where?: subject_masteryWhereInput
  }

  /**
   * subject_mastery upsert
   */
  export type subject_masteryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * The filter to search for the subject_mastery to update in case it exists.
     */
    where: subject_masteryWhereUniqueInput
    /**
     * In case the subject_mastery found by the `where` argument doesn't exist, create a new subject_mastery with this data.
     */
    create: XOR<subject_masteryCreateInput, subject_masteryUncheckedCreateInput>
    /**
     * In case the subject_mastery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subject_masteryUpdateInput, subject_masteryUncheckedUpdateInput>
  }

  /**
   * subject_mastery delete
   */
  export type subject_masteryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
    /**
     * Filter which subject_mastery to delete.
     */
    where: subject_masteryWhereUniqueInput
  }

  /**
   * subject_mastery deleteMany
   */
  export type subject_masteryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject_masteries to delete
     */
    where?: subject_masteryWhereInput
  }

  /**
   * subject_mastery without action
   */
  export type subject_masteryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_mastery
     */
    select?: subject_masterySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_masteryInclude<ExtArgs> | null
  }


  /**
   * Model activity_log
   */

  export type AggregateActivity_log = {
    _count: Activity_logCountAggregateOutputType | null
    _avg: Activity_logAvgAggregateOutputType | null
    _sum: Activity_logSumAggregateOutputType | null
    _min: Activity_logMinAggregateOutputType | null
    _max: Activity_logMaxAggregateOutputType | null
  }

  export type Activity_logAvgAggregateOutputType = {
    activity_id: number | null
    user_id: number | null
    xp_earned: number | null
  }

  export type Activity_logSumAggregateOutputType = {
    activity_id: bigint | null
    user_id: bigint | null
    xp_earned: number | null
  }

  export type Activity_logMinAggregateOutputType = {
    activity_id: bigint | null
    user_id: bigint | null
    activity_type: string | null
    xp_earned: number | null
    details: string | null
    created_at: Date | null
  }

  export type Activity_logMaxAggregateOutputType = {
    activity_id: bigint | null
    user_id: bigint | null
    activity_type: string | null
    xp_earned: number | null
    details: string | null
    created_at: Date | null
  }

  export type Activity_logCountAggregateOutputType = {
    activity_id: number
    user_id: number
    activity_type: number
    xp_earned: number
    details: number
    created_at: number
    _all: number
  }


  export type Activity_logAvgAggregateInputType = {
    activity_id?: true
    user_id?: true
    xp_earned?: true
  }

  export type Activity_logSumAggregateInputType = {
    activity_id?: true
    user_id?: true
    xp_earned?: true
  }

  export type Activity_logMinAggregateInputType = {
    activity_id?: true
    user_id?: true
    activity_type?: true
    xp_earned?: true
    details?: true
    created_at?: true
  }

  export type Activity_logMaxAggregateInputType = {
    activity_id?: true
    user_id?: true
    activity_type?: true
    xp_earned?: true
    details?: true
    created_at?: true
  }

  export type Activity_logCountAggregateInputType = {
    activity_id?: true
    user_id?: true
    activity_type?: true
    xp_earned?: true
    details?: true
    created_at?: true
    _all?: true
  }

  export type Activity_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activity_log to aggregate.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logOrderByWithRelationInput | activity_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activity_logs
    **/
    _count?: true | Activity_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Activity_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Activity_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Activity_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Activity_logMaxAggregateInputType
  }

  export type GetActivity_logAggregateType<T extends Activity_logAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity_log[P]>
      : GetScalarType<T[P], AggregateActivity_log[P]>
  }




  export type activity_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activity_logWhereInput
    orderBy?: activity_logOrderByWithAggregationInput | activity_logOrderByWithAggregationInput[]
    by: Activity_logScalarFieldEnum[] | Activity_logScalarFieldEnum
    having?: activity_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Activity_logCountAggregateInputType | true
    _avg?: Activity_logAvgAggregateInputType
    _sum?: Activity_logSumAggregateInputType
    _min?: Activity_logMinAggregateInputType
    _max?: Activity_logMaxAggregateInputType
  }

  export type Activity_logGroupByOutputType = {
    activity_id: bigint
    user_id: bigint
    activity_type: string
    xp_earned: number
    details: string | null
    created_at: Date | null
    _count: Activity_logCountAggregateOutputType | null
    _avg: Activity_logAvgAggregateOutputType | null
    _sum: Activity_logSumAggregateOutputType | null
    _min: Activity_logMinAggregateOutputType | null
    _max: Activity_logMaxAggregateOutputType | null
  }

  type GetActivity_logGroupByPayload<T extends activity_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Activity_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Activity_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Activity_logGroupByOutputType[P]>
            : GetScalarType<T[P], Activity_logGroupByOutputType[P]>
        }
      >
    >


  export type activity_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activity_id?: boolean
    user_id?: boolean
    activity_type?: boolean
    xp_earned?: boolean
    details?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity_log"]>


  export type activity_logSelectScalar = {
    activity_id?: boolean
    user_id?: boolean
    activity_type?: boolean
    xp_earned?: boolean
    details?: boolean
    created_at?: boolean
  }

  export type activity_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $activity_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activity_log"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      activity_id: bigint
      user_id: bigint
      activity_type: string
      xp_earned: number
      details: string | null
      created_at: Date | null
    }, ExtArgs["result"]["activity_log"]>
    composites: {}
  }

  type activity_logGetPayload<S extends boolean | null | undefined | activity_logDefaultArgs> = $Result.GetResult<Prisma.$activity_logPayload, S>

  type activity_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<activity_logFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Activity_logCountAggregateInputType | true
    }

  export interface activity_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activity_log'], meta: { name: 'activity_log' } }
    /**
     * Find zero or one Activity_log that matches the filter.
     * @param {activity_logFindUniqueArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activity_logFindUniqueArgs>(args: SelectSubset<T, activity_logFindUniqueArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity_log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {activity_logFindUniqueOrThrowArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activity_logFindUniqueOrThrowArgs>(args: SelectSubset<T, activity_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logFindFirstArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activity_logFindFirstArgs>(args?: SelectSubset<T, activity_logFindFirstArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logFindFirstOrThrowArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activity_logFindFirstOrThrowArgs>(args?: SelectSubset<T, activity_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activity_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activity_logs
     * const activity_logs = await prisma.activity_log.findMany()
     * 
     * // Get first 10 Activity_logs
     * const activity_logs = await prisma.activity_log.findMany({ take: 10 })
     * 
     * // Only select the `activity_id`
     * const activity_logWithActivity_idOnly = await prisma.activity_log.findMany({ select: { activity_id: true } })
     * 
     */
    findMany<T extends activity_logFindManyArgs>(args?: SelectSubset<T, activity_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity_log.
     * @param {activity_logCreateArgs} args - Arguments to create a Activity_log.
     * @example
     * // Create one Activity_log
     * const Activity_log = await prisma.activity_log.create({
     *   data: {
     *     // ... data to create a Activity_log
     *   }
     * })
     * 
     */
    create<T extends activity_logCreateArgs>(args: SelectSubset<T, activity_logCreateArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activity_logs.
     * @param {activity_logCreateManyArgs} args - Arguments to create many Activity_logs.
     * @example
     * // Create many Activity_logs
     * const activity_log = await prisma.activity_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activity_logCreateManyArgs>(args?: SelectSubset<T, activity_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activity_log.
     * @param {activity_logDeleteArgs} args - Arguments to delete one Activity_log.
     * @example
     * // Delete one Activity_log
     * const Activity_log = await prisma.activity_log.delete({
     *   where: {
     *     // ... filter to delete one Activity_log
     *   }
     * })
     * 
     */
    delete<T extends activity_logDeleteArgs>(args: SelectSubset<T, activity_logDeleteArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity_log.
     * @param {activity_logUpdateArgs} args - Arguments to update one Activity_log.
     * @example
     * // Update one Activity_log
     * const activity_log = await prisma.activity_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activity_logUpdateArgs>(args: SelectSubset<T, activity_logUpdateArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activity_logs.
     * @param {activity_logDeleteManyArgs} args - Arguments to filter Activity_logs to delete.
     * @example
     * // Delete a few Activity_logs
     * const { count } = await prisma.activity_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activity_logDeleteManyArgs>(args?: SelectSubset<T, activity_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activity_logs
     * const activity_log = await prisma.activity_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activity_logUpdateManyArgs>(args: SelectSubset<T, activity_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity_log.
     * @param {activity_logUpsertArgs} args - Arguments to update or create a Activity_log.
     * @example
     * // Update or create a Activity_log
     * const activity_log = await prisma.activity_log.upsert({
     *   create: {
     *     // ... data to create a Activity_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity_log we want to update
     *   }
     * })
     */
    upsert<T extends activity_logUpsertArgs>(args: SelectSubset<T, activity_logUpsertArgs<ExtArgs>>): Prisma__activity_logClient<$Result.GetResult<Prisma.$activity_logPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logCountArgs} args - Arguments to filter Activity_logs to count.
     * @example
     * // Count the number of Activity_logs
     * const count = await prisma.activity_log.count({
     *   where: {
     *     // ... the filter for the Activity_logs we want to count
     *   }
     * })
    **/
    count<T extends activity_logCountArgs>(
      args?: Subset<T, activity_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Activity_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Activity_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Activity_logAggregateArgs>(args: Subset<T, Activity_logAggregateArgs>): Prisma.PrismaPromise<GetActivity_logAggregateType<T>>

    /**
     * Group by Activity_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activity_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activity_logGroupByArgs['orderBy'] }
        : { orderBy?: activity_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activity_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivity_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activity_log model
   */
  readonly fields: activity_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activity_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activity_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activity_log model
   */ 
  interface activity_logFieldRefs {
    readonly activity_id: FieldRef<"activity_log", 'BigInt'>
    readonly user_id: FieldRef<"activity_log", 'BigInt'>
    readonly activity_type: FieldRef<"activity_log", 'String'>
    readonly xp_earned: FieldRef<"activity_log", 'Int'>
    readonly details: FieldRef<"activity_log", 'String'>
    readonly created_at: FieldRef<"activity_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activity_log findUnique
   */
  export type activity_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * Filter, which activity_log to fetch.
     */
    where: activity_logWhereUniqueInput
  }

  /**
   * activity_log findUniqueOrThrow
   */
  export type activity_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * Filter, which activity_log to fetch.
     */
    where: activity_logWhereUniqueInput
  }

  /**
   * activity_log findFirst
   */
  export type activity_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * Filter, which activity_log to fetch.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logOrderByWithRelationInput | activity_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activity_logs.
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activity_logs.
     */
    distinct?: Activity_logScalarFieldEnum | Activity_logScalarFieldEnum[]
  }

  /**
   * activity_log findFirstOrThrow
   */
  export type activity_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * Filter, which activity_log to fetch.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logOrderByWithRelationInput | activity_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activity_logs.
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activity_logs.
     */
    distinct?: Activity_logScalarFieldEnum | Activity_logScalarFieldEnum[]
  }

  /**
   * activity_log findMany
   */
  export type activity_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logOrderByWithRelationInput | activity_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activity_logs.
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    distinct?: Activity_logScalarFieldEnum | Activity_logScalarFieldEnum[]
  }

  /**
   * activity_log create
   */
  export type activity_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * The data needed to create a activity_log.
     */
    data: XOR<activity_logCreateInput, activity_logUncheckedCreateInput>
  }

  /**
   * activity_log createMany
   */
  export type activity_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activity_logs.
     */
    data: activity_logCreateManyInput | activity_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activity_log update
   */
  export type activity_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * The data needed to update a activity_log.
     */
    data: XOR<activity_logUpdateInput, activity_logUncheckedUpdateInput>
    /**
     * Choose, which activity_log to update.
     */
    where: activity_logWhereUniqueInput
  }

  /**
   * activity_log updateMany
   */
  export type activity_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activity_logs.
     */
    data: XOR<activity_logUpdateManyMutationInput, activity_logUncheckedUpdateManyInput>
    /**
     * Filter which activity_logs to update
     */
    where?: activity_logWhereInput
  }

  /**
   * activity_log upsert
   */
  export type activity_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * The filter to search for the activity_log to update in case it exists.
     */
    where: activity_logWhereUniqueInput
    /**
     * In case the activity_log found by the `where` argument doesn't exist, create a new activity_log with this data.
     */
    create: XOR<activity_logCreateInput, activity_logUncheckedCreateInput>
    /**
     * In case the activity_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activity_logUpdateInput, activity_logUncheckedUpdateInput>
  }

  /**
   * activity_log delete
   */
  export type activity_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
    /**
     * Filter which activity_log to delete.
     */
    where: activity_logWhereUniqueInput
  }

  /**
   * activity_log deleteMany
   */
  export type activity_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activity_logs to delete
     */
    where?: activity_logWhereInput
  }

  /**
   * activity_log without action
   */
  export type activity_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logInclude<ExtArgs> | null
  }


  /**
   * Model level_config
   */

  export type AggregateLevel_config = {
    _count: Level_configCountAggregateOutputType | null
    _avg: Level_configAvgAggregateOutputType | null
    _sum: Level_configSumAggregateOutputType | null
    _min: Level_configMinAggregateOutputType | null
    _max: Level_configMaxAggregateOutputType | null
  }

  export type Level_configAvgAggregateOutputType = {
    level: number | null
    xp_required: number | null
  }

  export type Level_configSumAggregateOutputType = {
    level: number | null
    xp_required: number | null
  }

  export type Level_configMinAggregateOutputType = {
    level: number | null
    xp_required: number | null
    created_at: Date | null
  }

  export type Level_configMaxAggregateOutputType = {
    level: number | null
    xp_required: number | null
    created_at: Date | null
  }

  export type Level_configCountAggregateOutputType = {
    level: number
    xp_required: number
    created_at: number
    _all: number
  }


  export type Level_configAvgAggregateInputType = {
    level?: true
    xp_required?: true
  }

  export type Level_configSumAggregateInputType = {
    level?: true
    xp_required?: true
  }

  export type Level_configMinAggregateInputType = {
    level?: true
    xp_required?: true
    created_at?: true
  }

  export type Level_configMaxAggregateInputType = {
    level?: true
    xp_required?: true
    created_at?: true
  }

  export type Level_configCountAggregateInputType = {
    level?: true
    xp_required?: true
    created_at?: true
    _all?: true
  }

  export type Level_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which level_config to aggregate.
     */
    where?: level_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_configs to fetch.
     */
    orderBy?: level_configOrderByWithRelationInput | level_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: level_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned level_configs
    **/
    _count?: true | Level_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Level_configAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Level_configSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Level_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Level_configMaxAggregateInputType
  }

  export type GetLevel_configAggregateType<T extends Level_configAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel_config[P]>
      : GetScalarType<T[P], AggregateLevel_config[P]>
  }




  export type level_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: level_configWhereInput
    orderBy?: level_configOrderByWithAggregationInput | level_configOrderByWithAggregationInput[]
    by: Level_configScalarFieldEnum[] | Level_configScalarFieldEnum
    having?: level_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Level_configCountAggregateInputType | true
    _avg?: Level_configAvgAggregateInputType
    _sum?: Level_configSumAggregateInputType
    _min?: Level_configMinAggregateInputType
    _max?: Level_configMaxAggregateInputType
  }

  export type Level_configGroupByOutputType = {
    level: number
    xp_required: number
    created_at: Date
    _count: Level_configCountAggregateOutputType | null
    _avg: Level_configAvgAggregateOutputType | null
    _sum: Level_configSumAggregateOutputType | null
    _min: Level_configMinAggregateOutputType | null
    _max: Level_configMaxAggregateOutputType | null
  }

  type GetLevel_configGroupByPayload<T extends level_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Level_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Level_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Level_configGroupByOutputType[P]>
            : GetScalarType<T[P], Level_configGroupByOutputType[P]>
        }
      >
    >


  export type level_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    level?: boolean
    xp_required?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["level_config"]>


  export type level_configSelectScalar = {
    level?: boolean
    xp_required?: boolean
    created_at?: boolean
  }


  export type $level_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "level_config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      level: number
      xp_required: number
      created_at: Date
    }, ExtArgs["result"]["level_config"]>
    composites: {}
  }

  type level_configGetPayload<S extends boolean | null | undefined | level_configDefaultArgs> = $Result.GetResult<Prisma.$level_configPayload, S>

  type level_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<level_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Level_configCountAggregateInputType | true
    }

  export interface level_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['level_config'], meta: { name: 'level_config' } }
    /**
     * Find zero or one Level_config that matches the filter.
     * @param {level_configFindUniqueArgs} args - Arguments to find a Level_config
     * @example
     * // Get one Level_config
     * const level_config = await prisma.level_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends level_configFindUniqueArgs>(args: SelectSubset<T, level_configFindUniqueArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Level_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {level_configFindUniqueOrThrowArgs} args - Arguments to find a Level_config
     * @example
     * // Get one Level_config
     * const level_config = await prisma.level_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends level_configFindUniqueOrThrowArgs>(args: SelectSubset<T, level_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Level_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_configFindFirstArgs} args - Arguments to find a Level_config
     * @example
     * // Get one Level_config
     * const level_config = await prisma.level_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends level_configFindFirstArgs>(args?: SelectSubset<T, level_configFindFirstArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Level_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_configFindFirstOrThrowArgs} args - Arguments to find a Level_config
     * @example
     * // Get one Level_config
     * const level_config = await prisma.level_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends level_configFindFirstOrThrowArgs>(args?: SelectSubset<T, level_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Level_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Level_configs
     * const level_configs = await prisma.level_config.findMany()
     * 
     * // Get first 10 Level_configs
     * const level_configs = await prisma.level_config.findMany({ take: 10 })
     * 
     * // Only select the `level`
     * const level_configWithLevelOnly = await prisma.level_config.findMany({ select: { level: true } })
     * 
     */
    findMany<T extends level_configFindManyArgs>(args?: SelectSubset<T, level_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Level_config.
     * @param {level_configCreateArgs} args - Arguments to create a Level_config.
     * @example
     * // Create one Level_config
     * const Level_config = await prisma.level_config.create({
     *   data: {
     *     // ... data to create a Level_config
     *   }
     * })
     * 
     */
    create<T extends level_configCreateArgs>(args: SelectSubset<T, level_configCreateArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Level_configs.
     * @param {level_configCreateManyArgs} args - Arguments to create many Level_configs.
     * @example
     * // Create many Level_configs
     * const level_config = await prisma.level_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends level_configCreateManyArgs>(args?: SelectSubset<T, level_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Level_config.
     * @param {level_configDeleteArgs} args - Arguments to delete one Level_config.
     * @example
     * // Delete one Level_config
     * const Level_config = await prisma.level_config.delete({
     *   where: {
     *     // ... filter to delete one Level_config
     *   }
     * })
     * 
     */
    delete<T extends level_configDeleteArgs>(args: SelectSubset<T, level_configDeleteArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Level_config.
     * @param {level_configUpdateArgs} args - Arguments to update one Level_config.
     * @example
     * // Update one Level_config
     * const level_config = await prisma.level_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends level_configUpdateArgs>(args: SelectSubset<T, level_configUpdateArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Level_configs.
     * @param {level_configDeleteManyArgs} args - Arguments to filter Level_configs to delete.
     * @example
     * // Delete a few Level_configs
     * const { count } = await prisma.level_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends level_configDeleteManyArgs>(args?: SelectSubset<T, level_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Level_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Level_configs
     * const level_config = await prisma.level_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends level_configUpdateManyArgs>(args: SelectSubset<T, level_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Level_config.
     * @param {level_configUpsertArgs} args - Arguments to update or create a Level_config.
     * @example
     * // Update or create a Level_config
     * const level_config = await prisma.level_config.upsert({
     *   create: {
     *     // ... data to create a Level_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level_config we want to update
     *   }
     * })
     */
    upsert<T extends level_configUpsertArgs>(args: SelectSubset<T, level_configUpsertArgs<ExtArgs>>): Prisma__level_configClient<$Result.GetResult<Prisma.$level_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Level_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_configCountArgs} args - Arguments to filter Level_configs to count.
     * @example
     * // Count the number of Level_configs
     * const count = await prisma.level_config.count({
     *   where: {
     *     // ... the filter for the Level_configs we want to count
     *   }
     * })
    **/
    count<T extends level_configCountArgs>(
      args?: Subset<T, level_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Level_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Level_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Level_configAggregateArgs>(args: Subset<T, Level_configAggregateArgs>): Prisma.PrismaPromise<GetLevel_configAggregateType<T>>

    /**
     * Group by Level_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends level_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: level_configGroupByArgs['orderBy'] }
        : { orderBy?: level_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, level_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevel_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the level_config model
   */
  readonly fields: level_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for level_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__level_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the level_config model
   */ 
  interface level_configFieldRefs {
    readonly level: FieldRef<"level_config", 'Int'>
    readonly xp_required: FieldRef<"level_config", 'Int'>
    readonly created_at: FieldRef<"level_config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * level_config findUnique
   */
  export type level_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * Filter, which level_config to fetch.
     */
    where: level_configWhereUniqueInput
  }

  /**
   * level_config findUniqueOrThrow
   */
  export type level_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * Filter, which level_config to fetch.
     */
    where: level_configWhereUniqueInput
  }

  /**
   * level_config findFirst
   */
  export type level_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * Filter, which level_config to fetch.
     */
    where?: level_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_configs to fetch.
     */
    orderBy?: level_configOrderByWithRelationInput | level_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for level_configs.
     */
    cursor?: level_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of level_configs.
     */
    distinct?: Level_configScalarFieldEnum | Level_configScalarFieldEnum[]
  }

  /**
   * level_config findFirstOrThrow
   */
  export type level_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * Filter, which level_config to fetch.
     */
    where?: level_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_configs to fetch.
     */
    orderBy?: level_configOrderByWithRelationInput | level_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for level_configs.
     */
    cursor?: level_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of level_configs.
     */
    distinct?: Level_configScalarFieldEnum | Level_configScalarFieldEnum[]
  }

  /**
   * level_config findMany
   */
  export type level_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * Filter, which level_configs to fetch.
     */
    where?: level_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_configs to fetch.
     */
    orderBy?: level_configOrderByWithRelationInput | level_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing level_configs.
     */
    cursor?: level_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_configs.
     */
    skip?: number
    distinct?: Level_configScalarFieldEnum | Level_configScalarFieldEnum[]
  }

  /**
   * level_config create
   */
  export type level_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * The data needed to create a level_config.
     */
    data: XOR<level_configCreateInput, level_configUncheckedCreateInput>
  }

  /**
   * level_config createMany
   */
  export type level_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many level_configs.
     */
    data: level_configCreateManyInput | level_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * level_config update
   */
  export type level_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * The data needed to update a level_config.
     */
    data: XOR<level_configUpdateInput, level_configUncheckedUpdateInput>
    /**
     * Choose, which level_config to update.
     */
    where: level_configWhereUniqueInput
  }

  /**
   * level_config updateMany
   */
  export type level_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update level_configs.
     */
    data: XOR<level_configUpdateManyMutationInput, level_configUncheckedUpdateManyInput>
    /**
     * Filter which level_configs to update
     */
    where?: level_configWhereInput
  }

  /**
   * level_config upsert
   */
  export type level_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * The filter to search for the level_config to update in case it exists.
     */
    where: level_configWhereUniqueInput
    /**
     * In case the level_config found by the `where` argument doesn't exist, create a new level_config with this data.
     */
    create: XOR<level_configCreateInput, level_configUncheckedCreateInput>
    /**
     * In case the level_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<level_configUpdateInput, level_configUncheckedUpdateInput>
  }

  /**
   * level_config delete
   */
  export type level_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
    /**
     * Filter which level_config to delete.
     */
    where: level_configWhereUniqueInput
  }

  /**
   * level_config deleteMany
   */
  export type level_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which level_configs to delete
     */
    where?: level_configWhereInput
  }

  /**
   * level_config without action
   */
  export type level_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level_config
     */
    select?: level_configSelect<ExtArgs> | null
  }


  /**
   * Model study_groups
   */

  export type AggregateStudy_groups = {
    _count: Study_groupsCountAggregateOutputType | null
    _avg: Study_groupsAvgAggregateOutputType | null
    _sum: Study_groupsSumAggregateOutputType | null
    _min: Study_groupsMinAggregateOutputType | null
    _max: Study_groupsMaxAggregateOutputType | null
  }

  export type Study_groupsAvgAggregateOutputType = {
    group_id: number | null
    tutor_id: number | null
  }

  export type Study_groupsSumAggregateOutputType = {
    group_id: bigint | null
    tutor_id: bigint | null
  }

  export type Study_groupsMinAggregateOutputType = {
    group_id: bigint | null
    group_name: string | null
    description: string | null
    tutor_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Study_groupsMaxAggregateOutputType = {
    group_id: bigint | null
    group_name: string | null
    description: string | null
    tutor_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Study_groupsCountAggregateOutputType = {
    group_id: number
    group_name: number
    description: number
    tutor_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Study_groupsAvgAggregateInputType = {
    group_id?: true
    tutor_id?: true
  }

  export type Study_groupsSumAggregateInputType = {
    group_id?: true
    tutor_id?: true
  }

  export type Study_groupsMinAggregateInputType = {
    group_id?: true
    group_name?: true
    description?: true
    tutor_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Study_groupsMaxAggregateInputType = {
    group_id?: true
    group_name?: true
    description?: true
    tutor_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Study_groupsCountAggregateInputType = {
    group_id?: true
    group_name?: true
    description?: true
    tutor_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Study_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_groups to aggregate.
     */
    where?: study_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_groups to fetch.
     */
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_groups
    **/
    _count?: true | Study_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Study_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Study_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_groupsMaxAggregateInputType
  }

  export type GetStudy_groupsAggregateType<T extends Study_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_groups[P]>
      : GetScalarType<T[P], AggregateStudy_groups[P]>
  }




  export type study_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_groupsWhereInput
    orderBy?: study_groupsOrderByWithAggregationInput | study_groupsOrderByWithAggregationInput[]
    by: Study_groupsScalarFieldEnum[] | Study_groupsScalarFieldEnum
    having?: study_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_groupsCountAggregateInputType | true
    _avg?: Study_groupsAvgAggregateInputType
    _sum?: Study_groupsSumAggregateInputType
    _min?: Study_groupsMinAggregateInputType
    _max?: Study_groupsMaxAggregateInputType
  }

  export type Study_groupsGroupByOutputType = {
    group_id: bigint
    group_name: string
    description: string | null
    tutor_id: bigint
    created_at: Date | null
    updated_at: Date | null
    _count: Study_groupsCountAggregateOutputType | null
    _avg: Study_groupsAvgAggregateOutputType | null
    _sum: Study_groupsSumAggregateOutputType | null
    _min: Study_groupsMinAggregateOutputType | null
    _max: Study_groupsMaxAggregateOutputType | null
  }

  type GetStudy_groupsGroupByPayload<T extends study_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Study_groupsGroupByOutputType[P]>
        }
      >
    >


  export type study_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    group_name?: boolean
    description?: boolean
    tutor_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    tutor?: boolean | usersDefaultArgs<ExtArgs>
    students?: boolean | study_groups$studentsArgs<ExtArgs>
    members?: boolean | study_groups$membersArgs<ExtArgs>
    assignments?: boolean | study_groups$assignmentsArgs<ExtArgs>
    test_plans?: boolean | study_groups$test_plansArgs<ExtArgs>
    _count?: boolean | Study_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_groups"]>


  export type study_groupsSelectScalar = {
    group_id?: boolean
    group_name?: boolean
    description?: boolean
    tutor_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type study_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | usersDefaultArgs<ExtArgs>
    students?: boolean | study_groups$studentsArgs<ExtArgs>
    members?: boolean | study_groups$membersArgs<ExtArgs>
    assignments?: boolean | study_groups$assignmentsArgs<ExtArgs>
    test_plans?: boolean | study_groups$test_plansArgs<ExtArgs>
    _count?: boolean | Study_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $study_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_groups"
    objects: {
      tutor: Prisma.$usersPayload<ExtArgs>
      students: Prisma.$usersPayload<ExtArgs>[]
      members: Prisma.$group_membersPayload<ExtArgs>[]
      assignments: Prisma.$test_assignmentsPayload<ExtArgs>[]
      test_plans: Prisma.$test_plansPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      group_id: bigint
      group_name: string
      description: string | null
      tutor_id: bigint
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["study_groups"]>
    composites: {}
  }

  type study_groupsGetPayload<S extends boolean | null | undefined | study_groupsDefaultArgs> = $Result.GetResult<Prisma.$study_groupsPayload, S>

  type study_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<study_groupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Study_groupsCountAggregateInputType | true
    }

  export interface study_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_groups'], meta: { name: 'study_groups' } }
    /**
     * Find zero or one Study_groups that matches the filter.
     * @param {study_groupsFindUniqueArgs} args - Arguments to find a Study_groups
     * @example
     * // Get one Study_groups
     * const study_groups = await prisma.study_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_groupsFindUniqueArgs>(args: SelectSubset<T, study_groupsFindUniqueArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Study_groups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {study_groupsFindUniqueOrThrowArgs} args - Arguments to find a Study_groups
     * @example
     * // Get one Study_groups
     * const study_groups = await prisma.study_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, study_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Study_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_groupsFindFirstArgs} args - Arguments to find a Study_groups
     * @example
     * // Get one Study_groups
     * const study_groups = await prisma.study_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_groupsFindFirstArgs>(args?: SelectSubset<T, study_groupsFindFirstArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Study_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_groupsFindFirstOrThrowArgs} args - Arguments to find a Study_groups
     * @example
     * // Get one Study_groups
     * const study_groups = await prisma.study_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, study_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Study_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_groups
     * const study_groups = await prisma.study_groups.findMany()
     * 
     * // Get first 10 Study_groups
     * const study_groups = await prisma.study_groups.findMany({ take: 10 })
     * 
     * // Only select the `group_id`
     * const study_groupsWithGroup_idOnly = await prisma.study_groups.findMany({ select: { group_id: true } })
     * 
     */
    findMany<T extends study_groupsFindManyArgs>(args?: SelectSubset<T, study_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Study_groups.
     * @param {study_groupsCreateArgs} args - Arguments to create a Study_groups.
     * @example
     * // Create one Study_groups
     * const Study_groups = await prisma.study_groups.create({
     *   data: {
     *     // ... data to create a Study_groups
     *   }
     * })
     * 
     */
    create<T extends study_groupsCreateArgs>(args: SelectSubset<T, study_groupsCreateArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Study_groups.
     * @param {study_groupsCreateManyArgs} args - Arguments to create many Study_groups.
     * @example
     * // Create many Study_groups
     * const study_groups = await prisma.study_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_groupsCreateManyArgs>(args?: SelectSubset<T, study_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_groups.
     * @param {study_groupsDeleteArgs} args - Arguments to delete one Study_groups.
     * @example
     * // Delete one Study_groups
     * const Study_groups = await prisma.study_groups.delete({
     *   where: {
     *     // ... filter to delete one Study_groups
     *   }
     * })
     * 
     */
    delete<T extends study_groupsDeleteArgs>(args: SelectSubset<T, study_groupsDeleteArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Study_groups.
     * @param {study_groupsUpdateArgs} args - Arguments to update one Study_groups.
     * @example
     * // Update one Study_groups
     * const study_groups = await prisma.study_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_groupsUpdateArgs>(args: SelectSubset<T, study_groupsUpdateArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Study_groups.
     * @param {study_groupsDeleteManyArgs} args - Arguments to filter Study_groups to delete.
     * @example
     * // Delete a few Study_groups
     * const { count } = await prisma.study_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_groupsDeleteManyArgs>(args?: SelectSubset<T, study_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_groups
     * const study_groups = await prisma.study_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_groupsUpdateManyArgs>(args: SelectSubset<T, study_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_groups.
     * @param {study_groupsUpsertArgs} args - Arguments to update or create a Study_groups.
     * @example
     * // Update or create a Study_groups
     * const study_groups = await prisma.study_groups.upsert({
     *   create: {
     *     // ... data to create a Study_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_groups we want to update
     *   }
     * })
     */
    upsert<T extends study_groupsUpsertArgs>(args: SelectSubset<T, study_groupsUpsertArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Study_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_groupsCountArgs} args - Arguments to filter Study_groups to count.
     * @example
     * // Count the number of Study_groups
     * const count = await prisma.study_groups.count({
     *   where: {
     *     // ... the filter for the Study_groups we want to count
     *   }
     * })
    **/
    count<T extends study_groupsCountArgs>(
      args?: Subset<T, study_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_groupsAggregateArgs>(args: Subset<T, Study_groupsAggregateArgs>): Prisma.PrismaPromise<GetStudy_groupsAggregateType<T>>

    /**
     * Group by Study_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_groupsGroupByArgs['orderBy'] }
        : { orderBy?: study_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_groups model
   */
  readonly fields: study_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutor<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends study_groups$studentsArgs<ExtArgs> = {}>(args?: Subset<T, study_groups$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends study_groups$membersArgs<ExtArgs> = {}>(args?: Subset<T, study_groups$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends study_groups$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, study_groups$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findMany"> | Null>
    test_plans<T extends study_groups$test_plansArgs<ExtArgs> = {}>(args?: Subset<T, study_groups$test_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_groups model
   */ 
  interface study_groupsFieldRefs {
    readonly group_id: FieldRef<"study_groups", 'BigInt'>
    readonly group_name: FieldRef<"study_groups", 'String'>
    readonly description: FieldRef<"study_groups", 'String'>
    readonly tutor_id: FieldRef<"study_groups", 'BigInt'>
    readonly created_at: FieldRef<"study_groups", 'DateTime'>
    readonly updated_at: FieldRef<"study_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * study_groups findUnique
   */
  export type study_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * Filter, which study_groups to fetch.
     */
    where: study_groupsWhereUniqueInput
  }

  /**
   * study_groups findUniqueOrThrow
   */
  export type study_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * Filter, which study_groups to fetch.
     */
    where: study_groupsWhereUniqueInput
  }

  /**
   * study_groups findFirst
   */
  export type study_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * Filter, which study_groups to fetch.
     */
    where?: study_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_groups to fetch.
     */
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_groups.
     */
    cursor?: study_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_groups.
     */
    distinct?: Study_groupsScalarFieldEnum | Study_groupsScalarFieldEnum[]
  }

  /**
   * study_groups findFirstOrThrow
   */
  export type study_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * Filter, which study_groups to fetch.
     */
    where?: study_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_groups to fetch.
     */
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_groups.
     */
    cursor?: study_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_groups.
     */
    distinct?: Study_groupsScalarFieldEnum | Study_groupsScalarFieldEnum[]
  }

  /**
   * study_groups findMany
   */
  export type study_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * Filter, which study_groups to fetch.
     */
    where?: study_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_groups to fetch.
     */
    orderBy?: study_groupsOrderByWithRelationInput | study_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_groups.
     */
    cursor?: study_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_groups.
     */
    skip?: number
    distinct?: Study_groupsScalarFieldEnum | Study_groupsScalarFieldEnum[]
  }

  /**
   * study_groups create
   */
  export type study_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a study_groups.
     */
    data: XOR<study_groupsCreateInput, study_groupsUncheckedCreateInput>
  }

  /**
   * study_groups createMany
   */
  export type study_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_groups.
     */
    data: study_groupsCreateManyInput | study_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_groups update
   */
  export type study_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a study_groups.
     */
    data: XOR<study_groupsUpdateInput, study_groupsUncheckedUpdateInput>
    /**
     * Choose, which study_groups to update.
     */
    where: study_groupsWhereUniqueInput
  }

  /**
   * study_groups updateMany
   */
  export type study_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_groups.
     */
    data: XOR<study_groupsUpdateManyMutationInput, study_groupsUncheckedUpdateManyInput>
    /**
     * Filter which study_groups to update
     */
    where?: study_groupsWhereInput
  }

  /**
   * study_groups upsert
   */
  export type study_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the study_groups to update in case it exists.
     */
    where: study_groupsWhereUniqueInput
    /**
     * In case the study_groups found by the `where` argument doesn't exist, create a new study_groups with this data.
     */
    create: XOR<study_groupsCreateInput, study_groupsUncheckedCreateInput>
    /**
     * In case the study_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_groupsUpdateInput, study_groupsUncheckedUpdateInput>
  }

  /**
   * study_groups delete
   */
  export type study_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    /**
     * Filter which study_groups to delete.
     */
    where: study_groupsWhereUniqueInput
  }

  /**
   * study_groups deleteMany
   */
  export type study_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_groups to delete
     */
    where?: study_groupsWhereInput
  }

  /**
   * study_groups.students
   */
  export type study_groups$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * study_groups.members
   */
  export type study_groups$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    where?: group_membersWhereInput
    orderBy?: group_membersOrderByWithRelationInput | group_membersOrderByWithRelationInput[]
    cursor?: group_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Group_membersScalarFieldEnum | Group_membersScalarFieldEnum[]
  }

  /**
   * study_groups.assignments
   */
  export type study_groups$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    where?: test_assignmentsWhereInput
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    cursor?: test_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * study_groups.test_plans
   */
  export type study_groups$test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    cursor?: test_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * study_groups without action
   */
  export type study_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
  }


  /**
   * Model student_guardians
   */

  export type AggregateStudent_guardians = {
    _count: Student_guardiansCountAggregateOutputType | null
    _avg: Student_guardiansAvgAggregateOutputType | null
    _sum: Student_guardiansSumAggregateOutputType | null
    _min: Student_guardiansMinAggregateOutputType | null
    _max: Student_guardiansMaxAggregateOutputType | null
  }

  export type Student_guardiansAvgAggregateOutputType = {
    relationship_id: number | null
    guardian_id: number | null
    student_id: number | null
  }

  export type Student_guardiansSumAggregateOutputType = {
    relationship_id: bigint | null
    guardian_id: bigint | null
    student_id: bigint | null
  }

  export type Student_guardiansMinAggregateOutputType = {
    relationship_id: bigint | null
    guardian_id: bigint | null
    student_id: bigint | null
    relationship_type: $Enums.GuardianRelationType | null
    status: $Enums.GuardianRelationStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_guardiansMaxAggregateOutputType = {
    relationship_id: bigint | null
    guardian_id: bigint | null
    student_id: bigint | null
    relationship_type: $Enums.GuardianRelationType | null
    status: $Enums.GuardianRelationStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_guardiansCountAggregateOutputType = {
    relationship_id: number
    guardian_id: number
    student_id: number
    relationship_type: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Student_guardiansAvgAggregateInputType = {
    relationship_id?: true
    guardian_id?: true
    student_id?: true
  }

  export type Student_guardiansSumAggregateInputType = {
    relationship_id?: true
    guardian_id?: true
    student_id?: true
  }

  export type Student_guardiansMinAggregateInputType = {
    relationship_id?: true
    guardian_id?: true
    student_id?: true
    relationship_type?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_guardiansMaxAggregateInputType = {
    relationship_id?: true
    guardian_id?: true
    student_id?: true
    relationship_type?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_guardiansCountAggregateInputType = {
    relationship_id?: true
    guardian_id?: true
    student_id?: true
    relationship_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Student_guardiansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_guardians to aggregate.
     */
    where?: student_guardiansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_guardians to fetch.
     */
    orderBy?: student_guardiansOrderByWithRelationInput | student_guardiansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_guardiansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_guardians
    **/
    _count?: true | Student_guardiansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_guardiansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_guardiansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_guardiansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_guardiansMaxAggregateInputType
  }

  export type GetStudent_guardiansAggregateType<T extends Student_guardiansAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_guardians]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_guardians[P]>
      : GetScalarType<T[P], AggregateStudent_guardians[P]>
  }




  export type student_guardiansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_guardiansWhereInput
    orderBy?: student_guardiansOrderByWithAggregationInput | student_guardiansOrderByWithAggregationInput[]
    by: Student_guardiansScalarFieldEnum[] | Student_guardiansScalarFieldEnum
    having?: student_guardiansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_guardiansCountAggregateInputType | true
    _avg?: Student_guardiansAvgAggregateInputType
    _sum?: Student_guardiansSumAggregateInputType
    _min?: Student_guardiansMinAggregateInputType
    _max?: Student_guardiansMaxAggregateInputType
  }

  export type Student_guardiansGroupByOutputType = {
    relationship_id: bigint
    guardian_id: bigint
    student_id: bigint
    relationship_type: $Enums.GuardianRelationType
    status: $Enums.GuardianRelationStatus
    created_at: Date | null
    updated_at: Date | null
    _count: Student_guardiansCountAggregateOutputType | null
    _avg: Student_guardiansAvgAggregateOutputType | null
    _sum: Student_guardiansSumAggregateOutputType | null
    _min: Student_guardiansMinAggregateOutputType | null
    _max: Student_guardiansMaxAggregateOutputType | null
  }

  type GetStudent_guardiansGroupByPayload<T extends student_guardiansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_guardiansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_guardiansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_guardiansGroupByOutputType[P]>
            : GetScalarType<T[P], Student_guardiansGroupByOutputType[P]>
        }
      >
    >


  export type student_guardiansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    relationship_id?: boolean
    guardian_id?: boolean
    student_id?: boolean
    relationship_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    guardian?: boolean | usersDefaultArgs<ExtArgs>
    student?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_guardians"]>


  export type student_guardiansSelectScalar = {
    relationship_id?: boolean
    guardian_id?: boolean
    student_id?: boolean
    relationship_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type student_guardiansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guardian?: boolean | usersDefaultArgs<ExtArgs>
    student?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $student_guardiansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_guardians"
    objects: {
      guardian: Prisma.$usersPayload<ExtArgs>
      student: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      relationship_id: bigint
      guardian_id: bigint
      student_id: bigint
      relationship_type: $Enums.GuardianRelationType
      status: $Enums.GuardianRelationStatus
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["student_guardians"]>
    composites: {}
  }

  type student_guardiansGetPayload<S extends boolean | null | undefined | student_guardiansDefaultArgs> = $Result.GetResult<Prisma.$student_guardiansPayload, S>

  type student_guardiansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<student_guardiansFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_guardiansCountAggregateInputType | true
    }

  export interface student_guardiansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_guardians'], meta: { name: 'student_guardians' } }
    /**
     * Find zero or one Student_guardians that matches the filter.
     * @param {student_guardiansFindUniqueArgs} args - Arguments to find a Student_guardians
     * @example
     * // Get one Student_guardians
     * const student_guardians = await prisma.student_guardians.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_guardiansFindUniqueArgs>(args: SelectSubset<T, student_guardiansFindUniqueArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_guardians that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {student_guardiansFindUniqueOrThrowArgs} args - Arguments to find a Student_guardians
     * @example
     * // Get one Student_guardians
     * const student_guardians = await prisma.student_guardians.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_guardiansFindUniqueOrThrowArgs>(args: SelectSubset<T, student_guardiansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_guardians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_guardiansFindFirstArgs} args - Arguments to find a Student_guardians
     * @example
     * // Get one Student_guardians
     * const student_guardians = await prisma.student_guardians.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_guardiansFindFirstArgs>(args?: SelectSubset<T, student_guardiansFindFirstArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_guardians that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_guardiansFindFirstOrThrowArgs} args - Arguments to find a Student_guardians
     * @example
     * // Get one Student_guardians
     * const student_guardians = await prisma.student_guardians.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_guardiansFindFirstOrThrowArgs>(args?: SelectSubset<T, student_guardiansFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_guardians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_guardiansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_guardians
     * const student_guardians = await prisma.student_guardians.findMany()
     * 
     * // Get first 10 Student_guardians
     * const student_guardians = await prisma.student_guardians.findMany({ take: 10 })
     * 
     * // Only select the `relationship_id`
     * const student_guardiansWithRelationship_idOnly = await prisma.student_guardians.findMany({ select: { relationship_id: true } })
     * 
     */
    findMany<T extends student_guardiansFindManyArgs>(args?: SelectSubset<T, student_guardiansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_guardians.
     * @param {student_guardiansCreateArgs} args - Arguments to create a Student_guardians.
     * @example
     * // Create one Student_guardians
     * const Student_guardians = await prisma.student_guardians.create({
     *   data: {
     *     // ... data to create a Student_guardians
     *   }
     * })
     * 
     */
    create<T extends student_guardiansCreateArgs>(args: SelectSubset<T, student_guardiansCreateArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_guardians.
     * @param {student_guardiansCreateManyArgs} args - Arguments to create many Student_guardians.
     * @example
     * // Create many Student_guardians
     * const student_guardians = await prisma.student_guardians.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_guardiansCreateManyArgs>(args?: SelectSubset<T, student_guardiansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_guardians.
     * @param {student_guardiansDeleteArgs} args - Arguments to delete one Student_guardians.
     * @example
     * // Delete one Student_guardians
     * const Student_guardians = await prisma.student_guardians.delete({
     *   where: {
     *     // ... filter to delete one Student_guardians
     *   }
     * })
     * 
     */
    delete<T extends student_guardiansDeleteArgs>(args: SelectSubset<T, student_guardiansDeleteArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_guardians.
     * @param {student_guardiansUpdateArgs} args - Arguments to update one Student_guardians.
     * @example
     * // Update one Student_guardians
     * const student_guardians = await prisma.student_guardians.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_guardiansUpdateArgs>(args: SelectSubset<T, student_guardiansUpdateArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_guardians.
     * @param {student_guardiansDeleteManyArgs} args - Arguments to filter Student_guardians to delete.
     * @example
     * // Delete a few Student_guardians
     * const { count } = await prisma.student_guardians.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_guardiansDeleteManyArgs>(args?: SelectSubset<T, student_guardiansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_guardiansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_guardians
     * const student_guardians = await prisma.student_guardians.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_guardiansUpdateManyArgs>(args: SelectSubset<T, student_guardiansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_guardians.
     * @param {student_guardiansUpsertArgs} args - Arguments to update or create a Student_guardians.
     * @example
     * // Update or create a Student_guardians
     * const student_guardians = await prisma.student_guardians.upsert({
     *   create: {
     *     // ... data to create a Student_guardians
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_guardians we want to update
     *   }
     * })
     */
    upsert<T extends student_guardiansUpsertArgs>(args: SelectSubset<T, student_guardiansUpsertArgs<ExtArgs>>): Prisma__student_guardiansClient<$Result.GetResult<Prisma.$student_guardiansPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_guardiansCountArgs} args - Arguments to filter Student_guardians to count.
     * @example
     * // Count the number of Student_guardians
     * const count = await prisma.student_guardians.count({
     *   where: {
     *     // ... the filter for the Student_guardians we want to count
     *   }
     * })
    **/
    count<T extends student_guardiansCountArgs>(
      args?: Subset<T, student_guardiansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_guardiansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_guardiansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_guardiansAggregateArgs>(args: Subset<T, Student_guardiansAggregateArgs>): Prisma.PrismaPromise<GetStudent_guardiansAggregateType<T>>

    /**
     * Group by Student_guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_guardiansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_guardiansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_guardiansGroupByArgs['orderBy'] }
        : { orderBy?: student_guardiansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_guardiansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_guardiansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_guardians model
   */
  readonly fields: student_guardiansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_guardians.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_guardiansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guardian<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_guardians model
   */ 
  interface student_guardiansFieldRefs {
    readonly relationship_id: FieldRef<"student_guardians", 'BigInt'>
    readonly guardian_id: FieldRef<"student_guardians", 'BigInt'>
    readonly student_id: FieldRef<"student_guardians", 'BigInt'>
    readonly relationship_type: FieldRef<"student_guardians", 'GuardianRelationType'>
    readonly status: FieldRef<"student_guardians", 'GuardianRelationStatus'>
    readonly created_at: FieldRef<"student_guardians", 'DateTime'>
    readonly updated_at: FieldRef<"student_guardians", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_guardians findUnique
   */
  export type student_guardiansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * Filter, which student_guardians to fetch.
     */
    where: student_guardiansWhereUniqueInput
  }

  /**
   * student_guardians findUniqueOrThrow
   */
  export type student_guardiansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * Filter, which student_guardians to fetch.
     */
    where: student_guardiansWhereUniqueInput
  }

  /**
   * student_guardians findFirst
   */
  export type student_guardiansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * Filter, which student_guardians to fetch.
     */
    where?: student_guardiansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_guardians to fetch.
     */
    orderBy?: student_guardiansOrderByWithRelationInput | student_guardiansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_guardians.
     */
    cursor?: student_guardiansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_guardians.
     */
    distinct?: Student_guardiansScalarFieldEnum | Student_guardiansScalarFieldEnum[]
  }

  /**
   * student_guardians findFirstOrThrow
   */
  export type student_guardiansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * Filter, which student_guardians to fetch.
     */
    where?: student_guardiansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_guardians to fetch.
     */
    orderBy?: student_guardiansOrderByWithRelationInput | student_guardiansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_guardians.
     */
    cursor?: student_guardiansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_guardians.
     */
    distinct?: Student_guardiansScalarFieldEnum | Student_guardiansScalarFieldEnum[]
  }

  /**
   * student_guardians findMany
   */
  export type student_guardiansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * Filter, which student_guardians to fetch.
     */
    where?: student_guardiansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_guardians to fetch.
     */
    orderBy?: student_guardiansOrderByWithRelationInput | student_guardiansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_guardians.
     */
    cursor?: student_guardiansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_guardians.
     */
    skip?: number
    distinct?: Student_guardiansScalarFieldEnum | Student_guardiansScalarFieldEnum[]
  }

  /**
   * student_guardians create
   */
  export type student_guardiansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * The data needed to create a student_guardians.
     */
    data: XOR<student_guardiansCreateInput, student_guardiansUncheckedCreateInput>
  }

  /**
   * student_guardians createMany
   */
  export type student_guardiansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_guardians.
     */
    data: student_guardiansCreateManyInput | student_guardiansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_guardians update
   */
  export type student_guardiansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * The data needed to update a student_guardians.
     */
    data: XOR<student_guardiansUpdateInput, student_guardiansUncheckedUpdateInput>
    /**
     * Choose, which student_guardians to update.
     */
    where: student_guardiansWhereUniqueInput
  }

  /**
   * student_guardians updateMany
   */
  export type student_guardiansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_guardians.
     */
    data: XOR<student_guardiansUpdateManyMutationInput, student_guardiansUncheckedUpdateManyInput>
    /**
     * Filter which student_guardians to update
     */
    where?: student_guardiansWhereInput
  }

  /**
   * student_guardians upsert
   */
  export type student_guardiansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * The filter to search for the student_guardians to update in case it exists.
     */
    where: student_guardiansWhereUniqueInput
    /**
     * In case the student_guardians found by the `where` argument doesn't exist, create a new student_guardians with this data.
     */
    create: XOR<student_guardiansCreateInput, student_guardiansUncheckedCreateInput>
    /**
     * In case the student_guardians was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_guardiansUpdateInput, student_guardiansUncheckedUpdateInput>
  }

  /**
   * student_guardians delete
   */
  export type student_guardiansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
    /**
     * Filter which student_guardians to delete.
     */
    where: student_guardiansWhereUniqueInput
  }

  /**
   * student_guardians deleteMany
   */
  export type student_guardiansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_guardians to delete
     */
    where?: student_guardiansWhereInput
  }

  /**
   * student_guardians without action
   */
  export type student_guardiansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_guardians
     */
    select?: student_guardiansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_guardiansInclude<ExtArgs> | null
  }


  /**
   * Model group_members
   */

  export type AggregateGroup_members = {
    _count: Group_membersCountAggregateOutputType | null
    _avg: Group_membersAvgAggregateOutputType | null
    _sum: Group_membersSumAggregateOutputType | null
    _min: Group_membersMinAggregateOutputType | null
    _max: Group_membersMaxAggregateOutputType | null
  }

  export type Group_membersAvgAggregateOutputType = {
    group_id: number | null
    student_id: number | null
  }

  export type Group_membersSumAggregateOutputType = {
    group_id: bigint | null
    student_id: bigint | null
  }

  export type Group_membersMinAggregateOutputType = {
    group_id: bigint | null
    student_id: bigint | null
    joined_at: Date | null
  }

  export type Group_membersMaxAggregateOutputType = {
    group_id: bigint | null
    student_id: bigint | null
    joined_at: Date | null
  }

  export type Group_membersCountAggregateOutputType = {
    group_id: number
    student_id: number
    joined_at: number
    _all: number
  }


  export type Group_membersAvgAggregateInputType = {
    group_id?: true
    student_id?: true
  }

  export type Group_membersSumAggregateInputType = {
    group_id?: true
    student_id?: true
  }

  export type Group_membersMinAggregateInputType = {
    group_id?: true
    student_id?: true
    joined_at?: true
  }

  export type Group_membersMaxAggregateInputType = {
    group_id?: true
    student_id?: true
    joined_at?: true
  }

  export type Group_membersCountAggregateInputType = {
    group_id?: true
    student_id?: true
    joined_at?: true
    _all?: true
  }

  export type Group_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_members to aggregate.
     */
    where?: group_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_members to fetch.
     */
    orderBy?: group_membersOrderByWithRelationInput | group_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_members
    **/
    _count?: true | Group_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_membersMaxAggregateInputType
  }

  export type GetGroup_membersAggregateType<T extends Group_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_members[P]>
      : GetScalarType<T[P], AggregateGroup_members[P]>
  }




  export type group_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_membersWhereInput
    orderBy?: group_membersOrderByWithAggregationInput | group_membersOrderByWithAggregationInput[]
    by: Group_membersScalarFieldEnum[] | Group_membersScalarFieldEnum
    having?: group_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_membersCountAggregateInputType | true
    _avg?: Group_membersAvgAggregateInputType
    _sum?: Group_membersSumAggregateInputType
    _min?: Group_membersMinAggregateInputType
    _max?: Group_membersMaxAggregateInputType
  }

  export type Group_membersGroupByOutputType = {
    group_id: bigint
    student_id: bigint
    joined_at: Date | null
    _count: Group_membersCountAggregateOutputType | null
    _avg: Group_membersAvgAggregateOutputType | null
    _sum: Group_membersSumAggregateOutputType | null
    _min: Group_membersMinAggregateOutputType | null
    _max: Group_membersMaxAggregateOutputType | null
  }

  type GetGroup_membersGroupByPayload<T extends group_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Group_membersGroupByOutputType[P]>
        }
      >
    >


  export type group_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    student_id?: boolean
    joined_at?: boolean
    group?: boolean | study_groupsDefaultArgs<ExtArgs>
    student?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group_members"]>


  export type group_membersSelectScalar = {
    group_id?: boolean
    student_id?: boolean
    joined_at?: boolean
  }

  export type group_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | study_groupsDefaultArgs<ExtArgs>
    student?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $group_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_members"
    objects: {
      group: Prisma.$study_groupsPayload<ExtArgs>
      student: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      group_id: bigint
      student_id: bigint
      joined_at: Date | null
    }, ExtArgs["result"]["group_members"]>
    composites: {}
  }

  type group_membersGetPayload<S extends boolean | null | undefined | group_membersDefaultArgs> = $Result.GetResult<Prisma.$group_membersPayload, S>

  type group_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<group_membersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Group_membersCountAggregateInputType | true
    }

  export interface group_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_members'], meta: { name: 'group_members' } }
    /**
     * Find zero or one Group_members that matches the filter.
     * @param {group_membersFindUniqueArgs} args - Arguments to find a Group_members
     * @example
     * // Get one Group_members
     * const group_members = await prisma.group_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_membersFindUniqueArgs>(args: SelectSubset<T, group_membersFindUniqueArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group_members that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {group_membersFindUniqueOrThrowArgs} args - Arguments to find a Group_members
     * @example
     * // Get one Group_members
     * const group_members = await prisma.group_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_membersFindUniqueOrThrowArgs>(args: SelectSubset<T, group_membersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_membersFindFirstArgs} args - Arguments to find a Group_members
     * @example
     * // Get one Group_members
     * const group_members = await prisma.group_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_membersFindFirstArgs>(args?: SelectSubset<T, group_membersFindFirstArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_membersFindFirstOrThrowArgs} args - Arguments to find a Group_members
     * @example
     * // Get one Group_members
     * const group_members = await prisma.group_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_membersFindFirstOrThrowArgs>(args?: SelectSubset<T, group_membersFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Group_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_membersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_members
     * const group_members = await prisma.group_members.findMany()
     * 
     * // Get first 10 Group_members
     * const group_members = await prisma.group_members.findMany({ take: 10 })
     * 
     * // Only select the `group_id`
     * const group_membersWithGroup_idOnly = await prisma.group_members.findMany({ select: { group_id: true } })
     * 
     */
    findMany<T extends group_membersFindManyArgs>(args?: SelectSubset<T, group_membersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group_members.
     * @param {group_membersCreateArgs} args - Arguments to create a Group_members.
     * @example
     * // Create one Group_members
     * const Group_members = await prisma.group_members.create({
     *   data: {
     *     // ... data to create a Group_members
     *   }
     * })
     * 
     */
    create<T extends group_membersCreateArgs>(args: SelectSubset<T, group_membersCreateArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Group_members.
     * @param {group_membersCreateManyArgs} args - Arguments to create many Group_members.
     * @example
     * // Create many Group_members
     * const group_members = await prisma.group_members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_membersCreateManyArgs>(args?: SelectSubset<T, group_membersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group_members.
     * @param {group_membersDeleteArgs} args - Arguments to delete one Group_members.
     * @example
     * // Delete one Group_members
     * const Group_members = await prisma.group_members.delete({
     *   where: {
     *     // ... filter to delete one Group_members
     *   }
     * })
     * 
     */
    delete<T extends group_membersDeleteArgs>(args: SelectSubset<T, group_membersDeleteArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group_members.
     * @param {group_membersUpdateArgs} args - Arguments to update one Group_members.
     * @example
     * // Update one Group_members
     * const group_members = await prisma.group_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_membersUpdateArgs>(args: SelectSubset<T, group_membersUpdateArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Group_members.
     * @param {group_membersDeleteManyArgs} args - Arguments to filter Group_members to delete.
     * @example
     * // Delete a few Group_members
     * const { count } = await prisma.group_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_membersDeleteManyArgs>(args?: SelectSubset<T, group_membersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_members
     * const group_members = await prisma.group_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_membersUpdateManyArgs>(args: SelectSubset<T, group_membersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group_members.
     * @param {group_membersUpsertArgs} args - Arguments to update or create a Group_members.
     * @example
     * // Update or create a Group_members
     * const group_members = await prisma.group_members.upsert({
     *   create: {
     *     // ... data to create a Group_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_members we want to update
     *   }
     * })
     */
    upsert<T extends group_membersUpsertArgs>(args: SelectSubset<T, group_membersUpsertArgs<ExtArgs>>): Prisma__group_membersClient<$Result.GetResult<Prisma.$group_membersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Group_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_membersCountArgs} args - Arguments to filter Group_members to count.
     * @example
     * // Count the number of Group_members
     * const count = await prisma.group_members.count({
     *   where: {
     *     // ... the filter for the Group_members we want to count
     *   }
     * })
    **/
    count<T extends group_membersCountArgs>(
      args?: Subset<T, group_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_membersAggregateArgs>(args: Subset<T, Group_membersAggregateArgs>): Prisma.PrismaPromise<GetGroup_membersAggregateType<T>>

    /**
     * Group by Group_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_membersGroupByArgs['orderBy'] }
        : { orderBy?: group_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_members model
   */
  readonly fields: group_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends study_groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_groupsDefaultArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_members model
   */ 
  interface group_membersFieldRefs {
    readonly group_id: FieldRef<"group_members", 'BigInt'>
    readonly student_id: FieldRef<"group_members", 'BigInt'>
    readonly joined_at: FieldRef<"group_members", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * group_members findUnique
   */
  export type group_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * Filter, which group_members to fetch.
     */
    where: group_membersWhereUniqueInput
  }

  /**
   * group_members findUniqueOrThrow
   */
  export type group_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * Filter, which group_members to fetch.
     */
    where: group_membersWhereUniqueInput
  }

  /**
   * group_members findFirst
   */
  export type group_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * Filter, which group_members to fetch.
     */
    where?: group_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_members to fetch.
     */
    orderBy?: group_membersOrderByWithRelationInput | group_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_members.
     */
    cursor?: group_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_members.
     */
    distinct?: Group_membersScalarFieldEnum | Group_membersScalarFieldEnum[]
  }

  /**
   * group_members findFirstOrThrow
   */
  export type group_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * Filter, which group_members to fetch.
     */
    where?: group_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_members to fetch.
     */
    orderBy?: group_membersOrderByWithRelationInput | group_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_members.
     */
    cursor?: group_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_members.
     */
    distinct?: Group_membersScalarFieldEnum | Group_membersScalarFieldEnum[]
  }

  /**
   * group_members findMany
   */
  export type group_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * Filter, which group_members to fetch.
     */
    where?: group_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_members to fetch.
     */
    orderBy?: group_membersOrderByWithRelationInput | group_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_members.
     */
    cursor?: group_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_members.
     */
    skip?: number
    distinct?: Group_membersScalarFieldEnum | Group_membersScalarFieldEnum[]
  }

  /**
   * group_members create
   */
  export type group_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a group_members.
     */
    data: XOR<group_membersCreateInput, group_membersUncheckedCreateInput>
  }

  /**
   * group_members createMany
   */
  export type group_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_members.
     */
    data: group_membersCreateManyInput | group_membersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_members update
   */
  export type group_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a group_members.
     */
    data: XOR<group_membersUpdateInput, group_membersUncheckedUpdateInput>
    /**
     * Choose, which group_members to update.
     */
    where: group_membersWhereUniqueInput
  }

  /**
   * group_members updateMany
   */
  export type group_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_members.
     */
    data: XOR<group_membersUpdateManyMutationInput, group_membersUncheckedUpdateManyInput>
    /**
     * Filter which group_members to update
     */
    where?: group_membersWhereInput
  }

  /**
   * group_members upsert
   */
  export type group_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the group_members to update in case it exists.
     */
    where: group_membersWhereUniqueInput
    /**
     * In case the group_members found by the `where` argument doesn't exist, create a new group_members with this data.
     */
    create: XOR<group_membersCreateInput, group_membersUncheckedCreateInput>
    /**
     * In case the group_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_membersUpdateInput, group_membersUncheckedUpdateInput>
  }

  /**
   * group_members delete
   */
  export type group_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
    /**
     * Filter which group_members to delete.
     */
    where: group_membersWhereUniqueInput
  }

  /**
   * group_members deleteMany
   */
  export type group_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_members to delete
     */
    where?: group_membersWhereInput
  }

  /**
   * group_members without action
   */
  export type group_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_members
     */
    select?: group_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_membersInclude<ExtArgs> | null
  }


  /**
   * Model test_assignments
   */

  export type AggregateTest_assignments = {
    _count: Test_assignmentsCountAggregateOutputType | null
    _avg: Test_assignmentsAvgAggregateOutputType | null
    _sum: Test_assignmentsSumAggregateOutputType | null
    _min: Test_assignmentsMinAggregateOutputType | null
    _max: Test_assignmentsMaxAggregateOutputType | null
  }

  export type Test_assignmentsAvgAggregateOutputType = {
    assignment_id: number | null
    test_plan_id: number | null
    assigned_by: number | null
    group_id: number | null
    student_id: number | null
  }

  export type Test_assignmentsSumAggregateOutputType = {
    assignment_id: bigint | null
    test_plan_id: bigint | null
    assigned_by: bigint | null
    group_id: bigint | null
    student_id: bigint | null
  }

  export type Test_assignmentsMinAggregateOutputType = {
    assignment_id: bigint | null
    test_plan_id: bigint | null
    assigned_by: bigint | null
    group_id: bigint | null
    student_id: bigint | null
    due_date: Date | null
    status: $Enums.TestAssignmentStatus | null
    created_at: Date | null
  }

  export type Test_assignmentsMaxAggregateOutputType = {
    assignment_id: bigint | null
    test_plan_id: bigint | null
    assigned_by: bigint | null
    group_id: bigint | null
    student_id: bigint | null
    due_date: Date | null
    status: $Enums.TestAssignmentStatus | null
    created_at: Date | null
  }

  export type Test_assignmentsCountAggregateOutputType = {
    assignment_id: number
    test_plan_id: number
    assigned_by: number
    group_id: number
    student_id: number
    due_date: number
    status: number
    created_at: number
    _all: number
  }


  export type Test_assignmentsAvgAggregateInputType = {
    assignment_id?: true
    test_plan_id?: true
    assigned_by?: true
    group_id?: true
    student_id?: true
  }

  export type Test_assignmentsSumAggregateInputType = {
    assignment_id?: true
    test_plan_id?: true
    assigned_by?: true
    group_id?: true
    student_id?: true
  }

  export type Test_assignmentsMinAggregateInputType = {
    assignment_id?: true
    test_plan_id?: true
    assigned_by?: true
    group_id?: true
    student_id?: true
    due_date?: true
    status?: true
    created_at?: true
  }

  export type Test_assignmentsMaxAggregateInputType = {
    assignment_id?: true
    test_plan_id?: true
    assigned_by?: true
    group_id?: true
    student_id?: true
    due_date?: true
    status?: true
    created_at?: true
  }

  export type Test_assignmentsCountAggregateInputType = {
    assignment_id?: true
    test_plan_id?: true
    assigned_by?: true
    group_id?: true
    student_id?: true
    due_date?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Test_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_assignments to aggregate.
     */
    where?: test_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_assignments to fetch.
     */
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_assignments
    **/
    _count?: true | Test_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_assignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_assignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_assignmentsMaxAggregateInputType
  }

  export type GetTest_assignmentsAggregateType<T extends Test_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_assignments[P]>
      : GetScalarType<T[P], AggregateTest_assignments[P]>
  }




  export type test_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_assignmentsWhereInput
    orderBy?: test_assignmentsOrderByWithAggregationInput | test_assignmentsOrderByWithAggregationInput[]
    by: Test_assignmentsScalarFieldEnum[] | Test_assignmentsScalarFieldEnum
    having?: test_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_assignmentsCountAggregateInputType | true
    _avg?: Test_assignmentsAvgAggregateInputType
    _sum?: Test_assignmentsSumAggregateInputType
    _min?: Test_assignmentsMinAggregateInputType
    _max?: Test_assignmentsMaxAggregateInputType
  }

  export type Test_assignmentsGroupByOutputType = {
    assignment_id: bigint
    test_plan_id: bigint
    assigned_by: bigint
    group_id: bigint | null
    student_id: bigint | null
    due_date: Date
    status: $Enums.TestAssignmentStatus
    created_at: Date | null
    _count: Test_assignmentsCountAggregateOutputType | null
    _avg: Test_assignmentsAvgAggregateOutputType | null
    _sum: Test_assignmentsSumAggregateOutputType | null
    _min: Test_assignmentsMinAggregateOutputType | null
    _max: Test_assignmentsMaxAggregateOutputType | null
  }

  type GetTest_assignmentsGroupByPayload<T extends test_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type test_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    test_plan_id?: boolean
    assigned_by?: boolean
    group_id?: boolean
    student_id?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    test_plan?: boolean | test_plansDefaultArgs<ExtArgs>
    assigner?: boolean | usersDefaultArgs<ExtArgs>
    group?: boolean | test_assignments$groupArgs<ExtArgs>
    student?: boolean | test_assignments$studentArgs<ExtArgs>
  }, ExtArgs["result"]["test_assignments"]>


  export type test_assignmentsSelectScalar = {
    assignment_id?: boolean
    test_plan_id?: boolean
    assigned_by?: boolean
    group_id?: boolean
    student_id?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type test_assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_plan?: boolean | test_plansDefaultArgs<ExtArgs>
    assigner?: boolean | usersDefaultArgs<ExtArgs>
    group?: boolean | test_assignments$groupArgs<ExtArgs>
    student?: boolean | test_assignments$studentArgs<ExtArgs>
  }

  export type $test_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_assignments"
    objects: {
      test_plan: Prisma.$test_plansPayload<ExtArgs>
      assigner: Prisma.$usersPayload<ExtArgs>
      group: Prisma.$study_groupsPayload<ExtArgs> | null
      student: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      assignment_id: bigint
      test_plan_id: bigint
      assigned_by: bigint
      group_id: bigint | null
      student_id: bigint | null
      due_date: Date
      status: $Enums.TestAssignmentStatus
      created_at: Date | null
    }, ExtArgs["result"]["test_assignments"]>
    composites: {}
  }

  type test_assignmentsGetPayload<S extends boolean | null | undefined | test_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$test_assignmentsPayload, S>

  type test_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<test_assignmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Test_assignmentsCountAggregateInputType | true
    }

  export interface test_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_assignments'], meta: { name: 'test_assignments' } }
    /**
     * Find zero or one Test_assignments that matches the filter.
     * @param {test_assignmentsFindUniqueArgs} args - Arguments to find a Test_assignments
     * @example
     * // Get one Test_assignments
     * const test_assignments = await prisma.test_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_assignmentsFindUniqueArgs>(args: SelectSubset<T, test_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Test_assignments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {test_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Test_assignments
     * @example
     * // Get one Test_assignments
     * const test_assignments = await prisma.test_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Test_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_assignmentsFindFirstArgs} args - Arguments to find a Test_assignments
     * @example
     * // Get one Test_assignments
     * const test_assignments = await prisma.test_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_assignmentsFindFirstArgs>(args?: SelectSubset<T, test_assignmentsFindFirstArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Test_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_assignmentsFindFirstOrThrowArgs} args - Arguments to find a Test_assignments
     * @example
     * // Get one Test_assignments
     * const test_assignments = await prisma.test_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Test_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_assignments
     * const test_assignments = await prisma.test_assignments.findMany()
     * 
     * // Get first 10 Test_assignments
     * const test_assignments = await prisma.test_assignments.findMany({ take: 10 })
     * 
     * // Only select the `assignment_id`
     * const test_assignmentsWithAssignment_idOnly = await prisma.test_assignments.findMany({ select: { assignment_id: true } })
     * 
     */
    findMany<T extends test_assignmentsFindManyArgs>(args?: SelectSubset<T, test_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Test_assignments.
     * @param {test_assignmentsCreateArgs} args - Arguments to create a Test_assignments.
     * @example
     * // Create one Test_assignments
     * const Test_assignments = await prisma.test_assignments.create({
     *   data: {
     *     // ... data to create a Test_assignments
     *   }
     * })
     * 
     */
    create<T extends test_assignmentsCreateArgs>(args: SelectSubset<T, test_assignmentsCreateArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Test_assignments.
     * @param {test_assignmentsCreateManyArgs} args - Arguments to create many Test_assignments.
     * @example
     * // Create many Test_assignments
     * const test_assignments = await prisma.test_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_assignmentsCreateManyArgs>(args?: SelectSubset<T, test_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_assignments.
     * @param {test_assignmentsDeleteArgs} args - Arguments to delete one Test_assignments.
     * @example
     * // Delete one Test_assignments
     * const Test_assignments = await prisma.test_assignments.delete({
     *   where: {
     *     // ... filter to delete one Test_assignments
     *   }
     * })
     * 
     */
    delete<T extends test_assignmentsDeleteArgs>(args: SelectSubset<T, test_assignmentsDeleteArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Test_assignments.
     * @param {test_assignmentsUpdateArgs} args - Arguments to update one Test_assignments.
     * @example
     * // Update one Test_assignments
     * const test_assignments = await prisma.test_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_assignmentsUpdateArgs>(args: SelectSubset<T, test_assignmentsUpdateArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Test_assignments.
     * @param {test_assignmentsDeleteManyArgs} args - Arguments to filter Test_assignments to delete.
     * @example
     * // Delete a few Test_assignments
     * const { count } = await prisma.test_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_assignmentsDeleteManyArgs>(args?: SelectSubset<T, test_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_assignments
     * const test_assignments = await prisma.test_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_assignmentsUpdateManyArgs>(args: SelectSubset<T, test_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_assignments.
     * @param {test_assignmentsUpsertArgs} args - Arguments to update or create a Test_assignments.
     * @example
     * // Update or create a Test_assignments
     * const test_assignments = await prisma.test_assignments.upsert({
     *   create: {
     *     // ... data to create a Test_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_assignments we want to update
     *   }
     * })
     */
    upsert<T extends test_assignmentsUpsertArgs>(args: SelectSubset<T, test_assignmentsUpsertArgs<ExtArgs>>): Prisma__test_assignmentsClient<$Result.GetResult<Prisma.$test_assignmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Test_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_assignmentsCountArgs} args - Arguments to filter Test_assignments to count.
     * @example
     * // Count the number of Test_assignments
     * const count = await prisma.test_assignments.count({
     *   where: {
     *     // ... the filter for the Test_assignments we want to count
     *   }
     * })
    **/
    count<T extends test_assignmentsCountArgs>(
      args?: Subset<T, test_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_assignmentsAggregateArgs>(args: Subset<T, Test_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetTest_assignmentsAggregateType<T>>

    /**
     * Group by Test_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: test_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_assignments model
   */
  readonly fields: test_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_plan<T extends test_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_plansDefaultArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assigner<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    group<T extends test_assignments$groupArgs<ExtArgs> = {}>(args?: Subset<T, test_assignments$groupArgs<ExtArgs>>): Prisma__study_groupsClient<$Result.GetResult<Prisma.$study_groupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    student<T extends test_assignments$studentArgs<ExtArgs> = {}>(args?: Subset<T, test_assignments$studentArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_assignments model
   */ 
  interface test_assignmentsFieldRefs {
    readonly assignment_id: FieldRef<"test_assignments", 'BigInt'>
    readonly test_plan_id: FieldRef<"test_assignments", 'BigInt'>
    readonly assigned_by: FieldRef<"test_assignments", 'BigInt'>
    readonly group_id: FieldRef<"test_assignments", 'BigInt'>
    readonly student_id: FieldRef<"test_assignments", 'BigInt'>
    readonly due_date: FieldRef<"test_assignments", 'DateTime'>
    readonly status: FieldRef<"test_assignments", 'TestAssignmentStatus'>
    readonly created_at: FieldRef<"test_assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_assignments findUnique
   */
  export type test_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which test_assignments to fetch.
     */
    where: test_assignmentsWhereUniqueInput
  }

  /**
   * test_assignments findUniqueOrThrow
   */
  export type test_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which test_assignments to fetch.
     */
    where: test_assignmentsWhereUniqueInput
  }

  /**
   * test_assignments findFirst
   */
  export type test_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which test_assignments to fetch.
     */
    where?: test_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_assignments to fetch.
     */
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_assignments.
     */
    cursor?: test_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_assignments.
     */
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * test_assignments findFirstOrThrow
   */
  export type test_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which test_assignments to fetch.
     */
    where?: test_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_assignments to fetch.
     */
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_assignments.
     */
    cursor?: test_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_assignments.
     */
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * test_assignments findMany
   */
  export type test_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which test_assignments to fetch.
     */
    where?: test_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_assignments to fetch.
     */
    orderBy?: test_assignmentsOrderByWithRelationInput | test_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_assignments.
     */
    cursor?: test_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_assignments.
     */
    skip?: number
    distinct?: Test_assignmentsScalarFieldEnum | Test_assignmentsScalarFieldEnum[]
  }

  /**
   * test_assignments create
   */
  export type test_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_assignments.
     */
    data: XOR<test_assignmentsCreateInput, test_assignmentsUncheckedCreateInput>
  }

  /**
   * test_assignments createMany
   */
  export type test_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_assignments.
     */
    data: test_assignmentsCreateManyInput | test_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_assignments update
   */
  export type test_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_assignments.
     */
    data: XOR<test_assignmentsUpdateInput, test_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which test_assignments to update.
     */
    where: test_assignmentsWhereUniqueInput
  }

  /**
   * test_assignments updateMany
   */
  export type test_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_assignments.
     */
    data: XOR<test_assignmentsUpdateManyMutationInput, test_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which test_assignments to update
     */
    where?: test_assignmentsWhereInput
  }

  /**
   * test_assignments upsert
   */
  export type test_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_assignments to update in case it exists.
     */
    where: test_assignmentsWhereUniqueInput
    /**
     * In case the test_assignments found by the `where` argument doesn't exist, create a new test_assignments with this data.
     */
    create: XOR<test_assignmentsCreateInput, test_assignmentsUncheckedCreateInput>
    /**
     * In case the test_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_assignmentsUpdateInput, test_assignmentsUncheckedUpdateInput>
  }

  /**
   * test_assignments delete
   */
  export type test_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
    /**
     * Filter which test_assignments to delete.
     */
    where: test_assignmentsWhereUniqueInput
  }

  /**
   * test_assignments deleteMany
   */
  export type test_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_assignments to delete
     */
    where?: test_assignmentsWhereInput
  }

  /**
   * test_assignments.group
   */
  export type test_assignments$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_groups
     */
    select?: study_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_groupsInclude<ExtArgs> | null
    where?: study_groupsWhereInput
  }

  /**
   * test_assignments.student
   */
  export type test_assignments$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * test_assignments without action
   */
  export type test_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_assignments
     */
    select?: test_assignmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_assignmentsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Exam_boardsScalarFieldEnum: {
    board_id: 'board_id',
    board_name: 'board_name',
    description: 'description',
    input_type: 'input_type'
  };

  export type Exam_boardsScalarFieldEnum = (typeof Exam_boardsScalarFieldEnum)[keyof typeof Exam_boardsScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    question_id: 'question_id',
    subtopic_id: 'subtopic_id',
    question_text: 'question_text',
    question_text_plain: 'question_text_plain',
    options: 'options',
    correct_answer: 'correct_answer',
    correct_answer_plain: 'correct_answer_plain',
    solution: 'solution',
    solution_plain: 'solution_plain',
    difficulty_level: 'difficulty_level',
    created_at: 'created_at',
    created_by: 'created_by',
    active: 'active'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const Question_set_itemsScalarFieldEnum: {
    item_id: 'item_id',
    set_id: 'set_id',
    question_id: 'question_id',
    sequence: 'sequence',
    created_at: 'created_at'
  };

  export type Question_set_itemsScalarFieldEnum = (typeof Question_set_itemsScalarFieldEnum)[keyof typeof Question_set_itemsScalarFieldEnum]


  export const Question_setsScalarFieldEnum: {
    set_id: 'set_id',
    name: 'name',
    description: 'description',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    active: 'active',
    metadata: 'metadata'
  };

  export type Question_setsScalarFieldEnum = (typeof Question_setsScalarFieldEnum)[keyof typeof Question_setsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name',
    description: 'description'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    subject_id: 'subject_id',
    subject_name: 'subject_name',
    description: 'description'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const SubtopicsScalarFieldEnum: {
    subtopic_id: 'subtopic_id',
    topic_id: 'topic_id',
    subtopic_name: 'subtopic_name',
    description: 'description'
  };

  export type SubtopicsScalarFieldEnum = (typeof SubtopicsScalarFieldEnum)[keyof typeof SubtopicsScalarFieldEnum]


  export const Test_executionsScalarFieldEnum: {
    execution_id: 'execution_id',
    test_plan_id: 'test_plan_id',
    student_id: 'student_id',
    status: 'status',
    started_at: 'started_at',
    completed_at: 'completed_at',
    test_data: 'test_data',
    score: 'score'
  };

  export type Test_executionsScalarFieldEnum = (typeof Test_executionsScalarFieldEnum)[keyof typeof Test_executionsScalarFieldEnum]


  export const Test_plan_question_setsScalarFieldEnum: {
    link_id: 'link_id',
    test_plan_id: 'test_plan_id',
    set_id: 'set_id',
    sequence: 'sequence',
    created_at: 'created_at'
  };

  export type Test_plan_question_setsScalarFieldEnum = (typeof Test_plan_question_setsScalarFieldEnum)[keyof typeof Test_plan_question_setsScalarFieldEnum]


  export const Test_plansScalarFieldEnum: {
    test_plan_id: 'test_plan_id',
    template_id: 'template_id',
    board_id: 'board_id',
    test_type: 'test_type',
    timing_type: 'timing_type',
    time_limit: 'time_limit',
    student_id: 'student_id',
    planned_by: 'planned_by',
    planned_at: 'planned_at',
    configuration: 'configuration'
  };

  export type Test_plansScalarFieldEnum = (typeof Test_plansScalarFieldEnum)[keyof typeof Test_plansScalarFieldEnum]


  export const Test_templatesScalarFieldEnum: {
    template_id: 'template_id',
    template_name: 'template_name',
    source: 'source',
    created_by: 'created_by',
    created_at: 'created_at',
    board_id: 'board_id',
    test_type: 'test_type',
    timing_type: 'timing_type',
    time_limit: 'time_limit',
    configuration: 'configuration',
    active: 'active'
  };

  export type Test_templatesScalarFieldEnum = (typeof Test_templatesScalarFieldEnum)[keyof typeof Test_templatesScalarFieldEnum]


  export const TopicsScalarFieldEnum: {
    topic_id: 'topic_id',
    subject_id: 'subject_id',
    topic_name: 'topic_name',
    description: 'description'
  };

  export type TopicsScalarFieldEnum = (typeof TopicsScalarFieldEnum)[keyof typeof TopicsScalarFieldEnum]


  export const User_rolesScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    email: 'email',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    created_at: 'created_at',
    last_login: 'last_login',
    active: 'active'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Difficulty_levelsScalarFieldEnum: {
    level_id: 'level_id',
    level_name: 'level_name',
    level_value: 'level_value',
    subject_id: 'subject_id',
    purpose: 'purpose',
    characteristics: 'characteristics',
    focus_area: 'focus_area',
    steps_required: 'steps_required',
    created_at: 'created_at',
    active: 'active'
  };

  export type Difficulty_levelsScalarFieldEnum = (typeof Difficulty_levelsScalarFieldEnum)[keyof typeof Difficulty_levelsScalarFieldEnum]


  export const Student_progressScalarFieldEnum: {
    user_id: 'user_id',
    level: 'level',
    current_xp: 'current_xp',
    next_level_xp: 'next_level_xp',
    streak_days: 'streak_days',
    last_activity_date: 'last_activity_date',
    total_points: 'total_points',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Student_progressScalarFieldEnum = (typeof Student_progressScalarFieldEnum)[keyof typeof Student_progressScalarFieldEnum]


  export const AchievementsScalarFieldEnum: {
    achievement_id: 'achievement_id',
    title: 'title',
    description: 'description',
    category: 'category',
    points: 'points',
    icon: 'icon',
    required_criteria: 'required_criteria',
    created_at: 'created_at'
  };

  export type AchievementsScalarFieldEnum = (typeof AchievementsScalarFieldEnum)[keyof typeof AchievementsScalarFieldEnum]


  export const Student_achievementsScalarFieldEnum: {
    user_id: 'user_id',
    achievement_id: 'achievement_id',
    unlocked_at: 'unlocked_at',
    progress: 'progress'
  };

  export type Student_achievementsScalarFieldEnum = (typeof Student_achievementsScalarFieldEnum)[keyof typeof Student_achievementsScalarFieldEnum]


  export const RewardsScalarFieldEnum: {
    reward_id: 'reward_id',
    title: 'title',
    description: 'description',
    category: 'category',
    cost: 'cost',
    icon: 'icon',
    created_at: 'created_at'
  };

  export type RewardsScalarFieldEnum = (typeof RewardsScalarFieldEnum)[keyof typeof RewardsScalarFieldEnum]


  export const Student_rewardsScalarFieldEnum: {
    user_id: 'user_id',
    reward_id: 'reward_id',
    purchased_at: 'purchased_at'
  };

  export type Student_rewardsScalarFieldEnum = (typeof Student_rewardsScalarFieldEnum)[keyof typeof Student_rewardsScalarFieldEnum]


  export const Subject_masteryScalarFieldEnum: {
    user_id: 'user_id',
    subject_id: 'subject_id',
    mastery_level: 'mastery_level',
    total_questions_attempted: 'total_questions_attempted',
    correct_answers: 'correct_answers',
    last_test_date: 'last_test_date'
  };

  export type Subject_masteryScalarFieldEnum = (typeof Subject_masteryScalarFieldEnum)[keyof typeof Subject_masteryScalarFieldEnum]


  export const Activity_logScalarFieldEnum: {
    activity_id: 'activity_id',
    user_id: 'user_id',
    activity_type: 'activity_type',
    xp_earned: 'xp_earned',
    details: 'details',
    created_at: 'created_at'
  };

  export type Activity_logScalarFieldEnum = (typeof Activity_logScalarFieldEnum)[keyof typeof Activity_logScalarFieldEnum]


  export const Level_configScalarFieldEnum: {
    level: 'level',
    xp_required: 'xp_required',
    created_at: 'created_at'
  };

  export type Level_configScalarFieldEnum = (typeof Level_configScalarFieldEnum)[keyof typeof Level_configScalarFieldEnum]


  export const Study_groupsScalarFieldEnum: {
    group_id: 'group_id',
    group_name: 'group_name',
    description: 'description',
    tutor_id: 'tutor_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Study_groupsScalarFieldEnum = (typeof Study_groupsScalarFieldEnum)[keyof typeof Study_groupsScalarFieldEnum]


  export const Student_guardiansScalarFieldEnum: {
    relationship_id: 'relationship_id',
    guardian_id: 'guardian_id',
    student_id: 'student_id',
    relationship_type: 'relationship_type',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Student_guardiansScalarFieldEnum = (typeof Student_guardiansScalarFieldEnum)[keyof typeof Student_guardiansScalarFieldEnum]


  export const Group_membersScalarFieldEnum: {
    group_id: 'group_id',
    student_id: 'student_id',
    joined_at: 'joined_at'
  };

  export type Group_membersScalarFieldEnum = (typeof Group_membersScalarFieldEnum)[keyof typeof Group_membersScalarFieldEnum]


  export const Test_assignmentsScalarFieldEnum: {
    assignment_id: 'assignment_id',
    test_plan_id: 'test_plan_id',
    assigned_by: 'assigned_by',
    group_id: 'group_id',
    student_id: 'student_id',
    due_date: 'due_date',
    status: 'status',
    created_at: 'created_at'
  };

  export type Test_assignmentsScalarFieldEnum = (typeof Test_assignmentsScalarFieldEnum)[keyof typeof Test_assignmentsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'exam_boards_input_type'
   */
  export type Enumexam_boards_input_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'exam_boards_input_type'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'test_executions_status'
   */
  export type Enumtest_executions_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_executions_status'>
    


  /**
   * Reference to a field of type 'test_plans_test_type'
   */
  export type Enumtest_plans_test_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_plans_test_type'>
    


  /**
   * Reference to a field of type 'test_plans_timing_type'
   */
  export type Enumtest_plans_timing_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_plans_timing_type'>
    


  /**
   * Reference to a field of type 'test_templates_source'
   */
  export type Enumtest_templates_sourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_templates_source'>
    


  /**
   * Reference to a field of type 'test_templates_test_type'
   */
  export type Enumtest_templates_test_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_templates_test_type'>
    


  /**
   * Reference to a field of type 'test_templates_timing_type'
   */
  export type Enumtest_templates_timing_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_templates_timing_type'>
    


  /**
   * Reference to a field of type 'GuardianRelationType'
   */
  export type EnumGuardianRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuardianRelationType'>
    


  /**
   * Reference to a field of type 'GuardianRelationStatus'
   */
  export type EnumGuardianRelationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuardianRelationStatus'>
    


  /**
   * Reference to a field of type 'TestAssignmentStatus'
   */
  export type EnumTestAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestAssignmentStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type exam_boardsWhereInput = {
    AND?: exam_boardsWhereInput | exam_boardsWhereInput[]
    OR?: exam_boardsWhereInput[]
    NOT?: exam_boardsWhereInput | exam_boardsWhereInput[]
    board_id?: IntFilter<"exam_boards"> | number
    board_name?: StringFilter<"exam_boards"> | string
    description?: StringNullableFilter<"exam_boards"> | string | null
    input_type?: Enumexam_boards_input_typeFilter<"exam_boards"> | $Enums.exam_boards_input_type
    test_plans?: Test_plansListRelationFilter
    test_templates?: Test_templatesListRelationFilter
  }

  export type exam_boardsOrderByWithRelationInput = {
    board_id?: SortOrder
    board_name?: SortOrder
    description?: SortOrderInput | SortOrder
    input_type?: SortOrder
    test_plans?: test_plansOrderByRelationAggregateInput
    test_templates?: test_templatesOrderByRelationAggregateInput
  }

  export type exam_boardsWhereUniqueInput = Prisma.AtLeast<{
    board_id?: number
    board_name?: string
    AND?: exam_boardsWhereInput | exam_boardsWhereInput[]
    OR?: exam_boardsWhereInput[]
    NOT?: exam_boardsWhereInput | exam_boardsWhereInput[]
    description?: StringNullableFilter<"exam_boards"> | string | null
    input_type?: Enumexam_boards_input_typeFilter<"exam_boards"> | $Enums.exam_boards_input_type
    test_plans?: Test_plansListRelationFilter
    test_templates?: Test_templatesListRelationFilter
  }, "board_id" | "board_name">

  export type exam_boardsOrderByWithAggregationInput = {
    board_id?: SortOrder
    board_name?: SortOrder
    description?: SortOrderInput | SortOrder
    input_type?: SortOrder
    _count?: exam_boardsCountOrderByAggregateInput
    _avg?: exam_boardsAvgOrderByAggregateInput
    _max?: exam_boardsMaxOrderByAggregateInput
    _min?: exam_boardsMinOrderByAggregateInput
    _sum?: exam_boardsSumOrderByAggregateInput
  }

  export type exam_boardsScalarWhereWithAggregatesInput = {
    AND?: exam_boardsScalarWhereWithAggregatesInput | exam_boardsScalarWhereWithAggregatesInput[]
    OR?: exam_boardsScalarWhereWithAggregatesInput[]
    NOT?: exam_boardsScalarWhereWithAggregatesInput | exam_boardsScalarWhereWithAggregatesInput[]
    board_id?: IntWithAggregatesFilter<"exam_boards"> | number
    board_name?: StringWithAggregatesFilter<"exam_boards"> | string
    description?: StringNullableWithAggregatesFilter<"exam_boards"> | string | null
    input_type?: Enumexam_boards_input_typeWithAggregatesFilter<"exam_boards"> | $Enums.exam_boards_input_type
  }

  export type questionsWhereInput = {
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    question_id?: BigIntFilter<"questions"> | bigint | number
    subtopic_id?: IntFilter<"questions"> | number
    question_text?: StringFilter<"questions"> | string
    question_text_plain?: StringFilter<"questions"> | string
    options?: StringFilter<"questions"> | string
    correct_answer?: StringFilter<"questions"> | string
    correct_answer_plain?: StringFilter<"questions"> | string
    solution?: StringFilter<"questions"> | string
    solution_plain?: StringFilter<"questions"> | string
    difficulty_level?: IntFilter<"questions"> | number
    created_at?: DateTimeNullableFilter<"questions"> | Date | string | null
    created_by?: BigIntFilter<"questions"> | bigint | number
    active?: BoolNullableFilter<"questions"> | boolean | null
    subtopics?: XOR<SubtopicsRelationFilter, subtopicsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    question_set_items?: Question_set_itemsListRelationFilter
  }

  export type questionsOrderByWithRelationInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    question_text?: SortOrder
    question_text_plain?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    correct_answer_plain?: SortOrder
    solution?: SortOrder
    solution_plain?: SortOrder
    difficulty_level?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    active?: SortOrderInput | SortOrder
    subtopics?: subtopicsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    question_set_items?: question_set_itemsOrderByRelationAggregateInput
  }

  export type questionsWhereUniqueInput = Prisma.AtLeast<{
    question_id?: bigint | number
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    subtopic_id?: IntFilter<"questions"> | number
    question_text?: StringFilter<"questions"> | string
    question_text_plain?: StringFilter<"questions"> | string
    options?: StringFilter<"questions"> | string
    correct_answer?: StringFilter<"questions"> | string
    correct_answer_plain?: StringFilter<"questions"> | string
    solution?: StringFilter<"questions"> | string
    solution_plain?: StringFilter<"questions"> | string
    difficulty_level?: IntFilter<"questions"> | number
    created_at?: DateTimeNullableFilter<"questions"> | Date | string | null
    created_by?: BigIntFilter<"questions"> | bigint | number
    active?: BoolNullableFilter<"questions"> | boolean | null
    subtopics?: XOR<SubtopicsRelationFilter, subtopicsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    question_set_items?: Question_set_itemsListRelationFilter
  }, "question_id">

  export type questionsOrderByWithAggregationInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    question_text?: SortOrder
    question_text_plain?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    correct_answer_plain?: SortOrder
    solution?: SortOrder
    solution_plain?: SortOrder
    difficulty_level?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: questionsCountOrderByAggregateInput
    _avg?: questionsAvgOrderByAggregateInput
    _max?: questionsMaxOrderByAggregateInput
    _min?: questionsMinOrderByAggregateInput
    _sum?: questionsSumOrderByAggregateInput
  }

  export type questionsScalarWhereWithAggregatesInput = {
    AND?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    OR?: questionsScalarWhereWithAggregatesInput[]
    NOT?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    question_id?: BigIntWithAggregatesFilter<"questions"> | bigint | number
    subtopic_id?: IntWithAggregatesFilter<"questions"> | number
    question_text?: StringWithAggregatesFilter<"questions"> | string
    question_text_plain?: StringWithAggregatesFilter<"questions"> | string
    options?: StringWithAggregatesFilter<"questions"> | string
    correct_answer?: StringWithAggregatesFilter<"questions"> | string
    correct_answer_plain?: StringWithAggregatesFilter<"questions"> | string
    solution?: StringWithAggregatesFilter<"questions"> | string
    solution_plain?: StringWithAggregatesFilter<"questions"> | string
    difficulty_level?: IntWithAggregatesFilter<"questions"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"questions"> | Date | string | null
    created_by?: BigIntWithAggregatesFilter<"questions"> | bigint | number
    active?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
  }

  export type question_set_itemsWhereInput = {
    AND?: question_set_itemsWhereInput | question_set_itemsWhereInput[]
    OR?: question_set_itemsWhereInput[]
    NOT?: question_set_itemsWhereInput | question_set_itemsWhereInput[]
    item_id?: BigIntFilter<"question_set_items"> | bigint | number
    set_id?: BigIntFilter<"question_set_items"> | bigint | number
    question_id?: BigIntFilter<"question_set_items"> | bigint | number
    sequence?: IntFilter<"question_set_items"> | number
    created_at?: DateTimeFilter<"question_set_items"> | Date | string
    question_set?: XOR<Question_setsRelationFilter, question_setsWhereInput>
    question?: XOR<QuestionsRelationFilter, questionsWhereInput>
  }

  export type question_set_itemsOrderByWithRelationInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
    question_set?: question_setsOrderByWithRelationInput
    question?: questionsOrderByWithRelationInput
  }

  export type question_set_itemsWhereUniqueInput = Prisma.AtLeast<{
    item_id?: bigint | number
    AND?: question_set_itemsWhereInput | question_set_itemsWhereInput[]
    OR?: question_set_itemsWhereInput[]
    NOT?: question_set_itemsWhereInput | question_set_itemsWhereInput[]
    set_id?: BigIntFilter<"question_set_items"> | bigint | number
    question_id?: BigIntFilter<"question_set_items"> | bigint | number
    sequence?: IntFilter<"question_set_items"> | number
    created_at?: DateTimeFilter<"question_set_items"> | Date | string
    question_set?: XOR<Question_setsRelationFilter, question_setsWhereInput>
    question?: XOR<QuestionsRelationFilter, questionsWhereInput>
  }, "item_id">

  export type question_set_itemsOrderByWithAggregationInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
    _count?: question_set_itemsCountOrderByAggregateInput
    _avg?: question_set_itemsAvgOrderByAggregateInput
    _max?: question_set_itemsMaxOrderByAggregateInput
    _min?: question_set_itemsMinOrderByAggregateInput
    _sum?: question_set_itemsSumOrderByAggregateInput
  }

  export type question_set_itemsScalarWhereWithAggregatesInput = {
    AND?: question_set_itemsScalarWhereWithAggregatesInput | question_set_itemsScalarWhereWithAggregatesInput[]
    OR?: question_set_itemsScalarWhereWithAggregatesInput[]
    NOT?: question_set_itemsScalarWhereWithAggregatesInput | question_set_itemsScalarWhereWithAggregatesInput[]
    item_id?: BigIntWithAggregatesFilter<"question_set_items"> | bigint | number
    set_id?: BigIntWithAggregatesFilter<"question_set_items"> | bigint | number
    question_id?: BigIntWithAggregatesFilter<"question_set_items"> | bigint | number
    sequence?: IntWithAggregatesFilter<"question_set_items"> | number
    created_at?: DateTimeWithAggregatesFilter<"question_set_items"> | Date | string
  }

  export type question_setsWhereInput = {
    AND?: question_setsWhereInput | question_setsWhereInput[]
    OR?: question_setsWhereInput[]
    NOT?: question_setsWhereInput | question_setsWhereInput[]
    set_id?: BigIntFilter<"question_sets"> | bigint | number
    name?: StringFilter<"question_sets"> | string
    description?: StringNullableFilter<"question_sets"> | string | null
    created_by?: BigIntFilter<"question_sets"> | bigint | number
    created_at?: DateTimeFilter<"question_sets"> | Date | string
    updated_at?: DateTimeFilter<"question_sets"> | Date | string
    active?: BoolFilter<"question_sets"> | boolean
    metadata?: StringNullableFilter<"question_sets"> | string | null
    creator?: XOR<UsersRelationFilter, usersWhereInput>
    question_set_items?: Question_set_itemsListRelationFilter
    test_plan_links?: Test_plan_question_setsListRelationFilter
  }

  export type question_setsOrderByWithRelationInput = {
    set_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    creator?: usersOrderByWithRelationInput
    question_set_items?: question_set_itemsOrderByRelationAggregateInput
    test_plan_links?: test_plan_question_setsOrderByRelationAggregateInput
  }

  export type question_setsWhereUniqueInput = Prisma.AtLeast<{
    set_id?: bigint | number
    AND?: question_setsWhereInput | question_setsWhereInput[]
    OR?: question_setsWhereInput[]
    NOT?: question_setsWhereInput | question_setsWhereInput[]
    name?: StringFilter<"question_sets"> | string
    description?: StringNullableFilter<"question_sets"> | string | null
    created_by?: BigIntFilter<"question_sets"> | bigint | number
    created_at?: DateTimeFilter<"question_sets"> | Date | string
    updated_at?: DateTimeFilter<"question_sets"> | Date | string
    active?: BoolFilter<"question_sets"> | boolean
    metadata?: StringNullableFilter<"question_sets"> | string | null
    creator?: XOR<UsersRelationFilter, usersWhereInput>
    question_set_items?: Question_set_itemsListRelationFilter
    test_plan_links?: Test_plan_question_setsListRelationFilter
  }, "set_id">

  export type question_setsOrderByWithAggregationInput = {
    set_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: question_setsCountOrderByAggregateInput
    _avg?: question_setsAvgOrderByAggregateInput
    _max?: question_setsMaxOrderByAggregateInput
    _min?: question_setsMinOrderByAggregateInput
    _sum?: question_setsSumOrderByAggregateInput
  }

  export type question_setsScalarWhereWithAggregatesInput = {
    AND?: question_setsScalarWhereWithAggregatesInput | question_setsScalarWhereWithAggregatesInput[]
    OR?: question_setsScalarWhereWithAggregatesInput[]
    NOT?: question_setsScalarWhereWithAggregatesInput | question_setsScalarWhereWithAggregatesInput[]
    set_id?: BigIntWithAggregatesFilter<"question_sets"> | bigint | number
    name?: StringWithAggregatesFilter<"question_sets"> | string
    description?: StringNullableWithAggregatesFilter<"question_sets"> | string | null
    created_by?: BigIntWithAggregatesFilter<"question_sets"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"question_sets"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"question_sets"> | Date | string
    active?: BoolWithAggregatesFilter<"question_sets"> | boolean
    metadata?: StringNullableWithAggregatesFilter<"question_sets"> | string | null
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    role_id?: IntFilter<"roles"> | number
    role_name?: StringFilter<"roles"> | string
    description?: StringNullableFilter<"roles"> | string | null
    user_roles?: User_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrderInput | SortOrder
    user_roles?: user_rolesOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    role_name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    description?: StringNullableFilter<"roles"> | string | null
    user_roles?: User_rolesListRelationFilter
  }, "role_id" | "role_name">

  export type rolesOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"roles"> | number
    role_name?: StringWithAggregatesFilter<"roles"> | string
    description?: StringNullableWithAggregatesFilter<"roles"> | string | null
  }

  export type subjectsWhereInput = {
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    subject_id?: IntFilter<"subjects"> | number
    subject_name?: StringFilter<"subjects"> | string
    description?: StringNullableFilter<"subjects"> | string | null
    topics?: TopicsListRelationFilter
    subject_mastery?: Subject_masteryListRelationFilter
    difficulty_levels?: Difficulty_levelsListRelationFilter
  }

  export type subjectsOrderByWithRelationInput = {
    subject_id?: SortOrder
    subject_name?: SortOrder
    description?: SortOrderInput | SortOrder
    topics?: topicsOrderByRelationAggregateInput
    subject_mastery?: subject_masteryOrderByRelationAggregateInput
    difficulty_levels?: difficulty_levelsOrderByRelationAggregateInput
  }

  export type subjectsWhereUniqueInput = Prisma.AtLeast<{
    subject_id?: number
    subject_name?: string
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    description?: StringNullableFilter<"subjects"> | string | null
    topics?: TopicsListRelationFilter
    subject_mastery?: Subject_masteryListRelationFilter
    difficulty_levels?: Difficulty_levelsListRelationFilter
  }, "subject_id" | "subject_name">

  export type subjectsOrderByWithAggregationInput = {
    subject_id?: SortOrder
    subject_name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: subjectsCountOrderByAggregateInput
    _avg?: subjectsAvgOrderByAggregateInput
    _max?: subjectsMaxOrderByAggregateInput
    _min?: subjectsMinOrderByAggregateInput
    _sum?: subjectsSumOrderByAggregateInput
  }

  export type subjectsScalarWhereWithAggregatesInput = {
    AND?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    OR?: subjectsScalarWhereWithAggregatesInput[]
    NOT?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    subject_id?: IntWithAggregatesFilter<"subjects"> | number
    subject_name?: StringWithAggregatesFilter<"subjects"> | string
    description?: StringNullableWithAggregatesFilter<"subjects"> | string | null
  }

  export type subtopicsWhereInput = {
    AND?: subtopicsWhereInput | subtopicsWhereInput[]
    OR?: subtopicsWhereInput[]
    NOT?: subtopicsWhereInput | subtopicsWhereInput[]
    subtopic_id?: IntFilter<"subtopics"> | number
    topic_id?: IntFilter<"subtopics"> | number
    subtopic_name?: StringFilter<"subtopics"> | string
    description?: StringNullableFilter<"subtopics"> | string | null
    questions?: QuestionsListRelationFilter
    topics?: XOR<TopicsRelationFilter, topicsWhereInput>
  }

  export type subtopicsOrderByWithRelationInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
    subtopic_name?: SortOrder
    description?: SortOrderInput | SortOrder
    questions?: questionsOrderByRelationAggregateInput
    topics?: topicsOrderByWithRelationInput
  }

  export type subtopicsWhereUniqueInput = Prisma.AtLeast<{
    subtopic_id?: number
    topic_id_subtopic_name?: subtopicsTopic_idSubtopic_nameCompoundUniqueInput
    AND?: subtopicsWhereInput | subtopicsWhereInput[]
    OR?: subtopicsWhereInput[]
    NOT?: subtopicsWhereInput | subtopicsWhereInput[]
    topic_id?: IntFilter<"subtopics"> | number
    subtopic_name?: StringFilter<"subtopics"> | string
    description?: StringNullableFilter<"subtopics"> | string | null
    questions?: QuestionsListRelationFilter
    topics?: XOR<TopicsRelationFilter, topicsWhereInput>
  }, "subtopic_id" | "topic_id_subtopic_name">

  export type subtopicsOrderByWithAggregationInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
    subtopic_name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: subtopicsCountOrderByAggregateInput
    _avg?: subtopicsAvgOrderByAggregateInput
    _max?: subtopicsMaxOrderByAggregateInput
    _min?: subtopicsMinOrderByAggregateInput
    _sum?: subtopicsSumOrderByAggregateInput
  }

  export type subtopicsScalarWhereWithAggregatesInput = {
    AND?: subtopicsScalarWhereWithAggregatesInput | subtopicsScalarWhereWithAggregatesInput[]
    OR?: subtopicsScalarWhereWithAggregatesInput[]
    NOT?: subtopicsScalarWhereWithAggregatesInput | subtopicsScalarWhereWithAggregatesInput[]
    subtopic_id?: IntWithAggregatesFilter<"subtopics"> | number
    topic_id?: IntWithAggregatesFilter<"subtopics"> | number
    subtopic_name?: StringWithAggregatesFilter<"subtopics"> | string
    description?: StringNullableWithAggregatesFilter<"subtopics"> | string | null
  }

  export type test_executionsWhereInput = {
    AND?: test_executionsWhereInput | test_executionsWhereInput[]
    OR?: test_executionsWhereInput[]
    NOT?: test_executionsWhereInput | test_executionsWhereInput[]
    execution_id?: BigIntFilter<"test_executions"> | bigint | number
    test_plan_id?: BigIntFilter<"test_executions"> | bigint | number
    student_id?: BigIntFilter<"test_executions"> | bigint | number
    status?: Enumtest_executions_statusFilter<"test_executions"> | $Enums.test_executions_status
    started_at?: DateTimeNullableFilter<"test_executions"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"test_executions"> | Date | string | null
    test_data?: StringFilter<"test_executions"> | string
    score?: IntNullableFilter<"test_executions"> | number | null
    test_plans?: XOR<Test_plansRelationFilter, test_plansWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type test_executionsOrderByWithRelationInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    test_data?: SortOrder
    score?: SortOrderInput | SortOrder
    test_plans?: test_plansOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type test_executionsWhereUniqueInput = Prisma.AtLeast<{
    execution_id?: bigint | number
    AND?: test_executionsWhereInput | test_executionsWhereInput[]
    OR?: test_executionsWhereInput[]
    NOT?: test_executionsWhereInput | test_executionsWhereInput[]
    test_plan_id?: BigIntFilter<"test_executions"> | bigint | number
    student_id?: BigIntFilter<"test_executions"> | bigint | number
    status?: Enumtest_executions_statusFilter<"test_executions"> | $Enums.test_executions_status
    started_at?: DateTimeNullableFilter<"test_executions"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"test_executions"> | Date | string | null
    test_data?: StringFilter<"test_executions"> | string
    score?: IntNullableFilter<"test_executions"> | number | null
    test_plans?: XOR<Test_plansRelationFilter, test_plansWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "execution_id">

  export type test_executionsOrderByWithAggregationInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    test_data?: SortOrder
    score?: SortOrderInput | SortOrder
    _count?: test_executionsCountOrderByAggregateInput
    _avg?: test_executionsAvgOrderByAggregateInput
    _max?: test_executionsMaxOrderByAggregateInput
    _min?: test_executionsMinOrderByAggregateInput
    _sum?: test_executionsSumOrderByAggregateInput
  }

  export type test_executionsScalarWhereWithAggregatesInput = {
    AND?: test_executionsScalarWhereWithAggregatesInput | test_executionsScalarWhereWithAggregatesInput[]
    OR?: test_executionsScalarWhereWithAggregatesInput[]
    NOT?: test_executionsScalarWhereWithAggregatesInput | test_executionsScalarWhereWithAggregatesInput[]
    execution_id?: BigIntWithAggregatesFilter<"test_executions"> | bigint | number
    test_plan_id?: BigIntWithAggregatesFilter<"test_executions"> | bigint | number
    student_id?: BigIntWithAggregatesFilter<"test_executions"> | bigint | number
    status?: Enumtest_executions_statusWithAggregatesFilter<"test_executions"> | $Enums.test_executions_status
    started_at?: DateTimeNullableWithAggregatesFilter<"test_executions"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"test_executions"> | Date | string | null
    test_data?: StringWithAggregatesFilter<"test_executions"> | string
    score?: IntNullableWithAggregatesFilter<"test_executions"> | number | null
  }

  export type test_plan_question_setsWhereInput = {
    AND?: test_plan_question_setsWhereInput | test_plan_question_setsWhereInput[]
    OR?: test_plan_question_setsWhereInput[]
    NOT?: test_plan_question_setsWhereInput | test_plan_question_setsWhereInput[]
    link_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    test_plan_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    set_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    sequence?: IntFilter<"test_plan_question_sets"> | number
    created_at?: DateTimeFilter<"test_plan_question_sets"> | Date | string
    test_plan?: XOR<Test_plansRelationFilter, test_plansWhereInput>
    question_set?: XOR<Question_setsRelationFilter, question_setsWhereInput>
  }

  export type test_plan_question_setsOrderByWithRelationInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
    test_plan?: test_plansOrderByWithRelationInput
    question_set?: question_setsOrderByWithRelationInput
  }

  export type test_plan_question_setsWhereUniqueInput = Prisma.AtLeast<{
    link_id?: bigint | number
    AND?: test_plan_question_setsWhereInput | test_plan_question_setsWhereInput[]
    OR?: test_plan_question_setsWhereInput[]
    NOT?: test_plan_question_setsWhereInput | test_plan_question_setsWhereInput[]
    test_plan_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    set_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    sequence?: IntFilter<"test_plan_question_sets"> | number
    created_at?: DateTimeFilter<"test_plan_question_sets"> | Date | string
    test_plan?: XOR<Test_plansRelationFilter, test_plansWhereInput>
    question_set?: XOR<Question_setsRelationFilter, question_setsWhereInput>
  }, "link_id">

  export type test_plan_question_setsOrderByWithAggregationInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
    _count?: test_plan_question_setsCountOrderByAggregateInput
    _avg?: test_plan_question_setsAvgOrderByAggregateInput
    _max?: test_plan_question_setsMaxOrderByAggregateInput
    _min?: test_plan_question_setsMinOrderByAggregateInput
    _sum?: test_plan_question_setsSumOrderByAggregateInput
  }

  export type test_plan_question_setsScalarWhereWithAggregatesInput = {
    AND?: test_plan_question_setsScalarWhereWithAggregatesInput | test_plan_question_setsScalarWhereWithAggregatesInput[]
    OR?: test_plan_question_setsScalarWhereWithAggregatesInput[]
    NOT?: test_plan_question_setsScalarWhereWithAggregatesInput | test_plan_question_setsScalarWhereWithAggregatesInput[]
    link_id?: BigIntWithAggregatesFilter<"test_plan_question_sets"> | bigint | number
    test_plan_id?: BigIntWithAggregatesFilter<"test_plan_question_sets"> | bigint | number
    set_id?: BigIntWithAggregatesFilter<"test_plan_question_sets"> | bigint | number
    sequence?: IntWithAggregatesFilter<"test_plan_question_sets"> | number
    created_at?: DateTimeWithAggregatesFilter<"test_plan_question_sets"> | Date | string
  }

  export type test_plansWhereInput = {
    AND?: test_plansWhereInput | test_plansWhereInput[]
    OR?: test_plansWhereInput[]
    NOT?: test_plansWhereInput | test_plansWhereInput[]
    test_plan_id?: BigIntFilter<"test_plans"> | bigint | number
    template_id?: BigIntNullableFilter<"test_plans"> | bigint | number | null
    board_id?: IntFilter<"test_plans"> | number
    test_type?: Enumtest_plans_test_typeFilter<"test_plans"> | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFilter<"test_plans"> | $Enums.test_plans_timing_type
    time_limit?: IntNullableFilter<"test_plans"> | number | null
    student_id?: BigIntFilter<"test_plans"> | bigint | number
    planned_by?: BigIntFilter<"test_plans"> | bigint | number
    planned_at?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    configuration?: StringFilter<"test_plans"> | string
    test_executions?: Test_executionsListRelationFilter
    test_templates?: XOR<Test_templatesNullableRelationFilter, test_templatesWhereInput> | null
    exam_boards?: XOR<Exam_boardsRelationFilter, exam_boardsWhereInput>
    student?: XOR<UsersRelationFilter, usersWhereInput>
    planner?: XOR<UsersRelationFilter, usersWhereInput>
    study_groups?: Study_groupsListRelationFilter
    assignments?: Test_assignmentsListRelationFilter
    question_set_links?: Test_plan_question_setsListRelationFilter
  }

  export type test_plansOrderByWithRelationInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrderInput | SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrderInput | SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
    planned_at?: SortOrderInput | SortOrder
    configuration?: SortOrder
    test_executions?: test_executionsOrderByRelationAggregateInput
    test_templates?: test_templatesOrderByWithRelationInput
    exam_boards?: exam_boardsOrderByWithRelationInput
    student?: usersOrderByWithRelationInput
    planner?: usersOrderByWithRelationInput
    study_groups?: study_groupsOrderByRelationAggregateInput
    assignments?: test_assignmentsOrderByRelationAggregateInput
    question_set_links?: test_plan_question_setsOrderByRelationAggregateInput
  }

  export type test_plansWhereUniqueInput = Prisma.AtLeast<{
    test_plan_id?: bigint | number
    AND?: test_plansWhereInput | test_plansWhereInput[]
    OR?: test_plansWhereInput[]
    NOT?: test_plansWhereInput | test_plansWhereInput[]
    template_id?: BigIntNullableFilter<"test_plans"> | bigint | number | null
    board_id?: IntFilter<"test_plans"> | number
    test_type?: Enumtest_plans_test_typeFilter<"test_plans"> | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFilter<"test_plans"> | $Enums.test_plans_timing_type
    time_limit?: IntNullableFilter<"test_plans"> | number | null
    student_id?: BigIntFilter<"test_plans"> | bigint | number
    planned_by?: BigIntFilter<"test_plans"> | bigint | number
    planned_at?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    configuration?: StringFilter<"test_plans"> | string
    test_executions?: Test_executionsListRelationFilter
    test_templates?: XOR<Test_templatesNullableRelationFilter, test_templatesWhereInput> | null
    exam_boards?: XOR<Exam_boardsRelationFilter, exam_boardsWhereInput>
    student?: XOR<UsersRelationFilter, usersWhereInput>
    planner?: XOR<UsersRelationFilter, usersWhereInput>
    study_groups?: Study_groupsListRelationFilter
    assignments?: Test_assignmentsListRelationFilter
    question_set_links?: Test_plan_question_setsListRelationFilter
  }, "test_plan_id">

  export type test_plansOrderByWithAggregationInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrderInput | SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrderInput | SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
    planned_at?: SortOrderInput | SortOrder
    configuration?: SortOrder
    _count?: test_plansCountOrderByAggregateInput
    _avg?: test_plansAvgOrderByAggregateInput
    _max?: test_plansMaxOrderByAggregateInput
    _min?: test_plansMinOrderByAggregateInput
    _sum?: test_plansSumOrderByAggregateInput
  }

  export type test_plansScalarWhereWithAggregatesInput = {
    AND?: test_plansScalarWhereWithAggregatesInput | test_plansScalarWhereWithAggregatesInput[]
    OR?: test_plansScalarWhereWithAggregatesInput[]
    NOT?: test_plansScalarWhereWithAggregatesInput | test_plansScalarWhereWithAggregatesInput[]
    test_plan_id?: BigIntWithAggregatesFilter<"test_plans"> | bigint | number
    template_id?: BigIntNullableWithAggregatesFilter<"test_plans"> | bigint | number | null
    board_id?: IntWithAggregatesFilter<"test_plans"> | number
    test_type?: Enumtest_plans_test_typeWithAggregatesFilter<"test_plans"> | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeWithAggregatesFilter<"test_plans"> | $Enums.test_plans_timing_type
    time_limit?: IntNullableWithAggregatesFilter<"test_plans"> | number | null
    student_id?: BigIntWithAggregatesFilter<"test_plans"> | bigint | number
    planned_by?: BigIntWithAggregatesFilter<"test_plans"> | bigint | number
    planned_at?: DateTimeNullableWithAggregatesFilter<"test_plans"> | Date | string | null
    configuration?: StringWithAggregatesFilter<"test_plans"> | string
  }

  export type test_templatesWhereInput = {
    AND?: test_templatesWhereInput | test_templatesWhereInput[]
    OR?: test_templatesWhereInput[]
    NOT?: test_templatesWhereInput | test_templatesWhereInput[]
    template_id?: BigIntFilter<"test_templates"> | bigint | number
    template_name?: StringFilter<"test_templates"> | string
    source?: Enumtest_templates_sourceFilter<"test_templates"> | $Enums.test_templates_source
    created_by?: BigIntFilter<"test_templates"> | bigint | number
    created_at?: DateTimeNullableFilter<"test_templates"> | Date | string | null
    board_id?: IntFilter<"test_templates"> | number
    test_type?: Enumtest_templates_test_typeFilter<"test_templates"> | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFilter<"test_templates"> | $Enums.test_templates_timing_type
    time_limit?: IntNullableFilter<"test_templates"> | number | null
    configuration?: StringFilter<"test_templates"> | string
    active?: BoolNullableFilter<"test_templates"> | boolean | null
    test_plans?: Test_plansListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
    exam_boards?: XOR<Exam_boardsRelationFilter, exam_boardsWhereInput>
  }

  export type test_templatesOrderByWithRelationInput = {
    template_id?: SortOrder
    template_name?: SortOrder
    source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrderInput | SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrderInput | SortOrder
    configuration?: SortOrder
    active?: SortOrderInput | SortOrder
    test_plans?: test_plansOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    exam_boards?: exam_boardsOrderByWithRelationInput
  }

  export type test_templatesWhereUniqueInput = Prisma.AtLeast<{
    template_id?: bigint | number
    AND?: test_templatesWhereInput | test_templatesWhereInput[]
    OR?: test_templatesWhereInput[]
    NOT?: test_templatesWhereInput | test_templatesWhereInput[]
    template_name?: StringFilter<"test_templates"> | string
    source?: Enumtest_templates_sourceFilter<"test_templates"> | $Enums.test_templates_source
    created_by?: BigIntFilter<"test_templates"> | bigint | number
    created_at?: DateTimeNullableFilter<"test_templates"> | Date | string | null
    board_id?: IntFilter<"test_templates"> | number
    test_type?: Enumtest_templates_test_typeFilter<"test_templates"> | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFilter<"test_templates"> | $Enums.test_templates_timing_type
    time_limit?: IntNullableFilter<"test_templates"> | number | null
    configuration?: StringFilter<"test_templates"> | string
    active?: BoolNullableFilter<"test_templates"> | boolean | null
    test_plans?: Test_plansListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
    exam_boards?: XOR<Exam_boardsRelationFilter, exam_boardsWhereInput>
  }, "template_id">

  export type test_templatesOrderByWithAggregationInput = {
    template_id?: SortOrder
    template_name?: SortOrder
    source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrderInput | SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrderInput | SortOrder
    configuration?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: test_templatesCountOrderByAggregateInput
    _avg?: test_templatesAvgOrderByAggregateInput
    _max?: test_templatesMaxOrderByAggregateInput
    _min?: test_templatesMinOrderByAggregateInput
    _sum?: test_templatesSumOrderByAggregateInput
  }

  export type test_templatesScalarWhereWithAggregatesInput = {
    AND?: test_templatesScalarWhereWithAggregatesInput | test_templatesScalarWhereWithAggregatesInput[]
    OR?: test_templatesScalarWhereWithAggregatesInput[]
    NOT?: test_templatesScalarWhereWithAggregatesInput | test_templatesScalarWhereWithAggregatesInput[]
    template_id?: BigIntWithAggregatesFilter<"test_templates"> | bigint | number
    template_name?: StringWithAggregatesFilter<"test_templates"> | string
    source?: Enumtest_templates_sourceWithAggregatesFilter<"test_templates"> | $Enums.test_templates_source
    created_by?: BigIntWithAggregatesFilter<"test_templates"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"test_templates"> | Date | string | null
    board_id?: IntWithAggregatesFilter<"test_templates"> | number
    test_type?: Enumtest_templates_test_typeWithAggregatesFilter<"test_templates"> | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeWithAggregatesFilter<"test_templates"> | $Enums.test_templates_timing_type
    time_limit?: IntNullableWithAggregatesFilter<"test_templates"> | number | null
    configuration?: StringWithAggregatesFilter<"test_templates"> | string
    active?: BoolNullableWithAggregatesFilter<"test_templates"> | boolean | null
  }

  export type topicsWhereInput = {
    AND?: topicsWhereInput | topicsWhereInput[]
    OR?: topicsWhereInput[]
    NOT?: topicsWhereInput | topicsWhereInput[]
    topic_id?: IntFilter<"topics"> | number
    subject_id?: IntFilter<"topics"> | number
    topic_name?: StringFilter<"topics"> | string
    description?: StringNullableFilter<"topics"> | string | null
    subtopics?: SubtopicsListRelationFilter
    subjects?: XOR<SubjectsRelationFilter, subjectsWhereInput>
  }

  export type topicsOrderByWithRelationInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
    topic_name?: SortOrder
    description?: SortOrderInput | SortOrder
    subtopics?: subtopicsOrderByRelationAggregateInput
    subjects?: subjectsOrderByWithRelationInput
  }

  export type topicsWhereUniqueInput = Prisma.AtLeast<{
    topic_id?: number
    subject_id_topic_name?: topicsSubject_idTopic_nameCompoundUniqueInput
    AND?: topicsWhereInput | topicsWhereInput[]
    OR?: topicsWhereInput[]
    NOT?: topicsWhereInput | topicsWhereInput[]
    subject_id?: IntFilter<"topics"> | number
    topic_name?: StringFilter<"topics"> | string
    description?: StringNullableFilter<"topics"> | string | null
    subtopics?: SubtopicsListRelationFilter
    subjects?: XOR<SubjectsRelationFilter, subjectsWhereInput>
  }, "topic_id" | "subject_id_topic_name">

  export type topicsOrderByWithAggregationInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
    topic_name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: topicsCountOrderByAggregateInput
    _avg?: topicsAvgOrderByAggregateInput
    _max?: topicsMaxOrderByAggregateInput
    _min?: topicsMinOrderByAggregateInput
    _sum?: topicsSumOrderByAggregateInput
  }

  export type topicsScalarWhereWithAggregatesInput = {
    AND?: topicsScalarWhereWithAggregatesInput | topicsScalarWhereWithAggregatesInput[]
    OR?: topicsScalarWhereWithAggregatesInput[]
    NOT?: topicsScalarWhereWithAggregatesInput | topicsScalarWhereWithAggregatesInput[]
    topic_id?: IntWithAggregatesFilter<"topics"> | number
    subject_id?: IntWithAggregatesFilter<"topics"> | number
    topic_name?: StringWithAggregatesFilter<"topics"> | string
    description?: StringNullableWithAggregatesFilter<"topics"> | string | null
  }

  export type user_rolesWhereInput = {
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    user_id?: BigIntFilter<"user_roles"> | bigint | number
    role_id?: IntFilter<"user_roles"> | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type user_rolesOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    users?: usersOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{
    user_id_role_id?: user_rolesUser_idRole_idCompoundUniqueInput
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    user_id?: BigIntFilter<"user_roles"> | bigint | number
    role_id?: IntFilter<"user_roles"> | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "user_id_role_id">

  export type user_rolesOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: user_rolesCountOrderByAggregateInput
    _avg?: user_rolesAvgOrderByAggregateInput
    _max?: user_rolesMaxOrderByAggregateInput
    _min?: user_rolesMinOrderByAggregateInput
    _sum?: user_rolesSumOrderByAggregateInput
  }

  export type user_rolesScalarWhereWithAggregatesInput = {
    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    OR?: user_rolesScalarWhereWithAggregatesInput[]
    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"user_roles"> | bigint | number
    role_id?: IntWithAggregatesFilter<"user_roles"> | number
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: BigIntFilter<"users"> | bigint | number
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    last_login?: DateTimeNullableFilter<"users"> | Date | string | null
    active?: BoolFilter<"users"> | boolean
    questions?: QuestionsListRelationFilter
    created_question_sets?: Question_setsListRelationFilter
    test_executions?: Test_executionsListRelationFilter
    assigned_test_plans?: Test_plansListRelationFilter
    planned_test_plans?: Test_plansListRelationFilter
    test_templates?: Test_templatesListRelationFilter
    user_roles?: User_rolesListRelationFilter
    achievements_earned?: Student_achievementsListRelationFilter
    tutor_groups?: Study_groupsListRelationFilter
    student_groups?: Study_groupsListRelationFilter
    group_memberships?: Group_membersListRelationFilter
    subject_mastery?: Subject_masteryListRelationFilter
    student_progress?: XOR<Student_progressNullableRelationFilter, student_progressWhereInput> | null
    activity_logs?: Activity_logListRelationFilter
    student_rewards?: Student_rewardsListRelationFilter
    guardian_relationships?: Student_guardiansListRelationFilter
    student_relationships?: Student_guardiansListRelationFilter
    assignments_created?: Test_assignmentsListRelationFilter
    assignments_received?: Test_assignmentsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrderInput | SortOrder
    active?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
    created_question_sets?: question_setsOrderByRelationAggregateInput
    test_executions?: test_executionsOrderByRelationAggregateInput
    assigned_test_plans?: test_plansOrderByRelationAggregateInput
    planned_test_plans?: test_plansOrderByRelationAggregateInput
    test_templates?: test_templatesOrderByRelationAggregateInput
    user_roles?: user_rolesOrderByRelationAggregateInput
    achievements_earned?: student_achievementsOrderByRelationAggregateInput
    tutor_groups?: study_groupsOrderByRelationAggregateInput
    student_groups?: study_groupsOrderByRelationAggregateInput
    group_memberships?: group_membersOrderByRelationAggregateInput
    subject_mastery?: subject_masteryOrderByRelationAggregateInput
    student_progress?: student_progressOrderByWithRelationInput
    activity_logs?: activity_logOrderByRelationAggregateInput
    student_rewards?: student_rewardsOrderByRelationAggregateInput
    guardian_relationships?: student_guardiansOrderByRelationAggregateInput
    student_relationships?: student_guardiansOrderByRelationAggregateInput
    assignments_created?: test_assignmentsOrderByRelationAggregateInput
    assignments_received?: test_assignmentsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    last_login?: DateTimeNullableFilter<"users"> | Date | string | null
    active?: BoolFilter<"users"> | boolean
    questions?: QuestionsListRelationFilter
    created_question_sets?: Question_setsListRelationFilter
    test_executions?: Test_executionsListRelationFilter
    assigned_test_plans?: Test_plansListRelationFilter
    planned_test_plans?: Test_plansListRelationFilter
    test_templates?: Test_templatesListRelationFilter
    user_roles?: User_rolesListRelationFilter
    achievements_earned?: Student_achievementsListRelationFilter
    tutor_groups?: Study_groupsListRelationFilter
    student_groups?: Study_groupsListRelationFilter
    group_memberships?: Group_membersListRelationFilter
    subject_mastery?: Subject_masteryListRelationFilter
    student_progress?: XOR<Student_progressNullableRelationFilter, student_progressWhereInput> | null
    activity_logs?: Activity_logListRelationFilter
    student_rewards?: Student_rewardsListRelationFilter
    guardian_relationships?: Student_guardiansListRelationFilter
    student_relationships?: Student_guardiansListRelationFilter
    assignments_created?: Test_assignmentsListRelationFilter
    assignments_received?: Test_assignmentsListRelationFilter
  }, "user_id" | "email">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    first_name?: StringWithAggregatesFilter<"users"> | string
    last_name?: StringWithAggregatesFilter<"users"> | string
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    last_login?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    active?: BoolWithAggregatesFilter<"users"> | boolean
  }

  export type difficulty_levelsWhereInput = {
    AND?: difficulty_levelsWhereInput | difficulty_levelsWhereInput[]
    OR?: difficulty_levelsWhereInput[]
    NOT?: difficulty_levelsWhereInput | difficulty_levelsWhereInput[]
    level_id?: IntFilter<"difficulty_levels"> | number
    level_name?: StringFilter<"difficulty_levels"> | string
    level_value?: IntFilter<"difficulty_levels"> | number
    subject_id?: IntFilter<"difficulty_levels"> | number
    purpose?: StringFilter<"difficulty_levels"> | string
    characteristics?: StringFilter<"difficulty_levels"> | string
    focus_area?: StringFilter<"difficulty_levels"> | string
    steps_required?: StringNullableFilter<"difficulty_levels"> | string | null
    created_at?: DateTimeNullableFilter<"difficulty_levels"> | Date | string | null
    active?: BoolNullableFilter<"difficulty_levels"> | boolean | null
    subject?: XOR<SubjectsRelationFilter, subjectsWhereInput>
  }

  export type difficulty_levelsOrderByWithRelationInput = {
    level_id?: SortOrder
    level_name?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
    purpose?: SortOrder
    characteristics?: SortOrder
    focus_area?: SortOrder
    steps_required?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    subject?: subjectsOrderByWithRelationInput
  }

  export type difficulty_levelsWhereUniqueInput = Prisma.AtLeast<{
    level_id?: number
    level_name?: string
    level_value?: number
    AND?: difficulty_levelsWhereInput | difficulty_levelsWhereInput[]
    OR?: difficulty_levelsWhereInput[]
    NOT?: difficulty_levelsWhereInput | difficulty_levelsWhereInput[]
    subject_id?: IntFilter<"difficulty_levels"> | number
    purpose?: StringFilter<"difficulty_levels"> | string
    characteristics?: StringFilter<"difficulty_levels"> | string
    focus_area?: StringFilter<"difficulty_levels"> | string
    steps_required?: StringNullableFilter<"difficulty_levels"> | string | null
    created_at?: DateTimeNullableFilter<"difficulty_levels"> | Date | string | null
    active?: BoolNullableFilter<"difficulty_levels"> | boolean | null
    subject?: XOR<SubjectsRelationFilter, subjectsWhereInput>
  }, "level_id" | "level_name" | "level_value">

  export type difficulty_levelsOrderByWithAggregationInput = {
    level_id?: SortOrder
    level_name?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
    purpose?: SortOrder
    characteristics?: SortOrder
    focus_area?: SortOrder
    steps_required?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    _count?: difficulty_levelsCountOrderByAggregateInput
    _avg?: difficulty_levelsAvgOrderByAggregateInput
    _max?: difficulty_levelsMaxOrderByAggregateInput
    _min?: difficulty_levelsMinOrderByAggregateInput
    _sum?: difficulty_levelsSumOrderByAggregateInput
  }

  export type difficulty_levelsScalarWhereWithAggregatesInput = {
    AND?: difficulty_levelsScalarWhereWithAggregatesInput | difficulty_levelsScalarWhereWithAggregatesInput[]
    OR?: difficulty_levelsScalarWhereWithAggregatesInput[]
    NOT?: difficulty_levelsScalarWhereWithAggregatesInput | difficulty_levelsScalarWhereWithAggregatesInput[]
    level_id?: IntWithAggregatesFilter<"difficulty_levels"> | number
    level_name?: StringWithAggregatesFilter<"difficulty_levels"> | string
    level_value?: IntWithAggregatesFilter<"difficulty_levels"> | number
    subject_id?: IntWithAggregatesFilter<"difficulty_levels"> | number
    purpose?: StringWithAggregatesFilter<"difficulty_levels"> | string
    characteristics?: StringWithAggregatesFilter<"difficulty_levels"> | string
    focus_area?: StringWithAggregatesFilter<"difficulty_levels"> | string
    steps_required?: StringNullableWithAggregatesFilter<"difficulty_levels"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"difficulty_levels"> | Date | string | null
    active?: BoolNullableWithAggregatesFilter<"difficulty_levels"> | boolean | null
  }

  export type student_progressWhereInput = {
    AND?: student_progressWhereInput | student_progressWhereInput[]
    OR?: student_progressWhereInput[]
    NOT?: student_progressWhereInput | student_progressWhereInput[]
    user_id?: BigIntFilter<"student_progress"> | bigint | number
    level?: IntFilter<"student_progress"> | number
    current_xp?: IntFilter<"student_progress"> | number
    next_level_xp?: IntFilter<"student_progress"> | number
    streak_days?: IntFilter<"student_progress"> | number
    last_activity_date?: DateTimeNullableFilter<"student_progress"> | Date | string | null
    total_points?: IntFilter<"student_progress"> | number
    created_at?: DateTimeNullableFilter<"student_progress"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_progress"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type student_progressOrderByWithRelationInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    last_activity_date?: SortOrderInput | SortOrder
    total_points?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type student_progressWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    AND?: student_progressWhereInput | student_progressWhereInput[]
    OR?: student_progressWhereInput[]
    NOT?: student_progressWhereInput | student_progressWhereInput[]
    level?: IntFilter<"student_progress"> | number
    current_xp?: IntFilter<"student_progress"> | number
    next_level_xp?: IntFilter<"student_progress"> | number
    streak_days?: IntFilter<"student_progress"> | number
    last_activity_date?: DateTimeNullableFilter<"student_progress"> | Date | string | null
    total_points?: IntFilter<"student_progress"> | number
    created_at?: DateTimeNullableFilter<"student_progress"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_progress"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "user_id">

  export type student_progressOrderByWithAggregationInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    last_activity_date?: SortOrderInput | SortOrder
    total_points?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: student_progressCountOrderByAggregateInput
    _avg?: student_progressAvgOrderByAggregateInput
    _max?: student_progressMaxOrderByAggregateInput
    _min?: student_progressMinOrderByAggregateInput
    _sum?: student_progressSumOrderByAggregateInput
  }

  export type student_progressScalarWhereWithAggregatesInput = {
    AND?: student_progressScalarWhereWithAggregatesInput | student_progressScalarWhereWithAggregatesInput[]
    OR?: student_progressScalarWhereWithAggregatesInput[]
    NOT?: student_progressScalarWhereWithAggregatesInput | student_progressScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"student_progress"> | bigint | number
    level?: IntWithAggregatesFilter<"student_progress"> | number
    current_xp?: IntWithAggregatesFilter<"student_progress"> | number
    next_level_xp?: IntWithAggregatesFilter<"student_progress"> | number
    streak_days?: IntWithAggregatesFilter<"student_progress"> | number
    last_activity_date?: DateTimeNullableWithAggregatesFilter<"student_progress"> | Date | string | null
    total_points?: IntWithAggregatesFilter<"student_progress"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"student_progress"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"student_progress"> | Date | string | null
  }

  export type achievementsWhereInput = {
    AND?: achievementsWhereInput | achievementsWhereInput[]
    OR?: achievementsWhereInput[]
    NOT?: achievementsWhereInput | achievementsWhereInput[]
    achievement_id?: BigIntFilter<"achievements"> | bigint | number
    title?: StringFilter<"achievements"> | string
    description?: StringFilter<"achievements"> | string
    category?: StringFilter<"achievements"> | string
    points?: IntFilter<"achievements"> | number
    icon?: StringNullableFilter<"achievements"> | string | null
    required_criteria?: StringFilter<"achievements"> | string
    created_at?: DateTimeNullableFilter<"achievements"> | Date | string | null
    student_achievements?: Student_achievementsListRelationFilter
  }

  export type achievementsOrderByWithRelationInput = {
    achievement_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    icon?: SortOrderInput | SortOrder
    required_criteria?: SortOrder
    created_at?: SortOrderInput | SortOrder
    student_achievements?: student_achievementsOrderByRelationAggregateInput
  }

  export type achievementsWhereUniqueInput = Prisma.AtLeast<{
    achievement_id?: bigint | number
    AND?: achievementsWhereInput | achievementsWhereInput[]
    OR?: achievementsWhereInput[]
    NOT?: achievementsWhereInput | achievementsWhereInput[]
    title?: StringFilter<"achievements"> | string
    description?: StringFilter<"achievements"> | string
    category?: StringFilter<"achievements"> | string
    points?: IntFilter<"achievements"> | number
    icon?: StringNullableFilter<"achievements"> | string | null
    required_criteria?: StringFilter<"achievements"> | string
    created_at?: DateTimeNullableFilter<"achievements"> | Date | string | null
    student_achievements?: Student_achievementsListRelationFilter
  }, "achievement_id">

  export type achievementsOrderByWithAggregationInput = {
    achievement_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    icon?: SortOrderInput | SortOrder
    required_criteria?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: achievementsCountOrderByAggregateInput
    _avg?: achievementsAvgOrderByAggregateInput
    _max?: achievementsMaxOrderByAggregateInput
    _min?: achievementsMinOrderByAggregateInput
    _sum?: achievementsSumOrderByAggregateInput
  }

  export type achievementsScalarWhereWithAggregatesInput = {
    AND?: achievementsScalarWhereWithAggregatesInput | achievementsScalarWhereWithAggregatesInput[]
    OR?: achievementsScalarWhereWithAggregatesInput[]
    NOT?: achievementsScalarWhereWithAggregatesInput | achievementsScalarWhereWithAggregatesInput[]
    achievement_id?: BigIntWithAggregatesFilter<"achievements"> | bigint | number
    title?: StringWithAggregatesFilter<"achievements"> | string
    description?: StringWithAggregatesFilter<"achievements"> | string
    category?: StringWithAggregatesFilter<"achievements"> | string
    points?: IntWithAggregatesFilter<"achievements"> | number
    icon?: StringNullableWithAggregatesFilter<"achievements"> | string | null
    required_criteria?: StringWithAggregatesFilter<"achievements"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"achievements"> | Date | string | null
  }

  export type student_achievementsWhereInput = {
    AND?: student_achievementsWhereInput | student_achievementsWhereInput[]
    OR?: student_achievementsWhereInput[]
    NOT?: student_achievementsWhereInput | student_achievementsWhereInput[]
    user_id?: BigIntFilter<"student_achievements"> | bigint | number
    achievement_id?: BigIntFilter<"student_achievements"> | bigint | number
    unlocked_at?: DateTimeNullableFilter<"student_achievements"> | Date | string | null
    progress?: IntFilter<"student_achievements"> | number
    user?: XOR<UsersRelationFilter, usersWhereInput>
    achievements?: XOR<AchievementsRelationFilter, achievementsWhereInput>
  }

  export type student_achievementsOrderByWithRelationInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    unlocked_at?: SortOrderInput | SortOrder
    progress?: SortOrder
    user?: usersOrderByWithRelationInput
    achievements?: achievementsOrderByWithRelationInput
  }

  export type student_achievementsWhereUniqueInput = Prisma.AtLeast<{
    user_id_achievement_id?: student_achievementsUser_idAchievement_idCompoundUniqueInput
    AND?: student_achievementsWhereInput | student_achievementsWhereInput[]
    OR?: student_achievementsWhereInput[]
    NOT?: student_achievementsWhereInput | student_achievementsWhereInput[]
    user_id?: BigIntFilter<"student_achievements"> | bigint | number
    achievement_id?: BigIntFilter<"student_achievements"> | bigint | number
    unlocked_at?: DateTimeNullableFilter<"student_achievements"> | Date | string | null
    progress?: IntFilter<"student_achievements"> | number
    user?: XOR<UsersRelationFilter, usersWhereInput>
    achievements?: XOR<AchievementsRelationFilter, achievementsWhereInput>
  }, "user_id_achievement_id">

  export type student_achievementsOrderByWithAggregationInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    unlocked_at?: SortOrderInput | SortOrder
    progress?: SortOrder
    _count?: student_achievementsCountOrderByAggregateInput
    _avg?: student_achievementsAvgOrderByAggregateInput
    _max?: student_achievementsMaxOrderByAggregateInput
    _min?: student_achievementsMinOrderByAggregateInput
    _sum?: student_achievementsSumOrderByAggregateInput
  }

  export type student_achievementsScalarWhereWithAggregatesInput = {
    AND?: student_achievementsScalarWhereWithAggregatesInput | student_achievementsScalarWhereWithAggregatesInput[]
    OR?: student_achievementsScalarWhereWithAggregatesInput[]
    NOT?: student_achievementsScalarWhereWithAggregatesInput | student_achievementsScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"student_achievements"> | bigint | number
    achievement_id?: BigIntWithAggregatesFilter<"student_achievements"> | bigint | number
    unlocked_at?: DateTimeNullableWithAggregatesFilter<"student_achievements"> | Date | string | null
    progress?: IntWithAggregatesFilter<"student_achievements"> | number
  }

  export type rewardsWhereInput = {
    AND?: rewardsWhereInput | rewardsWhereInput[]
    OR?: rewardsWhereInput[]
    NOT?: rewardsWhereInput | rewardsWhereInput[]
    reward_id?: BigIntFilter<"rewards"> | bigint | number
    title?: StringFilter<"rewards"> | string
    description?: StringFilter<"rewards"> | string
    category?: StringFilter<"rewards"> | string
    cost?: IntFilter<"rewards"> | number
    icon?: StringNullableFilter<"rewards"> | string | null
    created_at?: DateTimeNullableFilter<"rewards"> | Date | string | null
    student_rewards?: Student_rewardsListRelationFilter
  }

  export type rewardsOrderByWithRelationInput = {
    reward_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    icon?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    student_rewards?: student_rewardsOrderByRelationAggregateInput
  }

  export type rewardsWhereUniqueInput = Prisma.AtLeast<{
    reward_id?: bigint | number
    AND?: rewardsWhereInput | rewardsWhereInput[]
    OR?: rewardsWhereInput[]
    NOT?: rewardsWhereInput | rewardsWhereInput[]
    title?: StringFilter<"rewards"> | string
    description?: StringFilter<"rewards"> | string
    category?: StringFilter<"rewards"> | string
    cost?: IntFilter<"rewards"> | number
    icon?: StringNullableFilter<"rewards"> | string | null
    created_at?: DateTimeNullableFilter<"rewards"> | Date | string | null
    student_rewards?: Student_rewardsListRelationFilter
  }, "reward_id">

  export type rewardsOrderByWithAggregationInput = {
    reward_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    icon?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: rewardsCountOrderByAggregateInput
    _avg?: rewardsAvgOrderByAggregateInput
    _max?: rewardsMaxOrderByAggregateInput
    _min?: rewardsMinOrderByAggregateInput
    _sum?: rewardsSumOrderByAggregateInput
  }

  export type rewardsScalarWhereWithAggregatesInput = {
    AND?: rewardsScalarWhereWithAggregatesInput | rewardsScalarWhereWithAggregatesInput[]
    OR?: rewardsScalarWhereWithAggregatesInput[]
    NOT?: rewardsScalarWhereWithAggregatesInput | rewardsScalarWhereWithAggregatesInput[]
    reward_id?: BigIntWithAggregatesFilter<"rewards"> | bigint | number
    title?: StringWithAggregatesFilter<"rewards"> | string
    description?: StringWithAggregatesFilter<"rewards"> | string
    category?: StringWithAggregatesFilter<"rewards"> | string
    cost?: IntWithAggregatesFilter<"rewards"> | number
    icon?: StringNullableWithAggregatesFilter<"rewards"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"rewards"> | Date | string | null
  }

  export type student_rewardsWhereInput = {
    AND?: student_rewardsWhereInput | student_rewardsWhereInput[]
    OR?: student_rewardsWhereInput[]
    NOT?: student_rewardsWhereInput | student_rewardsWhereInput[]
    user_id?: BigIntFilter<"student_rewards"> | bigint | number
    reward_id?: BigIntFilter<"student_rewards"> | bigint | number
    purchased_at?: DateTimeNullableFilter<"student_rewards"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    rewards?: XOR<RewardsRelationFilter, rewardsWhereInput>
  }

  export type student_rewardsOrderByWithRelationInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
    purchased_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
    rewards?: rewardsOrderByWithRelationInput
  }

  export type student_rewardsWhereUniqueInput = Prisma.AtLeast<{
    user_id_reward_id?: student_rewardsUser_idReward_idCompoundUniqueInput
    AND?: student_rewardsWhereInput | student_rewardsWhereInput[]
    OR?: student_rewardsWhereInput[]
    NOT?: student_rewardsWhereInput | student_rewardsWhereInput[]
    user_id?: BigIntFilter<"student_rewards"> | bigint | number
    reward_id?: BigIntFilter<"student_rewards"> | bigint | number
    purchased_at?: DateTimeNullableFilter<"student_rewards"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    rewards?: XOR<RewardsRelationFilter, rewardsWhereInput>
  }, "user_id_reward_id">

  export type student_rewardsOrderByWithAggregationInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
    purchased_at?: SortOrderInput | SortOrder
    _count?: student_rewardsCountOrderByAggregateInput
    _avg?: student_rewardsAvgOrderByAggregateInput
    _max?: student_rewardsMaxOrderByAggregateInput
    _min?: student_rewardsMinOrderByAggregateInput
    _sum?: student_rewardsSumOrderByAggregateInput
  }

  export type student_rewardsScalarWhereWithAggregatesInput = {
    AND?: student_rewardsScalarWhereWithAggregatesInput | student_rewardsScalarWhereWithAggregatesInput[]
    OR?: student_rewardsScalarWhereWithAggregatesInput[]
    NOT?: student_rewardsScalarWhereWithAggregatesInput | student_rewardsScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"student_rewards"> | bigint | number
    reward_id?: BigIntWithAggregatesFilter<"student_rewards"> | bigint | number
    purchased_at?: DateTimeNullableWithAggregatesFilter<"student_rewards"> | Date | string | null
  }

  export type subject_masteryWhereInput = {
    AND?: subject_masteryWhereInput | subject_masteryWhereInput[]
    OR?: subject_masteryWhereInput[]
    NOT?: subject_masteryWhereInput | subject_masteryWhereInput[]
    user_id?: BigIntFilter<"subject_mastery"> | bigint | number
    subject_id?: IntFilter<"subject_mastery"> | number
    mastery_level?: IntFilter<"subject_mastery"> | number
    total_questions_attempted?: IntFilter<"subject_mastery"> | number
    correct_answers?: IntFilter<"subject_mastery"> | number
    last_test_date?: DateTimeNullableFilter<"subject_mastery"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    subjects?: XOR<SubjectsRelationFilter, subjectsWhereInput>
  }

  export type subject_masteryOrderByWithRelationInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
    last_test_date?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
  }

  export type subject_masteryWhereUniqueInput = Prisma.AtLeast<{
    user_id_subject_id?: subject_masteryUser_idSubject_idCompoundUniqueInput
    AND?: subject_masteryWhereInput | subject_masteryWhereInput[]
    OR?: subject_masteryWhereInput[]
    NOT?: subject_masteryWhereInput | subject_masteryWhereInput[]
    user_id?: BigIntFilter<"subject_mastery"> | bigint | number
    subject_id?: IntFilter<"subject_mastery"> | number
    mastery_level?: IntFilter<"subject_mastery"> | number
    total_questions_attempted?: IntFilter<"subject_mastery"> | number
    correct_answers?: IntFilter<"subject_mastery"> | number
    last_test_date?: DateTimeNullableFilter<"subject_mastery"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    subjects?: XOR<SubjectsRelationFilter, subjectsWhereInput>
  }, "user_id_subject_id">

  export type subject_masteryOrderByWithAggregationInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
    last_test_date?: SortOrderInput | SortOrder
    _count?: subject_masteryCountOrderByAggregateInput
    _avg?: subject_masteryAvgOrderByAggregateInput
    _max?: subject_masteryMaxOrderByAggregateInput
    _min?: subject_masteryMinOrderByAggregateInput
    _sum?: subject_masterySumOrderByAggregateInput
  }

  export type subject_masteryScalarWhereWithAggregatesInput = {
    AND?: subject_masteryScalarWhereWithAggregatesInput | subject_masteryScalarWhereWithAggregatesInput[]
    OR?: subject_masteryScalarWhereWithAggregatesInput[]
    NOT?: subject_masteryScalarWhereWithAggregatesInput | subject_masteryScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"subject_mastery"> | bigint | number
    subject_id?: IntWithAggregatesFilter<"subject_mastery"> | number
    mastery_level?: IntWithAggregatesFilter<"subject_mastery"> | number
    total_questions_attempted?: IntWithAggregatesFilter<"subject_mastery"> | number
    correct_answers?: IntWithAggregatesFilter<"subject_mastery"> | number
    last_test_date?: DateTimeNullableWithAggregatesFilter<"subject_mastery"> | Date | string | null
  }

  export type activity_logWhereInput = {
    AND?: activity_logWhereInput | activity_logWhereInput[]
    OR?: activity_logWhereInput[]
    NOT?: activity_logWhereInput | activity_logWhereInput[]
    activity_id?: BigIntFilter<"activity_log"> | bigint | number
    user_id?: BigIntFilter<"activity_log"> | bigint | number
    activity_type?: StringFilter<"activity_log"> | string
    xp_earned?: IntFilter<"activity_log"> | number
    details?: StringNullableFilter<"activity_log"> | string | null
    created_at?: DateTimeNullableFilter<"activity_log"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type activity_logOrderByWithRelationInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    activity_type?: SortOrder
    xp_earned?: SortOrder
    details?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type activity_logWhereUniqueInput = Prisma.AtLeast<{
    activity_id?: bigint | number
    AND?: activity_logWhereInput | activity_logWhereInput[]
    OR?: activity_logWhereInput[]
    NOT?: activity_logWhereInput | activity_logWhereInput[]
    user_id?: BigIntFilter<"activity_log"> | bigint | number
    activity_type?: StringFilter<"activity_log"> | string
    xp_earned?: IntFilter<"activity_log"> | number
    details?: StringNullableFilter<"activity_log"> | string | null
    created_at?: DateTimeNullableFilter<"activity_log"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "activity_id">

  export type activity_logOrderByWithAggregationInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    activity_type?: SortOrder
    xp_earned?: SortOrder
    details?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: activity_logCountOrderByAggregateInput
    _avg?: activity_logAvgOrderByAggregateInput
    _max?: activity_logMaxOrderByAggregateInput
    _min?: activity_logMinOrderByAggregateInput
    _sum?: activity_logSumOrderByAggregateInput
  }

  export type activity_logScalarWhereWithAggregatesInput = {
    AND?: activity_logScalarWhereWithAggregatesInput | activity_logScalarWhereWithAggregatesInput[]
    OR?: activity_logScalarWhereWithAggregatesInput[]
    NOT?: activity_logScalarWhereWithAggregatesInput | activity_logScalarWhereWithAggregatesInput[]
    activity_id?: BigIntWithAggregatesFilter<"activity_log"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"activity_log"> | bigint | number
    activity_type?: StringWithAggregatesFilter<"activity_log"> | string
    xp_earned?: IntWithAggregatesFilter<"activity_log"> | number
    details?: StringNullableWithAggregatesFilter<"activity_log"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"activity_log"> | Date | string | null
  }

  export type level_configWhereInput = {
    AND?: level_configWhereInput | level_configWhereInput[]
    OR?: level_configWhereInput[]
    NOT?: level_configWhereInput | level_configWhereInput[]
    level?: IntFilter<"level_config"> | number
    xp_required?: IntFilter<"level_config"> | number
    created_at?: DateTimeFilter<"level_config"> | Date | string
  }

  export type level_configOrderByWithRelationInput = {
    level?: SortOrder
    xp_required?: SortOrder
    created_at?: SortOrder
  }

  export type level_configWhereUniqueInput = Prisma.AtLeast<{
    level?: number
    AND?: level_configWhereInput | level_configWhereInput[]
    OR?: level_configWhereInput[]
    NOT?: level_configWhereInput | level_configWhereInput[]
    xp_required?: IntFilter<"level_config"> | number
    created_at?: DateTimeFilter<"level_config"> | Date | string
  }, "level">

  export type level_configOrderByWithAggregationInput = {
    level?: SortOrder
    xp_required?: SortOrder
    created_at?: SortOrder
    _count?: level_configCountOrderByAggregateInput
    _avg?: level_configAvgOrderByAggregateInput
    _max?: level_configMaxOrderByAggregateInput
    _min?: level_configMinOrderByAggregateInput
    _sum?: level_configSumOrderByAggregateInput
  }

  export type level_configScalarWhereWithAggregatesInput = {
    AND?: level_configScalarWhereWithAggregatesInput | level_configScalarWhereWithAggregatesInput[]
    OR?: level_configScalarWhereWithAggregatesInput[]
    NOT?: level_configScalarWhereWithAggregatesInput | level_configScalarWhereWithAggregatesInput[]
    level?: IntWithAggregatesFilter<"level_config"> | number
    xp_required?: IntWithAggregatesFilter<"level_config"> | number
    created_at?: DateTimeWithAggregatesFilter<"level_config"> | Date | string
  }

  export type study_groupsWhereInput = {
    AND?: study_groupsWhereInput | study_groupsWhereInput[]
    OR?: study_groupsWhereInput[]
    NOT?: study_groupsWhereInput | study_groupsWhereInput[]
    group_id?: BigIntFilter<"study_groups"> | bigint | number
    group_name?: StringFilter<"study_groups"> | string
    description?: StringNullableFilter<"study_groups"> | string | null
    tutor_id?: BigIntFilter<"study_groups"> | bigint | number
    created_at?: DateTimeNullableFilter<"study_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"study_groups"> | Date | string | null
    tutor?: XOR<UsersRelationFilter, usersWhereInput>
    students?: UsersListRelationFilter
    members?: Group_membersListRelationFilter
    assignments?: Test_assignmentsListRelationFilter
    test_plans?: Test_plansListRelationFilter
  }

  export type study_groupsOrderByWithRelationInput = {
    group_id?: SortOrder
    group_name?: SortOrder
    description?: SortOrderInput | SortOrder
    tutor_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    tutor?: usersOrderByWithRelationInput
    students?: usersOrderByRelationAggregateInput
    members?: group_membersOrderByRelationAggregateInput
    assignments?: test_assignmentsOrderByRelationAggregateInput
    test_plans?: test_plansOrderByRelationAggregateInput
  }

  export type study_groupsWhereUniqueInput = Prisma.AtLeast<{
    group_id?: bigint | number
    AND?: study_groupsWhereInput | study_groupsWhereInput[]
    OR?: study_groupsWhereInput[]
    NOT?: study_groupsWhereInput | study_groupsWhereInput[]
    group_name?: StringFilter<"study_groups"> | string
    description?: StringNullableFilter<"study_groups"> | string | null
    tutor_id?: BigIntFilter<"study_groups"> | bigint | number
    created_at?: DateTimeNullableFilter<"study_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"study_groups"> | Date | string | null
    tutor?: XOR<UsersRelationFilter, usersWhereInput>
    students?: UsersListRelationFilter
    members?: Group_membersListRelationFilter
    assignments?: Test_assignmentsListRelationFilter
    test_plans?: Test_plansListRelationFilter
  }, "group_id">

  export type study_groupsOrderByWithAggregationInput = {
    group_id?: SortOrder
    group_name?: SortOrder
    description?: SortOrderInput | SortOrder
    tutor_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: study_groupsCountOrderByAggregateInput
    _avg?: study_groupsAvgOrderByAggregateInput
    _max?: study_groupsMaxOrderByAggregateInput
    _min?: study_groupsMinOrderByAggregateInput
    _sum?: study_groupsSumOrderByAggregateInput
  }

  export type study_groupsScalarWhereWithAggregatesInput = {
    AND?: study_groupsScalarWhereWithAggregatesInput | study_groupsScalarWhereWithAggregatesInput[]
    OR?: study_groupsScalarWhereWithAggregatesInput[]
    NOT?: study_groupsScalarWhereWithAggregatesInput | study_groupsScalarWhereWithAggregatesInput[]
    group_id?: BigIntWithAggregatesFilter<"study_groups"> | bigint | number
    group_name?: StringWithAggregatesFilter<"study_groups"> | string
    description?: StringNullableWithAggregatesFilter<"study_groups"> | string | null
    tutor_id?: BigIntWithAggregatesFilter<"study_groups"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"study_groups"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"study_groups"> | Date | string | null
  }

  export type student_guardiansWhereInput = {
    AND?: student_guardiansWhereInput | student_guardiansWhereInput[]
    OR?: student_guardiansWhereInput[]
    NOT?: student_guardiansWhereInput | student_guardiansWhereInput[]
    relationship_id?: BigIntFilter<"student_guardians"> | bigint | number
    guardian_id?: BigIntFilter<"student_guardians"> | bigint | number
    student_id?: BigIntFilter<"student_guardians"> | bigint | number
    relationship_type?: EnumGuardianRelationTypeFilter<"student_guardians"> | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFilter<"student_guardians"> | $Enums.GuardianRelationStatus
    created_at?: DateTimeNullableFilter<"student_guardians"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_guardians"> | Date | string | null
    guardian?: XOR<UsersRelationFilter, usersWhereInput>
    student?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type student_guardiansOrderByWithRelationInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
    relationship_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    guardian?: usersOrderByWithRelationInput
    student?: usersOrderByWithRelationInput
  }

  export type student_guardiansWhereUniqueInput = Prisma.AtLeast<{
    relationship_id?: bigint | number
    guardian_id_student_id?: student_guardiansGuardian_idStudent_idCompoundUniqueInput
    AND?: student_guardiansWhereInput | student_guardiansWhereInput[]
    OR?: student_guardiansWhereInput[]
    NOT?: student_guardiansWhereInput | student_guardiansWhereInput[]
    guardian_id?: BigIntFilter<"student_guardians"> | bigint | number
    student_id?: BigIntFilter<"student_guardians"> | bigint | number
    relationship_type?: EnumGuardianRelationTypeFilter<"student_guardians"> | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFilter<"student_guardians"> | $Enums.GuardianRelationStatus
    created_at?: DateTimeNullableFilter<"student_guardians"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_guardians"> | Date | string | null
    guardian?: XOR<UsersRelationFilter, usersWhereInput>
    student?: XOR<UsersRelationFilter, usersWhereInput>
  }, "relationship_id" | "guardian_id_student_id">

  export type student_guardiansOrderByWithAggregationInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
    relationship_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: student_guardiansCountOrderByAggregateInput
    _avg?: student_guardiansAvgOrderByAggregateInput
    _max?: student_guardiansMaxOrderByAggregateInput
    _min?: student_guardiansMinOrderByAggregateInput
    _sum?: student_guardiansSumOrderByAggregateInput
  }

  export type student_guardiansScalarWhereWithAggregatesInput = {
    AND?: student_guardiansScalarWhereWithAggregatesInput | student_guardiansScalarWhereWithAggregatesInput[]
    OR?: student_guardiansScalarWhereWithAggregatesInput[]
    NOT?: student_guardiansScalarWhereWithAggregatesInput | student_guardiansScalarWhereWithAggregatesInput[]
    relationship_id?: BigIntWithAggregatesFilter<"student_guardians"> | bigint | number
    guardian_id?: BigIntWithAggregatesFilter<"student_guardians"> | bigint | number
    student_id?: BigIntWithAggregatesFilter<"student_guardians"> | bigint | number
    relationship_type?: EnumGuardianRelationTypeWithAggregatesFilter<"student_guardians"> | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusWithAggregatesFilter<"student_guardians"> | $Enums.GuardianRelationStatus
    created_at?: DateTimeNullableWithAggregatesFilter<"student_guardians"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"student_guardians"> | Date | string | null
  }

  export type group_membersWhereInput = {
    AND?: group_membersWhereInput | group_membersWhereInput[]
    OR?: group_membersWhereInput[]
    NOT?: group_membersWhereInput | group_membersWhereInput[]
    group_id?: BigIntFilter<"group_members"> | bigint | number
    student_id?: BigIntFilter<"group_members"> | bigint | number
    joined_at?: DateTimeNullableFilter<"group_members"> | Date | string | null
    group?: XOR<Study_groupsRelationFilter, study_groupsWhereInput>
    student?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type group_membersOrderByWithRelationInput = {
    group_id?: SortOrder
    student_id?: SortOrder
    joined_at?: SortOrderInput | SortOrder
    group?: study_groupsOrderByWithRelationInput
    student?: usersOrderByWithRelationInput
  }

  export type group_membersWhereUniqueInput = Prisma.AtLeast<{
    group_id_student_id?: group_membersGroup_idStudent_idCompoundUniqueInput
    AND?: group_membersWhereInput | group_membersWhereInput[]
    OR?: group_membersWhereInput[]
    NOT?: group_membersWhereInput | group_membersWhereInput[]
    group_id?: BigIntFilter<"group_members"> | bigint | number
    student_id?: BigIntFilter<"group_members"> | bigint | number
    joined_at?: DateTimeNullableFilter<"group_members"> | Date | string | null
    group?: XOR<Study_groupsRelationFilter, study_groupsWhereInput>
    student?: XOR<UsersRelationFilter, usersWhereInput>
  }, "group_id_student_id">

  export type group_membersOrderByWithAggregationInput = {
    group_id?: SortOrder
    student_id?: SortOrder
    joined_at?: SortOrderInput | SortOrder
    _count?: group_membersCountOrderByAggregateInput
    _avg?: group_membersAvgOrderByAggregateInput
    _max?: group_membersMaxOrderByAggregateInput
    _min?: group_membersMinOrderByAggregateInput
    _sum?: group_membersSumOrderByAggregateInput
  }

  export type group_membersScalarWhereWithAggregatesInput = {
    AND?: group_membersScalarWhereWithAggregatesInput | group_membersScalarWhereWithAggregatesInput[]
    OR?: group_membersScalarWhereWithAggregatesInput[]
    NOT?: group_membersScalarWhereWithAggregatesInput | group_membersScalarWhereWithAggregatesInput[]
    group_id?: BigIntWithAggregatesFilter<"group_members"> | bigint | number
    student_id?: BigIntWithAggregatesFilter<"group_members"> | bigint | number
    joined_at?: DateTimeNullableWithAggregatesFilter<"group_members"> | Date | string | null
  }

  export type test_assignmentsWhereInput = {
    AND?: test_assignmentsWhereInput | test_assignmentsWhereInput[]
    OR?: test_assignmentsWhereInput[]
    NOT?: test_assignmentsWhereInput | test_assignmentsWhereInput[]
    assignment_id?: BigIntFilter<"test_assignments"> | bigint | number
    test_plan_id?: BigIntFilter<"test_assignments"> | bigint | number
    assigned_by?: BigIntFilter<"test_assignments"> | bigint | number
    group_id?: BigIntNullableFilter<"test_assignments"> | bigint | number | null
    student_id?: BigIntNullableFilter<"test_assignments"> | bigint | number | null
    due_date?: DateTimeFilter<"test_assignments"> | Date | string
    status?: EnumTestAssignmentStatusFilter<"test_assignments"> | $Enums.TestAssignmentStatus
    created_at?: DateTimeNullableFilter<"test_assignments"> | Date | string | null
    test_plan?: XOR<Test_plansRelationFilter, test_plansWhereInput>
    assigner?: XOR<UsersRelationFilter, usersWhereInput>
    group?: XOR<Study_groupsNullableRelationFilter, study_groupsWhereInput> | null
    student?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type test_assignmentsOrderByWithRelationInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrderInput | SortOrder
    student_id?: SortOrderInput | SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    test_plan?: test_plansOrderByWithRelationInput
    assigner?: usersOrderByWithRelationInput
    group?: study_groupsOrderByWithRelationInput
    student?: usersOrderByWithRelationInput
  }

  export type test_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    assignment_id?: bigint | number
    AND?: test_assignmentsWhereInput | test_assignmentsWhereInput[]
    OR?: test_assignmentsWhereInput[]
    NOT?: test_assignmentsWhereInput | test_assignmentsWhereInput[]
    test_plan_id?: BigIntFilter<"test_assignments"> | bigint | number
    assigned_by?: BigIntFilter<"test_assignments"> | bigint | number
    group_id?: BigIntNullableFilter<"test_assignments"> | bigint | number | null
    student_id?: BigIntNullableFilter<"test_assignments"> | bigint | number | null
    due_date?: DateTimeFilter<"test_assignments"> | Date | string
    status?: EnumTestAssignmentStatusFilter<"test_assignments"> | $Enums.TestAssignmentStatus
    created_at?: DateTimeNullableFilter<"test_assignments"> | Date | string | null
    test_plan?: XOR<Test_plansRelationFilter, test_plansWhereInput>
    assigner?: XOR<UsersRelationFilter, usersWhereInput>
    group?: XOR<Study_groupsNullableRelationFilter, study_groupsWhereInput> | null
    student?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "assignment_id">

  export type test_assignmentsOrderByWithAggregationInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrderInput | SortOrder
    student_id?: SortOrderInput | SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: test_assignmentsCountOrderByAggregateInput
    _avg?: test_assignmentsAvgOrderByAggregateInput
    _max?: test_assignmentsMaxOrderByAggregateInput
    _min?: test_assignmentsMinOrderByAggregateInput
    _sum?: test_assignmentsSumOrderByAggregateInput
  }

  export type test_assignmentsScalarWhereWithAggregatesInput = {
    AND?: test_assignmentsScalarWhereWithAggregatesInput | test_assignmentsScalarWhereWithAggregatesInput[]
    OR?: test_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: test_assignmentsScalarWhereWithAggregatesInput | test_assignmentsScalarWhereWithAggregatesInput[]
    assignment_id?: BigIntWithAggregatesFilter<"test_assignments"> | bigint | number
    test_plan_id?: BigIntWithAggregatesFilter<"test_assignments"> | bigint | number
    assigned_by?: BigIntWithAggregatesFilter<"test_assignments"> | bigint | number
    group_id?: BigIntNullableWithAggregatesFilter<"test_assignments"> | bigint | number | null
    student_id?: BigIntNullableWithAggregatesFilter<"test_assignments"> | bigint | number | null
    due_date?: DateTimeWithAggregatesFilter<"test_assignments"> | Date | string
    status?: EnumTestAssignmentStatusWithAggregatesFilter<"test_assignments"> | $Enums.TestAssignmentStatus
    created_at?: DateTimeNullableWithAggregatesFilter<"test_assignments"> | Date | string | null
  }

  export type exam_boardsCreateInput = {
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
    test_plans?: test_plansCreateNestedManyWithoutExam_boardsInput
    test_templates?: test_templatesCreateNestedManyWithoutExam_boardsInput
  }

  export type exam_boardsUncheckedCreateInput = {
    board_id?: number
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
    test_plans?: test_plansUncheckedCreateNestedManyWithoutExam_boardsInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutExam_boardsInput
  }

  export type exam_boardsUpdateInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
    test_plans?: test_plansUpdateManyWithoutExam_boardsNestedInput
    test_templates?: test_templatesUpdateManyWithoutExam_boardsNestedInput
  }

  export type exam_boardsUncheckedUpdateInput = {
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
    test_plans?: test_plansUncheckedUpdateManyWithoutExam_boardsNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutExam_boardsNestedInput
  }

  export type exam_boardsCreateManyInput = {
    board_id?: number
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
  }

  export type exam_boardsUpdateManyMutationInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
  }

  export type exam_boardsUncheckedUpdateManyInput = {
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
  }

  export type questionsCreateInput = {
    question_id?: bigint | number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    active?: boolean | null
    subtopics: subtopicsCreateNestedOneWithoutQuestionsInput
    users: usersCreateNestedOneWithoutQuestionsInput
    question_set_items?: question_set_itemsCreateNestedManyWithoutQuestionInput
  }

  export type questionsUncheckedCreateInput = {
    question_id?: bigint | number
    subtopic_id: number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    created_by: bigint | number
    active?: boolean | null
    question_set_items?: question_set_itemsUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsUpdateInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    subtopics?: subtopicsUpdateOneRequiredWithoutQuestionsNestedInput
    users?: usersUpdateOneRequiredWithoutQuestionsNestedInput
    question_set_items?: question_set_itemsUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subtopic_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    question_set_items?: question_set_itemsUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsCreateManyInput = {
    question_id?: bigint | number
    subtopic_id: number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    created_by: bigint | number
    active?: boolean | null
  }

  export type questionsUpdateManyMutationInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type questionsUncheckedUpdateManyInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subtopic_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type question_set_itemsCreateInput = {
    item_id?: bigint | number
    sequence: number
    created_at?: Date | string
    question_set: question_setsCreateNestedOneWithoutQuestion_set_itemsInput
    question: questionsCreateNestedOneWithoutQuestion_set_itemsInput
  }

  export type question_set_itemsUncheckedCreateInput = {
    item_id?: bigint | number
    set_id: bigint | number
    question_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type question_set_itemsUpdateInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_set?: question_setsUpdateOneRequiredWithoutQuestion_set_itemsNestedInput
    question?: questionsUpdateOneRequiredWithoutQuestion_set_itemsNestedInput
  }

  export type question_set_itemsUncheckedUpdateInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_set_itemsCreateManyInput = {
    item_id?: bigint | number
    set_id: bigint | number
    question_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type question_set_itemsUpdateManyMutationInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_set_itemsUncheckedUpdateManyInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_setsCreateInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    creator: usersCreateNestedOneWithoutCreated_question_setsInput
    question_set_items?: question_set_itemsCreateNestedManyWithoutQuestion_setInput
    test_plan_links?: test_plan_question_setsCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsUncheckedCreateInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_by: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    question_set_items?: question_set_itemsUncheckedCreateNestedManyWithoutQuestion_setInput
    test_plan_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsUpdateInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: usersUpdateOneRequiredWithoutCreated_question_setsNestedInput
    question_set_items?: question_set_itemsUpdateManyWithoutQuestion_setNestedInput
    test_plan_links?: test_plan_question_setsUpdateManyWithoutQuestion_setNestedInput
  }

  export type question_setsUncheckedUpdateInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    question_set_items?: question_set_itemsUncheckedUpdateManyWithoutQuestion_setNestedInput
    test_plan_links?: test_plan_question_setsUncheckedUpdateManyWithoutQuestion_setNestedInput
  }

  export type question_setsCreateManyInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_by: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
  }

  export type question_setsUpdateManyMutationInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type question_setsUncheckedUpdateManyInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesCreateInput = {
    role_name: string
    description?: string | null
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    role_id?: number
    role_name: string
    description?: string | null
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    role_id?: number
    role_name: string
    description?: string | null
  }

  export type rolesUpdateManyMutationInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subjectsCreateInput = {
    subject_name: string
    description?: string | null
    topics?: topicsCreateNestedManyWithoutSubjectsInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutSubjectsInput
    difficulty_levels?: difficulty_levelsCreateNestedManyWithoutSubjectInput
  }

  export type subjectsUncheckedCreateInput = {
    subject_id?: number
    subject_name: string
    description?: string | null
    topics?: topicsUncheckedCreateNestedManyWithoutSubjectsInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutSubjectsInput
    difficulty_levels?: difficulty_levelsUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectsUpdateInput = {
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUpdateManyWithoutSubjectsNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutSubjectsNestedInput
    difficulty_levels?: difficulty_levelsUpdateManyWithoutSubjectNestedInput
  }

  export type subjectsUncheckedUpdateInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUncheckedUpdateManyWithoutSubjectsNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutSubjectsNestedInput
    difficulty_levels?: difficulty_levelsUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectsCreateManyInput = {
    subject_id?: number
    subject_name: string
    description?: string | null
  }

  export type subjectsUpdateManyMutationInput = {
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subjectsUncheckedUpdateManyInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subtopicsCreateInput = {
    subtopic_name: string
    description?: string | null
    questions?: questionsCreateNestedManyWithoutSubtopicsInput
    topics: topicsCreateNestedOneWithoutSubtopicsInput
  }

  export type subtopicsUncheckedCreateInput = {
    subtopic_id?: number
    topic_id: number
    subtopic_name: string
    description?: string | null
    questions?: questionsUncheckedCreateNestedManyWithoutSubtopicsInput
  }

  export type subtopicsUpdateInput = {
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: questionsUpdateManyWithoutSubtopicsNestedInput
    topics?: topicsUpdateOneRequiredWithoutSubtopicsNestedInput
  }

  export type subtopicsUncheckedUpdateInput = {
    subtopic_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: questionsUncheckedUpdateManyWithoutSubtopicsNestedInput
  }

  export type subtopicsCreateManyInput = {
    subtopic_id?: number
    topic_id: number
    subtopic_name: string
    description?: string | null
  }

  export type subtopicsUpdateManyMutationInput = {
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subtopicsUncheckedUpdateManyInput = {
    subtopic_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_executionsCreateInput = {
    execution_id?: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
    test_plans: test_plansCreateNestedOneWithoutTest_executionsInput
    users: usersCreateNestedOneWithoutTest_executionsInput
  }

  export type test_executionsUncheckedCreateInput = {
    execution_id?: bigint | number
    test_plan_id: bigint | number
    student_id: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
  }

  export type test_executionsUpdateInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    test_plans?: test_plansUpdateOneRequiredWithoutTest_executionsNestedInput
    users?: usersUpdateOneRequiredWithoutTest_executionsNestedInput
  }

  export type test_executionsUncheckedUpdateInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_executionsCreateManyInput = {
    execution_id?: bigint | number
    test_plan_id: bigint | number
    student_id: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
  }

  export type test_executionsUpdateManyMutationInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_executionsUncheckedUpdateManyInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_plan_question_setsCreateInput = {
    link_id?: bigint | number
    sequence: number
    created_at?: Date | string
    test_plan: test_plansCreateNestedOneWithoutQuestion_set_linksInput
    question_set: question_setsCreateNestedOneWithoutTest_plan_linksInput
  }

  export type test_plan_question_setsUncheckedCreateInput = {
    link_id?: bigint | number
    test_plan_id: bigint | number
    set_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type test_plan_question_setsUpdateInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    test_plan?: test_plansUpdateOneRequiredWithoutQuestion_set_linksNestedInput
    question_set?: question_setsUpdateOneRequiredWithoutTest_plan_linksNestedInput
  }

  export type test_plan_question_setsUncheckedUpdateInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_question_setsCreateManyInput = {
    link_id?: bigint | number
    test_plan_id: bigint | number
    set_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type test_plan_question_setsUpdateManyMutationInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_question_setsUncheckedUpdateManyInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plansCreateInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUpdateInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansCreateManyInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
  }

  export type test_plansUpdateManyMutationInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }

  export type test_plansUncheckedUpdateManyInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }

  export type test_templatesCreateInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_at?: Date | string | null
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    test_plans?: test_plansCreateNestedManyWithoutTest_templatesInput
    users: usersCreateNestedOneWithoutTest_templatesInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_templatesInput
  }

  export type test_templatesUncheckedCreateInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_by: bigint | number
    created_at?: Date | string | null
    board_id: number
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    test_plans?: test_plansUncheckedCreateNestedManyWithoutTest_templatesInput
  }

  export type test_templatesUpdateInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    test_plans?: test_plansUpdateManyWithoutTest_templatesNestedInput
    users?: usersUpdateOneRequiredWithoutTest_templatesNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_templatesNestedInput
  }

  export type test_templatesUncheckedUpdateInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    test_plans?: test_plansUncheckedUpdateManyWithoutTest_templatesNestedInput
  }

  export type test_templatesCreateManyInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_by: bigint | number
    created_at?: Date | string | null
    board_id: number
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
  }

  export type test_templatesUpdateManyMutationInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type test_templatesUncheckedUpdateManyInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type topicsCreateInput = {
    topic_name: string
    description?: string | null
    subtopics?: subtopicsCreateNestedManyWithoutTopicsInput
    subjects: subjectsCreateNestedOneWithoutTopicsInput
  }

  export type topicsUncheckedCreateInput = {
    topic_id?: number
    subject_id: number
    topic_name: string
    description?: string | null
    subtopics?: subtopicsUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type topicsUpdateInput = {
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: subtopicsUpdateManyWithoutTopicsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type topicsUncheckedUpdateInput = {
    topic_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: subtopicsUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type topicsCreateManyInput = {
    topic_id?: number
    subject_id: number
    topic_name: string
    description?: string | null
  }

  export type topicsUpdateManyMutationInput = {
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type topicsUncheckedUpdateManyInput = {
    topic_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_rolesCreateInput = {
    users: usersCreateNestedOneWithoutUser_rolesInput
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateInput = {
    user_id: bigint | number
    role_id: number
  }

  export type user_rolesUpdateInput = {
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesCreateManyInput = {
    user_id: bigint | number
    role_id: number
  }

  export type user_rolesUpdateManyMutationInput = {

  }

  export type user_rolesUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type usersCreateManyInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
  }

  export type usersUpdateManyMutationInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type difficulty_levelsCreateInput = {
    level_name: string
    level_value: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required?: string | null
    created_at?: Date | string | null
    active?: boolean | null
    subject: subjectsCreateNestedOneWithoutDifficulty_levelsInput
  }

  export type difficulty_levelsUncheckedCreateInput = {
    level_id?: number
    level_name: string
    level_value: number
    subject_id: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required?: string | null
    created_at?: Date | string | null
    active?: boolean | null
  }

  export type difficulty_levelsUpdateInput = {
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    subject?: subjectsUpdateOneRequiredWithoutDifficulty_levelsNestedInput
  }

  export type difficulty_levelsUncheckedUpdateInput = {
    level_id?: IntFieldUpdateOperationsInput | number
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type difficulty_levelsCreateManyInput = {
    level_id?: number
    level_name: string
    level_value: number
    subject_id: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required?: string | null
    created_at?: Date | string | null
    active?: boolean | null
  }

  export type difficulty_levelsUpdateManyMutationInput = {
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type difficulty_levelsUncheckedUpdateManyInput = {
    level_id?: IntFieldUpdateOperationsInput | number
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type student_progressCreateInput = {
    level?: number
    current_xp?: number
    next_level_xp?: number
    streak_days?: number
    last_activity_date?: Date | string | null
    total_points?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user: usersCreateNestedOneWithoutStudent_progressInput
  }

  export type student_progressUncheckedCreateInput = {
    user_id: bigint | number
    level?: number
    current_xp?: number
    next_level_xp?: number
    streak_days?: number
    last_activity_date?: Date | string | null
    total_points?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_progressUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    current_xp?: IntFieldUpdateOperationsInput | number
    next_level_xp?: IntFieldUpdateOperationsInput | number
    streak_days?: IntFieldUpdateOperationsInput | number
    last_activity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutStudent_progressNestedInput
  }

  export type student_progressUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    level?: IntFieldUpdateOperationsInput | number
    current_xp?: IntFieldUpdateOperationsInput | number
    next_level_xp?: IntFieldUpdateOperationsInput | number
    streak_days?: IntFieldUpdateOperationsInput | number
    last_activity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_progressCreateManyInput = {
    user_id: bigint | number
    level?: number
    current_xp?: number
    next_level_xp?: number
    streak_days?: number
    last_activity_date?: Date | string | null
    total_points?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_progressUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    current_xp?: IntFieldUpdateOperationsInput | number
    next_level_xp?: IntFieldUpdateOperationsInput | number
    streak_days?: IntFieldUpdateOperationsInput | number
    last_activity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_progressUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    level?: IntFieldUpdateOperationsInput | number
    current_xp?: IntFieldUpdateOperationsInput | number
    next_level_xp?: IntFieldUpdateOperationsInput | number
    streak_days?: IntFieldUpdateOperationsInput | number
    last_activity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type achievementsCreateInput = {
    achievement_id?: bigint | number
    title: string
    description: string
    category: string
    points: number
    icon?: string | null
    required_criteria: string
    created_at?: Date | string | null
    student_achievements?: student_achievementsCreateNestedManyWithoutAchievementsInput
  }

  export type achievementsUncheckedCreateInput = {
    achievement_id?: bigint | number
    title: string
    description: string
    category: string
    points: number
    icon?: string | null
    required_criteria: string
    created_at?: Date | string | null
    student_achievements?: student_achievementsUncheckedCreateNestedManyWithoutAchievementsInput
  }

  export type achievementsUpdateInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    required_criteria?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_achievements?: student_achievementsUpdateManyWithoutAchievementsNestedInput
  }

  export type achievementsUncheckedUpdateInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    required_criteria?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_achievements?: student_achievementsUncheckedUpdateManyWithoutAchievementsNestedInput
  }

  export type achievementsCreateManyInput = {
    achievement_id?: bigint | number
    title: string
    description: string
    category: string
    points: number
    icon?: string | null
    required_criteria: string
    created_at?: Date | string | null
  }

  export type achievementsUpdateManyMutationInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    required_criteria?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type achievementsUncheckedUpdateManyInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    required_criteria?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_achievementsCreateInput = {
    unlocked_at?: Date | string | null
    progress?: number
    user: usersCreateNestedOneWithoutAchievements_earnedInput
    achievements: achievementsCreateNestedOneWithoutStudent_achievementsInput
  }

  export type student_achievementsUncheckedCreateInput = {
    user_id: bigint | number
    achievement_id: bigint | number
    unlocked_at?: Date | string | null
    progress?: number
  }

  export type student_achievementsUpdateInput = {
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    user?: usersUpdateOneRequiredWithoutAchievements_earnedNestedInput
    achievements?: achievementsUpdateOneRequiredWithoutStudent_achievementsNestedInput
  }

  export type student_achievementsUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type student_achievementsCreateManyInput = {
    user_id: bigint | number
    achievement_id: bigint | number
    unlocked_at?: Date | string | null
    progress?: number
  }

  export type student_achievementsUpdateManyMutationInput = {
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type student_achievementsUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type rewardsCreateInput = {
    reward_id?: bigint | number
    title: string
    description: string
    category: string
    cost: number
    icon?: string | null
    created_at?: Date | string | null
    student_rewards?: student_rewardsCreateNestedManyWithoutRewardsInput
  }

  export type rewardsUncheckedCreateInput = {
    reward_id?: bigint | number
    title: string
    description: string
    category: string
    cost: number
    icon?: string | null
    created_at?: Date | string | null
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutRewardsInput
  }

  export type rewardsUpdateInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_rewards?: student_rewardsUpdateManyWithoutRewardsNestedInput
  }

  export type rewardsUncheckedUpdateInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutRewardsNestedInput
  }

  export type rewardsCreateManyInput = {
    reward_id?: bigint | number
    title: string
    description: string
    category: string
    cost: number
    icon?: string | null
    created_at?: Date | string | null
  }

  export type rewardsUpdateManyMutationInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardsUncheckedUpdateManyInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsCreateInput = {
    purchased_at?: Date | string | null
    user: usersCreateNestedOneWithoutStudent_rewardsInput
    rewards: rewardsCreateNestedOneWithoutStudent_rewardsInput
  }

  export type student_rewardsUncheckedCreateInput = {
    user_id: bigint | number
    reward_id: bigint | number
    purchased_at?: Date | string | null
  }

  export type student_rewardsUpdateInput = {
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutStudent_rewardsNestedInput
    rewards?: rewardsUpdateOneRequiredWithoutStudent_rewardsNestedInput
  }

  export type student_rewardsUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsCreateManyInput = {
    user_id: bigint | number
    reward_id: bigint | number
    purchased_at?: Date | string | null
  }

  export type student_rewardsUpdateManyMutationInput = {
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subject_masteryCreateInput = {
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
    user: usersCreateNestedOneWithoutSubject_masteryInput
    subjects: subjectsCreateNestedOneWithoutSubject_masteryInput
  }

  export type subject_masteryUncheckedCreateInput = {
    user_id: bigint | number
    subject_id: number
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
  }

  export type subject_masteryUpdateInput = {
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutSubject_masteryNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSubject_masteryNestedInput
  }

  export type subject_masteryUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subject_masteryCreateManyInput = {
    user_id: bigint | number
    subject_id: number
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
  }

  export type subject_masteryUpdateManyMutationInput = {
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subject_masteryUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logCreateInput = {
    activity_id?: bigint | number
    activity_type: string
    xp_earned?: number
    details?: string | null
    created_at?: Date | string | null
    user: usersCreateNestedOneWithoutActivity_logsInput
  }

  export type activity_logUncheckedCreateInput = {
    activity_id?: bigint | number
    user_id: bigint | number
    activity_type: string
    xp_earned?: number
    details?: string | null
    created_at?: Date | string | null
  }

  export type activity_logUpdateInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutActivity_logsNestedInput
  }

  export type activity_logUncheckedUpdateInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logCreateManyInput = {
    activity_id?: bigint | number
    user_id: bigint | number
    activity_type: string
    xp_earned?: number
    details?: string | null
    created_at?: Date | string | null
  }

  export type activity_logUpdateManyMutationInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUncheckedUpdateManyInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type level_configCreateInput = {
    level: number
    xp_required: number
    created_at?: Date | string
  }

  export type level_configUncheckedCreateInput = {
    level: number
    xp_required: number
    created_at?: Date | string
  }

  export type level_configUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    xp_required?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type level_configUncheckedUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    xp_required?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type level_configCreateManyInput = {
    level: number
    xp_required: number
    created_at?: Date | string
  }

  export type level_configUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    xp_required?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type level_configUncheckedUpdateManyInput = {
    level?: IntFieldUpdateOperationsInput | number
    xp_required?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type study_groupsCreateInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tutor: usersCreateNestedOneWithoutTutor_groupsInput
    students?: usersCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsCreateNestedManyWithoutGroupInput
    test_plans?: test_plansCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsUncheckedCreateInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    tutor_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students?: usersUncheckedCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersUncheckedCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutGroupInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsUpdateInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutor?: usersUpdateOneRequiredWithoutTutor_groupsNestedInput
    students?: usersUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: usersUncheckedUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUncheckedUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsCreateManyInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    tutor_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type study_groupsUpdateManyMutationInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type study_groupsUncheckedUpdateManyInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansCreateInput = {
    relationship_id?: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
    guardian: usersCreateNestedOneWithoutGuardian_relationshipsInput
    student: usersCreateNestedOneWithoutStudent_relationshipsInput
  }

  export type student_guardiansUncheckedCreateInput = {
    relationship_id?: bigint | number
    guardian_id: bigint | number
    student_id: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_guardiansUpdateInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    guardian?: usersUpdateOneRequiredWithoutGuardian_relationshipsNestedInput
    student?: usersUpdateOneRequiredWithoutStudent_relationshipsNestedInput
  }

  export type student_guardiansUncheckedUpdateInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansCreateManyInput = {
    relationship_id?: bigint | number
    guardian_id: bigint | number
    student_id: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_guardiansUpdateManyMutationInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansUncheckedUpdateManyInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersCreateInput = {
    joined_at?: Date | string | null
    group: study_groupsCreateNestedOneWithoutMembersInput
    student: usersCreateNestedOneWithoutGroup_membershipsInput
  }

  export type group_membersUncheckedCreateInput = {
    group_id: bigint | number
    student_id: bigint | number
    joined_at?: Date | string | null
  }

  export type group_membersUpdateInput = {
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: study_groupsUpdateOneRequiredWithoutMembersNestedInput
    student?: usersUpdateOneRequiredWithoutGroup_membershipsNestedInput
  }

  export type group_membersUncheckedUpdateInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersCreateManyInput = {
    group_id: bigint | number
    student_id: bigint | number
    joined_at?: Date | string | null
  }

  export type group_membersUpdateManyMutationInput = {
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersUncheckedUpdateManyInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsCreateInput = {
    assignment_id?: bigint | number
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
    test_plan: test_plansCreateNestedOneWithoutAssignmentsInput
    assigner: usersCreateNestedOneWithoutAssignments_createdInput
    group?: study_groupsCreateNestedOneWithoutAssignmentsInput
    student?: usersCreateNestedOneWithoutAssignments_receivedInput
  }

  export type test_assignmentsUncheckedCreateInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    assigned_by: bigint | number
    group_id?: bigint | number | null
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsUpdateInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_plan?: test_plansUpdateOneRequiredWithoutAssignmentsNestedInput
    assigner?: usersUpdateOneRequiredWithoutAssignments_createdNestedInput
    group?: study_groupsUpdateOneWithoutAssignmentsNestedInput
    student?: usersUpdateOneWithoutAssignments_receivedNestedInput
  }

  export type test_assignmentsUncheckedUpdateInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsCreateManyInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    assigned_by: bigint | number
    group_id?: bigint | number | null
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsUpdateManyMutationInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUncheckedUpdateManyInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Enumexam_boards_input_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.exam_boards_input_type | Enumexam_boards_input_typeFieldRefInput<$PrismaModel>
    in?: $Enums.exam_boards_input_type[]
    notIn?: $Enums.exam_boards_input_type[]
    not?: NestedEnumexam_boards_input_typeFilter<$PrismaModel> | $Enums.exam_boards_input_type
  }

  export type Test_plansListRelationFilter = {
    every?: test_plansWhereInput
    some?: test_plansWhereInput
    none?: test_plansWhereInput
  }

  export type Test_templatesListRelationFilter = {
    every?: test_templatesWhereInput
    some?: test_templatesWhereInput
    none?: test_templatesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type test_plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_templatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type exam_boardsCountOrderByAggregateInput = {
    board_id?: SortOrder
    board_name?: SortOrder
    description?: SortOrder
    input_type?: SortOrder
  }

  export type exam_boardsAvgOrderByAggregateInput = {
    board_id?: SortOrder
  }

  export type exam_boardsMaxOrderByAggregateInput = {
    board_id?: SortOrder
    board_name?: SortOrder
    description?: SortOrder
    input_type?: SortOrder
  }

  export type exam_boardsMinOrderByAggregateInput = {
    board_id?: SortOrder
    board_name?: SortOrder
    description?: SortOrder
    input_type?: SortOrder
  }

  export type exam_boardsSumOrderByAggregateInput = {
    board_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumexam_boards_input_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.exam_boards_input_type | Enumexam_boards_input_typeFieldRefInput<$PrismaModel>
    in?: $Enums.exam_boards_input_type[]
    notIn?: $Enums.exam_boards_input_type[]
    not?: NestedEnumexam_boards_input_typeWithAggregatesFilter<$PrismaModel> | $Enums.exam_boards_input_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumexam_boards_input_typeFilter<$PrismaModel>
    _max?: NestedEnumexam_boards_input_typeFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SubtopicsRelationFilter = {
    is?: subtopicsWhereInput
    isNot?: subtopicsWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type Question_set_itemsListRelationFilter = {
    every?: question_set_itemsWhereInput
    some?: question_set_itemsWhereInput
    none?: question_set_itemsWhereInput
  }

  export type question_set_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionsCountOrderByAggregateInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    question_text?: SortOrder
    question_text_plain?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    correct_answer_plain?: SortOrder
    solution?: SortOrder
    solution_plain?: SortOrder
    difficulty_level?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    active?: SortOrder
  }

  export type questionsAvgOrderByAggregateInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    difficulty_level?: SortOrder
    created_by?: SortOrder
  }

  export type questionsMaxOrderByAggregateInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    question_text?: SortOrder
    question_text_plain?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    correct_answer_plain?: SortOrder
    solution?: SortOrder
    solution_plain?: SortOrder
    difficulty_level?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    active?: SortOrder
  }

  export type questionsMinOrderByAggregateInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    question_text?: SortOrder
    question_text_plain?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    correct_answer_plain?: SortOrder
    solution?: SortOrder
    solution_plain?: SortOrder
    difficulty_level?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    active?: SortOrder
  }

  export type questionsSumOrderByAggregateInput = {
    question_id?: SortOrder
    subtopic_id?: SortOrder
    difficulty_level?: SortOrder
    created_by?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Question_setsRelationFilter = {
    is?: question_setsWhereInput
    isNot?: question_setsWhereInput
  }

  export type QuestionsRelationFilter = {
    is?: questionsWhereInput
    isNot?: questionsWhereInput
  }

  export type question_set_itemsCountOrderByAggregateInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
  }

  export type question_set_itemsAvgOrderByAggregateInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
  }

  export type question_set_itemsMaxOrderByAggregateInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
  }

  export type question_set_itemsMinOrderByAggregateInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
  }

  export type question_set_itemsSumOrderByAggregateInput = {
    item_id?: SortOrder
    set_id?: SortOrder
    question_id?: SortOrder
    sequence?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Test_plan_question_setsListRelationFilter = {
    every?: test_plan_question_setsWhereInput
    some?: test_plan_question_setsWhereInput
    none?: test_plan_question_setsWhereInput
  }

  export type test_plan_question_setsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type question_setsCountOrderByAggregateInput = {
    set_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    metadata?: SortOrder
  }

  export type question_setsAvgOrderByAggregateInput = {
    set_id?: SortOrder
    created_by?: SortOrder
  }

  export type question_setsMaxOrderByAggregateInput = {
    set_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    metadata?: SortOrder
  }

  export type question_setsMinOrderByAggregateInput = {
    set_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    metadata?: SortOrder
  }

  export type question_setsSumOrderByAggregateInput = {
    set_id?: SortOrder
    created_by?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type User_rolesListRelationFilter = {
    every?: user_rolesWhereInput
    some?: user_rolesWhereInput
    none?: user_rolesWhereInput
  }

  export type user_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type TopicsListRelationFilter = {
    every?: topicsWhereInput
    some?: topicsWhereInput
    none?: topicsWhereInput
  }

  export type Subject_masteryListRelationFilter = {
    every?: subject_masteryWhereInput
    some?: subject_masteryWhereInput
    none?: subject_masteryWhereInput
  }

  export type Difficulty_levelsListRelationFilter = {
    every?: difficulty_levelsWhereInput
    some?: difficulty_levelsWhereInput
    none?: difficulty_levelsWhereInput
  }

  export type topicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subject_masteryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type difficulty_levelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectsCountOrderByAggregateInput = {
    subject_id?: SortOrder
    subject_name?: SortOrder
    description?: SortOrder
  }

  export type subjectsAvgOrderByAggregateInput = {
    subject_id?: SortOrder
  }

  export type subjectsMaxOrderByAggregateInput = {
    subject_id?: SortOrder
    subject_name?: SortOrder
    description?: SortOrder
  }

  export type subjectsMinOrderByAggregateInput = {
    subject_id?: SortOrder
    subject_name?: SortOrder
    description?: SortOrder
  }

  export type subjectsSumOrderByAggregateInput = {
    subject_id?: SortOrder
  }

  export type QuestionsListRelationFilter = {
    every?: questionsWhereInput
    some?: questionsWhereInput
    none?: questionsWhereInput
  }

  export type TopicsRelationFilter = {
    is?: topicsWhereInput
    isNot?: topicsWhereInput
  }

  export type questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subtopicsTopic_idSubtopic_nameCompoundUniqueInput = {
    topic_id: number
    subtopic_name: string
  }

  export type subtopicsCountOrderByAggregateInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
    subtopic_name?: SortOrder
    description?: SortOrder
  }

  export type subtopicsAvgOrderByAggregateInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
  }

  export type subtopicsMaxOrderByAggregateInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
    subtopic_name?: SortOrder
    description?: SortOrder
  }

  export type subtopicsMinOrderByAggregateInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
    subtopic_name?: SortOrder
    description?: SortOrder
  }

  export type subtopicsSumOrderByAggregateInput = {
    subtopic_id?: SortOrder
    topic_id?: SortOrder
  }

  export type Enumtest_executions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_executions_status | Enumtest_executions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_executions_status[]
    notIn?: $Enums.test_executions_status[]
    not?: NestedEnumtest_executions_statusFilter<$PrismaModel> | $Enums.test_executions_status
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Test_plansRelationFilter = {
    is?: test_plansWhereInput
    isNot?: test_plansWhereInput
  }

  export type test_executionsCountOrderByAggregateInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    test_data?: SortOrder
    score?: SortOrder
  }

  export type test_executionsAvgOrderByAggregateInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    score?: SortOrder
  }

  export type test_executionsMaxOrderByAggregateInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    test_data?: SortOrder
    score?: SortOrder
  }

  export type test_executionsMinOrderByAggregateInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    test_data?: SortOrder
    score?: SortOrder
  }

  export type test_executionsSumOrderByAggregateInput = {
    execution_id?: SortOrder
    test_plan_id?: SortOrder
    student_id?: SortOrder
    score?: SortOrder
  }

  export type Enumtest_executions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_executions_status | Enumtest_executions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_executions_status[]
    notIn?: $Enums.test_executions_status[]
    not?: NestedEnumtest_executions_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_executions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_executions_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_executions_statusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type test_plan_question_setsCountOrderByAggregateInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
  }

  export type test_plan_question_setsAvgOrderByAggregateInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
  }

  export type test_plan_question_setsMaxOrderByAggregateInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
  }

  export type test_plan_question_setsMinOrderByAggregateInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
    created_at?: SortOrder
  }

  export type test_plan_question_setsSumOrderByAggregateInput = {
    link_id?: SortOrder
    test_plan_id?: SortOrder
    set_id?: SortOrder
    sequence?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type Enumtest_plans_test_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_test_type | Enumtest_plans_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_test_type[]
    notIn?: $Enums.test_plans_test_type[]
    not?: NestedEnumtest_plans_test_typeFilter<$PrismaModel> | $Enums.test_plans_test_type
  }

  export type Enumtest_plans_timing_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_timing_type | Enumtest_plans_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_timing_type[]
    notIn?: $Enums.test_plans_timing_type[]
    not?: NestedEnumtest_plans_timing_typeFilter<$PrismaModel> | $Enums.test_plans_timing_type
  }

  export type Test_executionsListRelationFilter = {
    every?: test_executionsWhereInput
    some?: test_executionsWhereInput
    none?: test_executionsWhereInput
  }

  export type Test_templatesNullableRelationFilter = {
    is?: test_templatesWhereInput | null
    isNot?: test_templatesWhereInput | null
  }

  export type Exam_boardsRelationFilter = {
    is?: exam_boardsWhereInput
    isNot?: exam_boardsWhereInput
  }

  export type Study_groupsListRelationFilter = {
    every?: study_groupsWhereInput
    some?: study_groupsWhereInput
    none?: study_groupsWhereInput
  }

  export type Test_assignmentsListRelationFilter = {
    every?: test_assignmentsWhereInput
    some?: test_assignmentsWhereInput
    none?: test_assignmentsWhereInput
  }

  export type test_executionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_plansCountOrderByAggregateInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
    planned_at?: SortOrder
    configuration?: SortOrder
  }

  export type test_plansAvgOrderByAggregateInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrder
    board_id?: SortOrder
    time_limit?: SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
  }

  export type test_plansMaxOrderByAggregateInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
    planned_at?: SortOrder
    configuration?: SortOrder
  }

  export type test_plansMinOrderByAggregateInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
    planned_at?: SortOrder
    configuration?: SortOrder
  }

  export type test_plansSumOrderByAggregateInput = {
    test_plan_id?: SortOrder
    template_id?: SortOrder
    board_id?: SortOrder
    time_limit?: SortOrder
    student_id?: SortOrder
    planned_by?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type Enumtest_plans_test_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_test_type | Enumtest_plans_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_test_type[]
    notIn?: $Enums.test_plans_test_type[]
    not?: NestedEnumtest_plans_test_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_plans_test_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plans_test_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_plans_test_typeFilter<$PrismaModel>
  }

  export type Enumtest_plans_timing_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_timing_type | Enumtest_plans_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_timing_type[]
    notIn?: $Enums.test_plans_timing_type[]
    not?: NestedEnumtest_plans_timing_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_plans_timing_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plans_timing_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_plans_timing_typeFilter<$PrismaModel>
  }

  export type Enumtest_templates_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_source | Enumtest_templates_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_source[]
    notIn?: $Enums.test_templates_source[]
    not?: NestedEnumtest_templates_sourceFilter<$PrismaModel> | $Enums.test_templates_source
  }

  export type Enumtest_templates_test_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_test_type | Enumtest_templates_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_test_type[]
    notIn?: $Enums.test_templates_test_type[]
    not?: NestedEnumtest_templates_test_typeFilter<$PrismaModel> | $Enums.test_templates_test_type
  }

  export type Enumtest_templates_timing_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_timing_type | Enumtest_templates_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_timing_type[]
    notIn?: $Enums.test_templates_timing_type[]
    not?: NestedEnumtest_templates_timing_typeFilter<$PrismaModel> | $Enums.test_templates_timing_type
  }

  export type test_templatesCountOrderByAggregateInput = {
    template_id?: SortOrder
    template_name?: SortOrder
    source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrder
    configuration?: SortOrder
    active?: SortOrder
  }

  export type test_templatesAvgOrderByAggregateInput = {
    template_id?: SortOrder
    created_by?: SortOrder
    board_id?: SortOrder
    time_limit?: SortOrder
  }

  export type test_templatesMaxOrderByAggregateInput = {
    template_id?: SortOrder
    template_name?: SortOrder
    source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrder
    configuration?: SortOrder
    active?: SortOrder
  }

  export type test_templatesMinOrderByAggregateInput = {
    template_id?: SortOrder
    template_name?: SortOrder
    source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    board_id?: SortOrder
    test_type?: SortOrder
    timing_type?: SortOrder
    time_limit?: SortOrder
    configuration?: SortOrder
    active?: SortOrder
  }

  export type test_templatesSumOrderByAggregateInput = {
    template_id?: SortOrder
    created_by?: SortOrder
    board_id?: SortOrder
    time_limit?: SortOrder
  }

  export type Enumtest_templates_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_source | Enumtest_templates_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_source[]
    notIn?: $Enums.test_templates_source[]
    not?: NestedEnumtest_templates_sourceWithAggregatesFilter<$PrismaModel> | $Enums.test_templates_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_templates_sourceFilter<$PrismaModel>
    _max?: NestedEnumtest_templates_sourceFilter<$PrismaModel>
  }

  export type Enumtest_templates_test_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_test_type | Enumtest_templates_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_test_type[]
    notIn?: $Enums.test_templates_test_type[]
    not?: NestedEnumtest_templates_test_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_templates_test_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_templates_test_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_templates_test_typeFilter<$PrismaModel>
  }

  export type Enumtest_templates_timing_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_timing_type | Enumtest_templates_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_timing_type[]
    notIn?: $Enums.test_templates_timing_type[]
    not?: NestedEnumtest_templates_timing_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_templates_timing_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_templates_timing_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_templates_timing_typeFilter<$PrismaModel>
  }

  export type SubtopicsListRelationFilter = {
    every?: subtopicsWhereInput
    some?: subtopicsWhereInput
    none?: subtopicsWhereInput
  }

  export type SubjectsRelationFilter = {
    is?: subjectsWhereInput
    isNot?: subjectsWhereInput
  }

  export type subtopicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type topicsSubject_idTopic_nameCompoundUniqueInput = {
    subject_id: number
    topic_name: string
  }

  export type topicsCountOrderByAggregateInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
    topic_name?: SortOrder
    description?: SortOrder
  }

  export type topicsAvgOrderByAggregateInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
  }

  export type topicsMaxOrderByAggregateInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
    topic_name?: SortOrder
    description?: SortOrder
  }

  export type topicsMinOrderByAggregateInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
    topic_name?: SortOrder
    description?: SortOrder
  }

  export type topicsSumOrderByAggregateInput = {
    topic_id?: SortOrder
    subject_id?: SortOrder
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type user_rolesUser_idRole_idCompoundUniqueInput = {
    user_id: bigint | number
    role_id: number
  }

  export type user_rolesCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type Question_setsListRelationFilter = {
    every?: question_setsWhereInput
    some?: question_setsWhereInput
    none?: question_setsWhereInput
  }

  export type Student_achievementsListRelationFilter = {
    every?: student_achievementsWhereInput
    some?: student_achievementsWhereInput
    none?: student_achievementsWhereInput
  }

  export type Group_membersListRelationFilter = {
    every?: group_membersWhereInput
    some?: group_membersWhereInput
    none?: group_membersWhereInput
  }

  export type Student_progressNullableRelationFilter = {
    is?: student_progressWhereInput | null
    isNot?: student_progressWhereInput | null
  }

  export type Activity_logListRelationFilter = {
    every?: activity_logWhereInput
    some?: activity_logWhereInput
    none?: activity_logWhereInput
  }

  export type Student_rewardsListRelationFilter = {
    every?: student_rewardsWhereInput
    some?: student_rewardsWhereInput
    none?: student_rewardsWhereInput
  }

  export type Student_guardiansListRelationFilter = {
    every?: student_guardiansWhereInput
    some?: student_guardiansWhereInput
    none?: student_guardiansWhereInput
  }

  export type question_setsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_achievementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type group_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type activity_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_rewardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_guardiansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrder
    active?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrder
    active?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrder
    active?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type difficulty_levelsCountOrderByAggregateInput = {
    level_id?: SortOrder
    level_name?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
    purpose?: SortOrder
    characteristics?: SortOrder
    focus_area?: SortOrder
    steps_required?: SortOrder
    created_at?: SortOrder
    active?: SortOrder
  }

  export type difficulty_levelsAvgOrderByAggregateInput = {
    level_id?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
  }

  export type difficulty_levelsMaxOrderByAggregateInput = {
    level_id?: SortOrder
    level_name?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
    purpose?: SortOrder
    characteristics?: SortOrder
    focus_area?: SortOrder
    steps_required?: SortOrder
    created_at?: SortOrder
    active?: SortOrder
  }

  export type difficulty_levelsMinOrderByAggregateInput = {
    level_id?: SortOrder
    level_name?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
    purpose?: SortOrder
    characteristics?: SortOrder
    focus_area?: SortOrder
    steps_required?: SortOrder
    created_at?: SortOrder
    active?: SortOrder
  }

  export type difficulty_levelsSumOrderByAggregateInput = {
    level_id?: SortOrder
    level_value?: SortOrder
    subject_id?: SortOrder
  }

  export type student_progressCountOrderByAggregateInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    last_activity_date?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_progressAvgOrderByAggregateInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    total_points?: SortOrder
  }

  export type student_progressMaxOrderByAggregateInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    last_activity_date?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_progressMinOrderByAggregateInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    last_activity_date?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_progressSumOrderByAggregateInput = {
    user_id?: SortOrder
    level?: SortOrder
    current_xp?: SortOrder
    next_level_xp?: SortOrder
    streak_days?: SortOrder
    total_points?: SortOrder
  }

  export type achievementsCountOrderByAggregateInput = {
    achievement_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    required_criteria?: SortOrder
    created_at?: SortOrder
  }

  export type achievementsAvgOrderByAggregateInput = {
    achievement_id?: SortOrder
    points?: SortOrder
  }

  export type achievementsMaxOrderByAggregateInput = {
    achievement_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    required_criteria?: SortOrder
    created_at?: SortOrder
  }

  export type achievementsMinOrderByAggregateInput = {
    achievement_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    required_criteria?: SortOrder
    created_at?: SortOrder
  }

  export type achievementsSumOrderByAggregateInput = {
    achievement_id?: SortOrder
    points?: SortOrder
  }

  export type AchievementsRelationFilter = {
    is?: achievementsWhereInput
    isNot?: achievementsWhereInput
  }

  export type student_achievementsUser_idAchievement_idCompoundUniqueInput = {
    user_id: bigint | number
    achievement_id: bigint | number
  }

  export type student_achievementsCountOrderByAggregateInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    unlocked_at?: SortOrder
    progress?: SortOrder
  }

  export type student_achievementsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    progress?: SortOrder
  }

  export type student_achievementsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    unlocked_at?: SortOrder
    progress?: SortOrder
  }

  export type student_achievementsMinOrderByAggregateInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    unlocked_at?: SortOrder
    progress?: SortOrder
  }

  export type student_achievementsSumOrderByAggregateInput = {
    user_id?: SortOrder
    achievement_id?: SortOrder
    progress?: SortOrder
  }

  export type rewardsCountOrderByAggregateInput = {
    reward_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    icon?: SortOrder
    created_at?: SortOrder
  }

  export type rewardsAvgOrderByAggregateInput = {
    reward_id?: SortOrder
    cost?: SortOrder
  }

  export type rewardsMaxOrderByAggregateInput = {
    reward_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    icon?: SortOrder
    created_at?: SortOrder
  }

  export type rewardsMinOrderByAggregateInput = {
    reward_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    icon?: SortOrder
    created_at?: SortOrder
  }

  export type rewardsSumOrderByAggregateInput = {
    reward_id?: SortOrder
    cost?: SortOrder
  }

  export type RewardsRelationFilter = {
    is?: rewardsWhereInput
    isNot?: rewardsWhereInput
  }

  export type student_rewardsUser_idReward_idCompoundUniqueInput = {
    user_id: bigint | number
    reward_id: bigint | number
  }

  export type student_rewardsCountOrderByAggregateInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
    purchased_at?: SortOrder
  }

  export type student_rewardsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
  }

  export type student_rewardsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
    purchased_at?: SortOrder
  }

  export type student_rewardsMinOrderByAggregateInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
    purchased_at?: SortOrder
  }

  export type student_rewardsSumOrderByAggregateInput = {
    user_id?: SortOrder
    reward_id?: SortOrder
  }

  export type subject_masteryUser_idSubject_idCompoundUniqueInput = {
    user_id: bigint | number
    subject_id: number
  }

  export type subject_masteryCountOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
    last_test_date?: SortOrder
  }

  export type subject_masteryAvgOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
  }

  export type subject_masteryMaxOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
    last_test_date?: SortOrder
  }

  export type subject_masteryMinOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
    last_test_date?: SortOrder
  }

  export type subject_masterySumOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    mastery_level?: SortOrder
    total_questions_attempted?: SortOrder
    correct_answers?: SortOrder
  }

  export type activity_logCountOrderByAggregateInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    activity_type?: SortOrder
    xp_earned?: SortOrder
    details?: SortOrder
    created_at?: SortOrder
  }

  export type activity_logAvgOrderByAggregateInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    xp_earned?: SortOrder
  }

  export type activity_logMaxOrderByAggregateInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    activity_type?: SortOrder
    xp_earned?: SortOrder
    details?: SortOrder
    created_at?: SortOrder
  }

  export type activity_logMinOrderByAggregateInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    activity_type?: SortOrder
    xp_earned?: SortOrder
    details?: SortOrder
    created_at?: SortOrder
  }

  export type activity_logSumOrderByAggregateInput = {
    activity_id?: SortOrder
    user_id?: SortOrder
    xp_earned?: SortOrder
  }

  export type level_configCountOrderByAggregateInput = {
    level?: SortOrder
    xp_required?: SortOrder
    created_at?: SortOrder
  }

  export type level_configAvgOrderByAggregateInput = {
    level?: SortOrder
    xp_required?: SortOrder
  }

  export type level_configMaxOrderByAggregateInput = {
    level?: SortOrder
    xp_required?: SortOrder
    created_at?: SortOrder
  }

  export type level_configMinOrderByAggregateInput = {
    level?: SortOrder
    xp_required?: SortOrder
    created_at?: SortOrder
  }

  export type level_configSumOrderByAggregateInput = {
    level?: SortOrder
    xp_required?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_groupsCountOrderByAggregateInput = {
    group_id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
    tutor_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type study_groupsAvgOrderByAggregateInput = {
    group_id?: SortOrder
    tutor_id?: SortOrder
  }

  export type study_groupsMaxOrderByAggregateInput = {
    group_id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
    tutor_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type study_groupsMinOrderByAggregateInput = {
    group_id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
    tutor_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type study_groupsSumOrderByAggregateInput = {
    group_id?: SortOrder
    tutor_id?: SortOrder
  }

  export type EnumGuardianRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationType | EnumGuardianRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationType[]
    notIn?: $Enums.GuardianRelationType[]
    not?: NestedEnumGuardianRelationTypeFilter<$PrismaModel> | $Enums.GuardianRelationType
  }

  export type EnumGuardianRelationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationStatus | EnumGuardianRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationStatus[]
    notIn?: $Enums.GuardianRelationStatus[]
    not?: NestedEnumGuardianRelationStatusFilter<$PrismaModel> | $Enums.GuardianRelationStatus
  }

  export type student_guardiansGuardian_idStudent_idCompoundUniqueInput = {
    guardian_id: bigint | number
    student_id: bigint | number
  }

  export type student_guardiansCountOrderByAggregateInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
    relationship_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_guardiansAvgOrderByAggregateInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
  }

  export type student_guardiansMaxOrderByAggregateInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
    relationship_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_guardiansMinOrderByAggregateInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
    relationship_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_guardiansSumOrderByAggregateInput = {
    relationship_id?: SortOrder
    guardian_id?: SortOrder
    student_id?: SortOrder
  }

  export type EnumGuardianRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationType | EnumGuardianRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationType[]
    notIn?: $Enums.GuardianRelationType[]
    not?: NestedEnumGuardianRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.GuardianRelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuardianRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumGuardianRelationTypeFilter<$PrismaModel>
  }

  export type EnumGuardianRelationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationStatus | EnumGuardianRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationStatus[]
    notIn?: $Enums.GuardianRelationStatus[]
    not?: NestedEnumGuardianRelationStatusWithAggregatesFilter<$PrismaModel> | $Enums.GuardianRelationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuardianRelationStatusFilter<$PrismaModel>
    _max?: NestedEnumGuardianRelationStatusFilter<$PrismaModel>
  }

  export type Study_groupsRelationFilter = {
    is?: study_groupsWhereInput
    isNot?: study_groupsWhereInput
  }

  export type group_membersGroup_idStudent_idCompoundUniqueInput = {
    group_id: bigint | number
    student_id: bigint | number
  }

  export type group_membersCountOrderByAggregateInput = {
    group_id?: SortOrder
    student_id?: SortOrder
    joined_at?: SortOrder
  }

  export type group_membersAvgOrderByAggregateInput = {
    group_id?: SortOrder
    student_id?: SortOrder
  }

  export type group_membersMaxOrderByAggregateInput = {
    group_id?: SortOrder
    student_id?: SortOrder
    joined_at?: SortOrder
  }

  export type group_membersMinOrderByAggregateInput = {
    group_id?: SortOrder
    student_id?: SortOrder
    joined_at?: SortOrder
  }

  export type group_membersSumOrderByAggregateInput = {
    group_id?: SortOrder
    student_id?: SortOrder
  }

  export type EnumTestAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestAssignmentStatus | EnumTestAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestAssignmentStatus[]
    notIn?: $Enums.TestAssignmentStatus[]
    not?: NestedEnumTestAssignmentStatusFilter<$PrismaModel> | $Enums.TestAssignmentStatus
  }

  export type Study_groupsNullableRelationFilter = {
    is?: study_groupsWhereInput | null
    isNot?: study_groupsWhereInput | null
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type test_assignmentsCountOrderByAggregateInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrder
    student_id?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type test_assignmentsAvgOrderByAggregateInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrder
    student_id?: SortOrder
  }

  export type test_assignmentsMaxOrderByAggregateInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrder
    student_id?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type test_assignmentsMinOrderByAggregateInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrder
    student_id?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type test_assignmentsSumOrderByAggregateInput = {
    assignment_id?: SortOrder
    test_plan_id?: SortOrder
    assigned_by?: SortOrder
    group_id?: SortOrder
    student_id?: SortOrder
  }

  export type EnumTestAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestAssignmentStatus | EnumTestAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestAssignmentStatus[]
    notIn?: $Enums.TestAssignmentStatus[]
    not?: NestedEnumTestAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestAssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumTestAssignmentStatusFilter<$PrismaModel>
  }

  export type test_plansCreateNestedManyWithoutExam_boardsInput = {
    create?: XOR<test_plansCreateWithoutExam_boardsInput, test_plansUncheckedCreateWithoutExam_boardsInput> | test_plansCreateWithoutExam_boardsInput[] | test_plansUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutExam_boardsInput | test_plansCreateOrConnectWithoutExam_boardsInput[]
    createMany?: test_plansCreateManyExam_boardsInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type test_templatesCreateNestedManyWithoutExam_boardsInput = {
    create?: XOR<test_templatesCreateWithoutExam_boardsInput, test_templatesUncheckedCreateWithoutExam_boardsInput> | test_templatesCreateWithoutExam_boardsInput[] | test_templatesUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutExam_boardsInput | test_templatesCreateOrConnectWithoutExam_boardsInput[]
    createMany?: test_templatesCreateManyExam_boardsInputEnvelope
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
  }

  export type test_plansUncheckedCreateNestedManyWithoutExam_boardsInput = {
    create?: XOR<test_plansCreateWithoutExam_boardsInput, test_plansUncheckedCreateWithoutExam_boardsInput> | test_plansCreateWithoutExam_boardsInput[] | test_plansUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutExam_boardsInput | test_plansCreateOrConnectWithoutExam_boardsInput[]
    createMany?: test_plansCreateManyExam_boardsInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type test_templatesUncheckedCreateNestedManyWithoutExam_boardsInput = {
    create?: XOR<test_templatesCreateWithoutExam_boardsInput, test_templatesUncheckedCreateWithoutExam_boardsInput> | test_templatesCreateWithoutExam_boardsInput[] | test_templatesUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutExam_boardsInput | test_templatesCreateOrConnectWithoutExam_boardsInput[]
    createMany?: test_templatesCreateManyExam_boardsInputEnvelope
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Enumexam_boards_input_typeFieldUpdateOperationsInput = {
    set?: $Enums.exam_boards_input_type
  }

  export type test_plansUpdateManyWithoutExam_boardsNestedInput = {
    create?: XOR<test_plansCreateWithoutExam_boardsInput, test_plansUncheckedCreateWithoutExam_boardsInput> | test_plansCreateWithoutExam_boardsInput[] | test_plansUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutExam_boardsInput | test_plansCreateOrConnectWithoutExam_boardsInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutExam_boardsInput | test_plansUpsertWithWhereUniqueWithoutExam_boardsInput[]
    createMany?: test_plansCreateManyExam_boardsInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutExam_boardsInput | test_plansUpdateWithWhereUniqueWithoutExam_boardsInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutExam_boardsInput | test_plansUpdateManyWithWhereWithoutExam_boardsInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_templatesUpdateManyWithoutExam_boardsNestedInput = {
    create?: XOR<test_templatesCreateWithoutExam_boardsInput, test_templatesUncheckedCreateWithoutExam_boardsInput> | test_templatesCreateWithoutExam_boardsInput[] | test_templatesUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutExam_boardsInput | test_templatesCreateOrConnectWithoutExam_boardsInput[]
    upsert?: test_templatesUpsertWithWhereUniqueWithoutExam_boardsInput | test_templatesUpsertWithWhereUniqueWithoutExam_boardsInput[]
    createMany?: test_templatesCreateManyExam_boardsInputEnvelope
    set?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    disconnect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    delete?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    update?: test_templatesUpdateWithWhereUniqueWithoutExam_boardsInput | test_templatesUpdateWithWhereUniqueWithoutExam_boardsInput[]
    updateMany?: test_templatesUpdateManyWithWhereWithoutExam_boardsInput | test_templatesUpdateManyWithWhereWithoutExam_boardsInput[]
    deleteMany?: test_templatesScalarWhereInput | test_templatesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type test_plansUncheckedUpdateManyWithoutExam_boardsNestedInput = {
    create?: XOR<test_plansCreateWithoutExam_boardsInput, test_plansUncheckedCreateWithoutExam_boardsInput> | test_plansCreateWithoutExam_boardsInput[] | test_plansUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutExam_boardsInput | test_plansCreateOrConnectWithoutExam_boardsInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutExam_boardsInput | test_plansUpsertWithWhereUniqueWithoutExam_boardsInput[]
    createMany?: test_plansCreateManyExam_boardsInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutExam_boardsInput | test_plansUpdateWithWhereUniqueWithoutExam_boardsInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutExam_boardsInput | test_plansUpdateManyWithWhereWithoutExam_boardsInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_templatesUncheckedUpdateManyWithoutExam_boardsNestedInput = {
    create?: XOR<test_templatesCreateWithoutExam_boardsInput, test_templatesUncheckedCreateWithoutExam_boardsInput> | test_templatesCreateWithoutExam_boardsInput[] | test_templatesUncheckedCreateWithoutExam_boardsInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutExam_boardsInput | test_templatesCreateOrConnectWithoutExam_boardsInput[]
    upsert?: test_templatesUpsertWithWhereUniqueWithoutExam_boardsInput | test_templatesUpsertWithWhereUniqueWithoutExam_boardsInput[]
    createMany?: test_templatesCreateManyExam_boardsInputEnvelope
    set?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    disconnect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    delete?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    update?: test_templatesUpdateWithWhereUniqueWithoutExam_boardsInput | test_templatesUpdateWithWhereUniqueWithoutExam_boardsInput[]
    updateMany?: test_templatesUpdateManyWithWhereWithoutExam_boardsInput | test_templatesUpdateManyWithWhereWithoutExam_boardsInput[]
    deleteMany?: test_templatesScalarWhereInput | test_templatesScalarWhereInput[]
  }

  export type subtopicsCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<subtopicsCreateWithoutQuestionsInput, subtopicsUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: subtopicsCreateOrConnectWithoutQuestionsInput
    connect?: subtopicsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<usersCreateWithoutQuestionsInput, usersUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutQuestionsInput
    connect?: usersWhereUniqueInput
  }

  export type question_set_itemsCreateNestedManyWithoutQuestionInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestionInput, question_set_itemsUncheckedCreateWithoutQuestionInput> | question_set_itemsCreateWithoutQuestionInput[] | question_set_itemsUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestionInput | question_set_itemsCreateOrConnectWithoutQuestionInput[]
    createMany?: question_set_itemsCreateManyQuestionInputEnvelope
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
  }

  export type question_set_itemsUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestionInput, question_set_itemsUncheckedCreateWithoutQuestionInput> | question_set_itemsCreateWithoutQuestionInput[] | question_set_itemsUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestionInput | question_set_itemsCreateOrConnectWithoutQuestionInput[]
    createMany?: question_set_itemsCreateManyQuestionInputEnvelope
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type subtopicsUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<subtopicsCreateWithoutQuestionsInput, subtopicsUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: subtopicsCreateOrConnectWithoutQuestionsInput
    upsert?: subtopicsUpsertWithoutQuestionsInput
    connect?: subtopicsWhereUniqueInput
    update?: XOR<XOR<subtopicsUpdateToOneWithWhereWithoutQuestionsInput, subtopicsUpdateWithoutQuestionsInput>, subtopicsUncheckedUpdateWithoutQuestionsInput>
  }

  export type usersUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<usersCreateWithoutQuestionsInput, usersUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutQuestionsInput
    upsert?: usersUpsertWithoutQuestionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutQuestionsInput, usersUpdateWithoutQuestionsInput>, usersUncheckedUpdateWithoutQuestionsInput>
  }

  export type question_set_itemsUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestionInput, question_set_itemsUncheckedCreateWithoutQuestionInput> | question_set_itemsCreateWithoutQuestionInput[] | question_set_itemsUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestionInput | question_set_itemsCreateOrConnectWithoutQuestionInput[]
    upsert?: question_set_itemsUpsertWithWhereUniqueWithoutQuestionInput | question_set_itemsUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: question_set_itemsCreateManyQuestionInputEnvelope
    set?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    disconnect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    delete?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    update?: question_set_itemsUpdateWithWhereUniqueWithoutQuestionInput | question_set_itemsUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: question_set_itemsUpdateManyWithWhereWithoutQuestionInput | question_set_itemsUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: question_set_itemsScalarWhereInput | question_set_itemsScalarWhereInput[]
  }

  export type question_set_itemsUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestionInput, question_set_itemsUncheckedCreateWithoutQuestionInput> | question_set_itemsCreateWithoutQuestionInput[] | question_set_itemsUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestionInput | question_set_itemsCreateOrConnectWithoutQuestionInput[]
    upsert?: question_set_itemsUpsertWithWhereUniqueWithoutQuestionInput | question_set_itemsUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: question_set_itemsCreateManyQuestionInputEnvelope
    set?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    disconnect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    delete?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    update?: question_set_itemsUpdateWithWhereUniqueWithoutQuestionInput | question_set_itemsUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: question_set_itemsUpdateManyWithWhereWithoutQuestionInput | question_set_itemsUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: question_set_itemsScalarWhereInput | question_set_itemsScalarWhereInput[]
  }

  export type question_setsCreateNestedOneWithoutQuestion_set_itemsInput = {
    create?: XOR<question_setsCreateWithoutQuestion_set_itemsInput, question_setsUncheckedCreateWithoutQuestion_set_itemsInput>
    connectOrCreate?: question_setsCreateOrConnectWithoutQuestion_set_itemsInput
    connect?: question_setsWhereUniqueInput
  }

  export type questionsCreateNestedOneWithoutQuestion_set_itemsInput = {
    create?: XOR<questionsCreateWithoutQuestion_set_itemsInput, questionsUncheckedCreateWithoutQuestion_set_itemsInput>
    connectOrCreate?: questionsCreateOrConnectWithoutQuestion_set_itemsInput
    connect?: questionsWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type question_setsUpdateOneRequiredWithoutQuestion_set_itemsNestedInput = {
    create?: XOR<question_setsCreateWithoutQuestion_set_itemsInput, question_setsUncheckedCreateWithoutQuestion_set_itemsInput>
    connectOrCreate?: question_setsCreateOrConnectWithoutQuestion_set_itemsInput
    upsert?: question_setsUpsertWithoutQuestion_set_itemsInput
    connect?: question_setsWhereUniqueInput
    update?: XOR<XOR<question_setsUpdateToOneWithWhereWithoutQuestion_set_itemsInput, question_setsUpdateWithoutQuestion_set_itemsInput>, question_setsUncheckedUpdateWithoutQuestion_set_itemsInput>
  }

  export type questionsUpdateOneRequiredWithoutQuestion_set_itemsNestedInput = {
    create?: XOR<questionsCreateWithoutQuestion_set_itemsInput, questionsUncheckedCreateWithoutQuestion_set_itemsInput>
    connectOrCreate?: questionsCreateOrConnectWithoutQuestion_set_itemsInput
    upsert?: questionsUpsertWithoutQuestion_set_itemsInput
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutQuestion_set_itemsInput, questionsUpdateWithoutQuestion_set_itemsInput>, questionsUncheckedUpdateWithoutQuestion_set_itemsInput>
  }

  export type usersCreateNestedOneWithoutCreated_question_setsInput = {
    create?: XOR<usersCreateWithoutCreated_question_setsInput, usersUncheckedCreateWithoutCreated_question_setsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreated_question_setsInput
    connect?: usersWhereUniqueInput
  }

  export type question_set_itemsCreateNestedManyWithoutQuestion_setInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestion_setInput, question_set_itemsUncheckedCreateWithoutQuestion_setInput> | question_set_itemsCreateWithoutQuestion_setInput[] | question_set_itemsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestion_setInput | question_set_itemsCreateOrConnectWithoutQuestion_setInput[]
    createMany?: question_set_itemsCreateManyQuestion_setInputEnvelope
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
  }

  export type test_plan_question_setsCreateNestedManyWithoutQuestion_setInput = {
    create?: XOR<test_plan_question_setsCreateWithoutQuestion_setInput, test_plan_question_setsUncheckedCreateWithoutQuestion_setInput> | test_plan_question_setsCreateWithoutQuestion_setInput[] | test_plan_question_setsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutQuestion_setInput | test_plan_question_setsCreateOrConnectWithoutQuestion_setInput[]
    createMany?: test_plan_question_setsCreateManyQuestion_setInputEnvelope
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
  }

  export type question_set_itemsUncheckedCreateNestedManyWithoutQuestion_setInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestion_setInput, question_set_itemsUncheckedCreateWithoutQuestion_setInput> | question_set_itemsCreateWithoutQuestion_setInput[] | question_set_itemsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestion_setInput | question_set_itemsCreateOrConnectWithoutQuestion_setInput[]
    createMany?: question_set_itemsCreateManyQuestion_setInputEnvelope
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
  }

  export type test_plan_question_setsUncheckedCreateNestedManyWithoutQuestion_setInput = {
    create?: XOR<test_plan_question_setsCreateWithoutQuestion_setInput, test_plan_question_setsUncheckedCreateWithoutQuestion_setInput> | test_plan_question_setsCreateWithoutQuestion_setInput[] | test_plan_question_setsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutQuestion_setInput | test_plan_question_setsCreateOrConnectWithoutQuestion_setInput[]
    createMany?: test_plan_question_setsCreateManyQuestion_setInputEnvelope
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneRequiredWithoutCreated_question_setsNestedInput = {
    create?: XOR<usersCreateWithoutCreated_question_setsInput, usersUncheckedCreateWithoutCreated_question_setsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreated_question_setsInput
    upsert?: usersUpsertWithoutCreated_question_setsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCreated_question_setsInput, usersUpdateWithoutCreated_question_setsInput>, usersUncheckedUpdateWithoutCreated_question_setsInput>
  }

  export type question_set_itemsUpdateManyWithoutQuestion_setNestedInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestion_setInput, question_set_itemsUncheckedCreateWithoutQuestion_setInput> | question_set_itemsCreateWithoutQuestion_setInput[] | question_set_itemsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestion_setInput | question_set_itemsCreateOrConnectWithoutQuestion_setInput[]
    upsert?: question_set_itemsUpsertWithWhereUniqueWithoutQuestion_setInput | question_set_itemsUpsertWithWhereUniqueWithoutQuestion_setInput[]
    createMany?: question_set_itemsCreateManyQuestion_setInputEnvelope
    set?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    disconnect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    delete?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    update?: question_set_itemsUpdateWithWhereUniqueWithoutQuestion_setInput | question_set_itemsUpdateWithWhereUniqueWithoutQuestion_setInput[]
    updateMany?: question_set_itemsUpdateManyWithWhereWithoutQuestion_setInput | question_set_itemsUpdateManyWithWhereWithoutQuestion_setInput[]
    deleteMany?: question_set_itemsScalarWhereInput | question_set_itemsScalarWhereInput[]
  }

  export type test_plan_question_setsUpdateManyWithoutQuestion_setNestedInput = {
    create?: XOR<test_plan_question_setsCreateWithoutQuestion_setInput, test_plan_question_setsUncheckedCreateWithoutQuestion_setInput> | test_plan_question_setsCreateWithoutQuestion_setInput[] | test_plan_question_setsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutQuestion_setInput | test_plan_question_setsCreateOrConnectWithoutQuestion_setInput[]
    upsert?: test_plan_question_setsUpsertWithWhereUniqueWithoutQuestion_setInput | test_plan_question_setsUpsertWithWhereUniqueWithoutQuestion_setInput[]
    createMany?: test_plan_question_setsCreateManyQuestion_setInputEnvelope
    set?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    disconnect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    delete?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    update?: test_plan_question_setsUpdateWithWhereUniqueWithoutQuestion_setInput | test_plan_question_setsUpdateWithWhereUniqueWithoutQuestion_setInput[]
    updateMany?: test_plan_question_setsUpdateManyWithWhereWithoutQuestion_setInput | test_plan_question_setsUpdateManyWithWhereWithoutQuestion_setInput[]
    deleteMany?: test_plan_question_setsScalarWhereInput | test_plan_question_setsScalarWhereInput[]
  }

  export type question_set_itemsUncheckedUpdateManyWithoutQuestion_setNestedInput = {
    create?: XOR<question_set_itemsCreateWithoutQuestion_setInput, question_set_itemsUncheckedCreateWithoutQuestion_setInput> | question_set_itemsCreateWithoutQuestion_setInput[] | question_set_itemsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: question_set_itemsCreateOrConnectWithoutQuestion_setInput | question_set_itemsCreateOrConnectWithoutQuestion_setInput[]
    upsert?: question_set_itemsUpsertWithWhereUniqueWithoutQuestion_setInput | question_set_itemsUpsertWithWhereUniqueWithoutQuestion_setInput[]
    createMany?: question_set_itemsCreateManyQuestion_setInputEnvelope
    set?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    disconnect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    delete?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    connect?: question_set_itemsWhereUniqueInput | question_set_itemsWhereUniqueInput[]
    update?: question_set_itemsUpdateWithWhereUniqueWithoutQuestion_setInput | question_set_itemsUpdateWithWhereUniqueWithoutQuestion_setInput[]
    updateMany?: question_set_itemsUpdateManyWithWhereWithoutQuestion_setInput | question_set_itemsUpdateManyWithWhereWithoutQuestion_setInput[]
    deleteMany?: question_set_itemsScalarWhereInput | question_set_itemsScalarWhereInput[]
  }

  export type test_plan_question_setsUncheckedUpdateManyWithoutQuestion_setNestedInput = {
    create?: XOR<test_plan_question_setsCreateWithoutQuestion_setInput, test_plan_question_setsUncheckedCreateWithoutQuestion_setInput> | test_plan_question_setsCreateWithoutQuestion_setInput[] | test_plan_question_setsUncheckedCreateWithoutQuestion_setInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutQuestion_setInput | test_plan_question_setsCreateOrConnectWithoutQuestion_setInput[]
    upsert?: test_plan_question_setsUpsertWithWhereUniqueWithoutQuestion_setInput | test_plan_question_setsUpsertWithWhereUniqueWithoutQuestion_setInput[]
    createMany?: test_plan_question_setsCreateManyQuestion_setInputEnvelope
    set?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    disconnect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    delete?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    update?: test_plan_question_setsUpdateWithWhereUniqueWithoutQuestion_setInput | test_plan_question_setsUpdateWithWhereUniqueWithoutQuestion_setInput[]
    updateMany?: test_plan_question_setsUpdateManyWithWhereWithoutQuestion_setInput | test_plan_question_setsUpdateManyWithWhereWithoutQuestion_setInput[]
    deleteMany?: test_plan_question_setsScalarWhereInput | test_plan_question_setsScalarWhereInput[]
  }

  export type user_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type topicsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<topicsCreateWithoutSubjectsInput, topicsUncheckedCreateWithoutSubjectsInput> | topicsCreateWithoutSubjectsInput[] | topicsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: topicsCreateOrConnectWithoutSubjectsInput | topicsCreateOrConnectWithoutSubjectsInput[]
    createMany?: topicsCreateManySubjectsInputEnvelope
    connect?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
  }

  export type subject_masteryCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<subject_masteryCreateWithoutSubjectsInput, subject_masteryUncheckedCreateWithoutSubjectsInput> | subject_masteryCreateWithoutSubjectsInput[] | subject_masteryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutSubjectsInput | subject_masteryCreateOrConnectWithoutSubjectsInput[]
    createMany?: subject_masteryCreateManySubjectsInputEnvelope
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
  }

  export type difficulty_levelsCreateNestedManyWithoutSubjectInput = {
    create?: XOR<difficulty_levelsCreateWithoutSubjectInput, difficulty_levelsUncheckedCreateWithoutSubjectInput> | difficulty_levelsCreateWithoutSubjectInput[] | difficulty_levelsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: difficulty_levelsCreateOrConnectWithoutSubjectInput | difficulty_levelsCreateOrConnectWithoutSubjectInput[]
    createMany?: difficulty_levelsCreateManySubjectInputEnvelope
    connect?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
  }

  export type topicsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<topicsCreateWithoutSubjectsInput, topicsUncheckedCreateWithoutSubjectsInput> | topicsCreateWithoutSubjectsInput[] | topicsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: topicsCreateOrConnectWithoutSubjectsInput | topicsCreateOrConnectWithoutSubjectsInput[]
    createMany?: topicsCreateManySubjectsInputEnvelope
    connect?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
  }

  export type subject_masteryUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<subject_masteryCreateWithoutSubjectsInput, subject_masteryUncheckedCreateWithoutSubjectsInput> | subject_masteryCreateWithoutSubjectsInput[] | subject_masteryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutSubjectsInput | subject_masteryCreateOrConnectWithoutSubjectsInput[]
    createMany?: subject_masteryCreateManySubjectsInputEnvelope
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
  }

  export type difficulty_levelsUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<difficulty_levelsCreateWithoutSubjectInput, difficulty_levelsUncheckedCreateWithoutSubjectInput> | difficulty_levelsCreateWithoutSubjectInput[] | difficulty_levelsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: difficulty_levelsCreateOrConnectWithoutSubjectInput | difficulty_levelsCreateOrConnectWithoutSubjectInput[]
    createMany?: difficulty_levelsCreateManySubjectInputEnvelope
    connect?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
  }

  export type topicsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<topicsCreateWithoutSubjectsInput, topicsUncheckedCreateWithoutSubjectsInput> | topicsCreateWithoutSubjectsInput[] | topicsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: topicsCreateOrConnectWithoutSubjectsInput | topicsCreateOrConnectWithoutSubjectsInput[]
    upsert?: topicsUpsertWithWhereUniqueWithoutSubjectsInput | topicsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: topicsCreateManySubjectsInputEnvelope
    set?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    disconnect?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    delete?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    connect?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    update?: topicsUpdateWithWhereUniqueWithoutSubjectsInput | topicsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: topicsUpdateManyWithWhereWithoutSubjectsInput | topicsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: topicsScalarWhereInput | topicsScalarWhereInput[]
  }

  export type subject_masteryUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<subject_masteryCreateWithoutSubjectsInput, subject_masteryUncheckedCreateWithoutSubjectsInput> | subject_masteryCreateWithoutSubjectsInput[] | subject_masteryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutSubjectsInput | subject_masteryCreateOrConnectWithoutSubjectsInput[]
    upsert?: subject_masteryUpsertWithWhereUniqueWithoutSubjectsInput | subject_masteryUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: subject_masteryCreateManySubjectsInputEnvelope
    set?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    disconnect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    delete?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    update?: subject_masteryUpdateWithWhereUniqueWithoutSubjectsInput | subject_masteryUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: subject_masteryUpdateManyWithWhereWithoutSubjectsInput | subject_masteryUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: subject_masteryScalarWhereInput | subject_masteryScalarWhereInput[]
  }

  export type difficulty_levelsUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<difficulty_levelsCreateWithoutSubjectInput, difficulty_levelsUncheckedCreateWithoutSubjectInput> | difficulty_levelsCreateWithoutSubjectInput[] | difficulty_levelsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: difficulty_levelsCreateOrConnectWithoutSubjectInput | difficulty_levelsCreateOrConnectWithoutSubjectInput[]
    upsert?: difficulty_levelsUpsertWithWhereUniqueWithoutSubjectInput | difficulty_levelsUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: difficulty_levelsCreateManySubjectInputEnvelope
    set?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    disconnect?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    delete?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    connect?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    update?: difficulty_levelsUpdateWithWhereUniqueWithoutSubjectInput | difficulty_levelsUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: difficulty_levelsUpdateManyWithWhereWithoutSubjectInput | difficulty_levelsUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: difficulty_levelsScalarWhereInput | difficulty_levelsScalarWhereInput[]
  }

  export type topicsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<topicsCreateWithoutSubjectsInput, topicsUncheckedCreateWithoutSubjectsInput> | topicsCreateWithoutSubjectsInput[] | topicsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: topicsCreateOrConnectWithoutSubjectsInput | topicsCreateOrConnectWithoutSubjectsInput[]
    upsert?: topicsUpsertWithWhereUniqueWithoutSubjectsInput | topicsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: topicsCreateManySubjectsInputEnvelope
    set?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    disconnect?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    delete?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    connect?: topicsWhereUniqueInput | topicsWhereUniqueInput[]
    update?: topicsUpdateWithWhereUniqueWithoutSubjectsInput | topicsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: topicsUpdateManyWithWhereWithoutSubjectsInput | topicsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: topicsScalarWhereInput | topicsScalarWhereInput[]
  }

  export type subject_masteryUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<subject_masteryCreateWithoutSubjectsInput, subject_masteryUncheckedCreateWithoutSubjectsInput> | subject_masteryCreateWithoutSubjectsInput[] | subject_masteryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutSubjectsInput | subject_masteryCreateOrConnectWithoutSubjectsInput[]
    upsert?: subject_masteryUpsertWithWhereUniqueWithoutSubjectsInput | subject_masteryUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: subject_masteryCreateManySubjectsInputEnvelope
    set?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    disconnect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    delete?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    update?: subject_masteryUpdateWithWhereUniqueWithoutSubjectsInput | subject_masteryUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: subject_masteryUpdateManyWithWhereWithoutSubjectsInput | subject_masteryUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: subject_masteryScalarWhereInput | subject_masteryScalarWhereInput[]
  }

  export type difficulty_levelsUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<difficulty_levelsCreateWithoutSubjectInput, difficulty_levelsUncheckedCreateWithoutSubjectInput> | difficulty_levelsCreateWithoutSubjectInput[] | difficulty_levelsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: difficulty_levelsCreateOrConnectWithoutSubjectInput | difficulty_levelsCreateOrConnectWithoutSubjectInput[]
    upsert?: difficulty_levelsUpsertWithWhereUniqueWithoutSubjectInput | difficulty_levelsUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: difficulty_levelsCreateManySubjectInputEnvelope
    set?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    disconnect?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    delete?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    connect?: difficulty_levelsWhereUniqueInput | difficulty_levelsWhereUniqueInput[]
    update?: difficulty_levelsUpdateWithWhereUniqueWithoutSubjectInput | difficulty_levelsUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: difficulty_levelsUpdateManyWithWhereWithoutSubjectInput | difficulty_levelsUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: difficulty_levelsScalarWhereInput | difficulty_levelsScalarWhereInput[]
  }

  export type questionsCreateNestedManyWithoutSubtopicsInput = {
    create?: XOR<questionsCreateWithoutSubtopicsInput, questionsUncheckedCreateWithoutSubtopicsInput> | questionsCreateWithoutSubtopicsInput[] | questionsUncheckedCreateWithoutSubtopicsInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSubtopicsInput | questionsCreateOrConnectWithoutSubtopicsInput[]
    createMany?: questionsCreateManySubtopicsInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type topicsCreateNestedOneWithoutSubtopicsInput = {
    create?: XOR<topicsCreateWithoutSubtopicsInput, topicsUncheckedCreateWithoutSubtopicsInput>
    connectOrCreate?: topicsCreateOrConnectWithoutSubtopicsInput
    connect?: topicsWhereUniqueInput
  }

  export type questionsUncheckedCreateNestedManyWithoutSubtopicsInput = {
    create?: XOR<questionsCreateWithoutSubtopicsInput, questionsUncheckedCreateWithoutSubtopicsInput> | questionsCreateWithoutSubtopicsInput[] | questionsUncheckedCreateWithoutSubtopicsInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSubtopicsInput | questionsCreateOrConnectWithoutSubtopicsInput[]
    createMany?: questionsCreateManySubtopicsInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutSubtopicsNestedInput = {
    create?: XOR<questionsCreateWithoutSubtopicsInput, questionsUncheckedCreateWithoutSubtopicsInput> | questionsCreateWithoutSubtopicsInput[] | questionsUncheckedCreateWithoutSubtopicsInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSubtopicsInput | questionsCreateOrConnectWithoutSubtopicsInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutSubtopicsInput | questionsUpsertWithWhereUniqueWithoutSubtopicsInput[]
    createMany?: questionsCreateManySubtopicsInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutSubtopicsInput | questionsUpdateWithWhereUniqueWithoutSubtopicsInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutSubtopicsInput | questionsUpdateManyWithWhereWithoutSubtopicsInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type topicsUpdateOneRequiredWithoutSubtopicsNestedInput = {
    create?: XOR<topicsCreateWithoutSubtopicsInput, topicsUncheckedCreateWithoutSubtopicsInput>
    connectOrCreate?: topicsCreateOrConnectWithoutSubtopicsInput
    upsert?: topicsUpsertWithoutSubtopicsInput
    connect?: topicsWhereUniqueInput
    update?: XOR<XOR<topicsUpdateToOneWithWhereWithoutSubtopicsInput, topicsUpdateWithoutSubtopicsInput>, topicsUncheckedUpdateWithoutSubtopicsInput>
  }

  export type questionsUncheckedUpdateManyWithoutSubtopicsNestedInput = {
    create?: XOR<questionsCreateWithoutSubtopicsInput, questionsUncheckedCreateWithoutSubtopicsInput> | questionsCreateWithoutSubtopicsInput[] | questionsUncheckedCreateWithoutSubtopicsInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSubtopicsInput | questionsCreateOrConnectWithoutSubtopicsInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutSubtopicsInput | questionsUpsertWithWhereUniqueWithoutSubtopicsInput[]
    createMany?: questionsCreateManySubtopicsInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutSubtopicsInput | questionsUpdateWithWhereUniqueWithoutSubtopicsInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutSubtopicsInput | questionsUpdateManyWithWhereWithoutSubtopicsInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type test_plansCreateNestedOneWithoutTest_executionsInput = {
    create?: XOR<test_plansCreateWithoutTest_executionsInput, test_plansUncheckedCreateWithoutTest_executionsInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutTest_executionsInput
    connect?: test_plansWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTest_executionsInput = {
    create?: XOR<usersCreateWithoutTest_executionsInput, usersUncheckedCreateWithoutTest_executionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_executionsInput
    connect?: usersWhereUniqueInput
  }

  export type Enumtest_executions_statusFieldUpdateOperationsInput = {
    set?: $Enums.test_executions_status
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type test_plansUpdateOneRequiredWithoutTest_executionsNestedInput = {
    create?: XOR<test_plansCreateWithoutTest_executionsInput, test_plansUncheckedCreateWithoutTest_executionsInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutTest_executionsInput
    upsert?: test_plansUpsertWithoutTest_executionsInput
    connect?: test_plansWhereUniqueInput
    update?: XOR<XOR<test_plansUpdateToOneWithWhereWithoutTest_executionsInput, test_plansUpdateWithoutTest_executionsInput>, test_plansUncheckedUpdateWithoutTest_executionsInput>
  }

  export type usersUpdateOneRequiredWithoutTest_executionsNestedInput = {
    create?: XOR<usersCreateWithoutTest_executionsInput, usersUncheckedCreateWithoutTest_executionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_executionsInput
    upsert?: usersUpsertWithoutTest_executionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTest_executionsInput, usersUpdateWithoutTest_executionsInput>, usersUncheckedUpdateWithoutTest_executionsInput>
  }

  export type test_plansCreateNestedOneWithoutQuestion_set_linksInput = {
    create?: XOR<test_plansCreateWithoutQuestion_set_linksInput, test_plansUncheckedCreateWithoutQuestion_set_linksInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutQuestion_set_linksInput
    connect?: test_plansWhereUniqueInput
  }

  export type question_setsCreateNestedOneWithoutTest_plan_linksInput = {
    create?: XOR<question_setsCreateWithoutTest_plan_linksInput, question_setsUncheckedCreateWithoutTest_plan_linksInput>
    connectOrCreate?: question_setsCreateOrConnectWithoutTest_plan_linksInput
    connect?: question_setsWhereUniqueInput
  }

  export type test_plansUpdateOneRequiredWithoutQuestion_set_linksNestedInput = {
    create?: XOR<test_plansCreateWithoutQuestion_set_linksInput, test_plansUncheckedCreateWithoutQuestion_set_linksInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutQuestion_set_linksInput
    upsert?: test_plansUpsertWithoutQuestion_set_linksInput
    connect?: test_plansWhereUniqueInput
    update?: XOR<XOR<test_plansUpdateToOneWithWhereWithoutQuestion_set_linksInput, test_plansUpdateWithoutQuestion_set_linksInput>, test_plansUncheckedUpdateWithoutQuestion_set_linksInput>
  }

  export type question_setsUpdateOneRequiredWithoutTest_plan_linksNestedInput = {
    create?: XOR<question_setsCreateWithoutTest_plan_linksInput, question_setsUncheckedCreateWithoutTest_plan_linksInput>
    connectOrCreate?: question_setsCreateOrConnectWithoutTest_plan_linksInput
    upsert?: question_setsUpsertWithoutTest_plan_linksInput
    connect?: question_setsWhereUniqueInput
    update?: XOR<XOR<question_setsUpdateToOneWithWhereWithoutTest_plan_linksInput, question_setsUpdateWithoutTest_plan_linksInput>, question_setsUncheckedUpdateWithoutTest_plan_linksInput>
  }

  export type test_executionsCreateNestedManyWithoutTest_plansInput = {
    create?: XOR<test_executionsCreateWithoutTest_plansInput, test_executionsUncheckedCreateWithoutTest_plansInput> | test_executionsCreateWithoutTest_plansInput[] | test_executionsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutTest_plansInput | test_executionsCreateOrConnectWithoutTest_plansInput[]
    createMany?: test_executionsCreateManyTest_plansInputEnvelope
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
  }

  export type test_templatesCreateNestedOneWithoutTest_plansInput = {
    create?: XOR<test_templatesCreateWithoutTest_plansInput, test_templatesUncheckedCreateWithoutTest_plansInput>
    connectOrCreate?: test_templatesCreateOrConnectWithoutTest_plansInput
    connect?: test_templatesWhereUniqueInput
  }

  export type exam_boardsCreateNestedOneWithoutTest_plansInput = {
    create?: XOR<exam_boardsCreateWithoutTest_plansInput, exam_boardsUncheckedCreateWithoutTest_plansInput>
    connectOrCreate?: exam_boardsCreateOrConnectWithoutTest_plansInput
    connect?: exam_boardsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAssigned_test_plansInput = {
    create?: XOR<usersCreateWithoutAssigned_test_plansInput, usersUncheckedCreateWithoutAssigned_test_plansInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssigned_test_plansInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPlanned_test_plansInput = {
    create?: XOR<usersCreateWithoutPlanned_test_plansInput, usersUncheckedCreateWithoutPlanned_test_plansInput>
    connectOrCreate?: usersCreateOrConnectWithoutPlanned_test_plansInput
    connect?: usersWhereUniqueInput
  }

  export type study_groupsCreateNestedManyWithoutTest_plansInput = {
    create?: XOR<study_groupsCreateWithoutTest_plansInput, study_groupsUncheckedCreateWithoutTest_plansInput> | study_groupsCreateWithoutTest_plansInput[] | study_groupsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTest_plansInput | study_groupsCreateOrConnectWithoutTest_plansInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
  }

  export type test_assignmentsCreateNestedManyWithoutTest_planInput = {
    create?: XOR<test_assignmentsCreateWithoutTest_planInput, test_assignmentsUncheckedCreateWithoutTest_planInput> | test_assignmentsCreateWithoutTest_planInput[] | test_assignmentsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutTest_planInput | test_assignmentsCreateOrConnectWithoutTest_planInput[]
    createMany?: test_assignmentsCreateManyTest_planInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type test_plan_question_setsCreateNestedManyWithoutTest_planInput = {
    create?: XOR<test_plan_question_setsCreateWithoutTest_planInput, test_plan_question_setsUncheckedCreateWithoutTest_planInput> | test_plan_question_setsCreateWithoutTest_planInput[] | test_plan_question_setsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutTest_planInput | test_plan_question_setsCreateOrConnectWithoutTest_planInput[]
    createMany?: test_plan_question_setsCreateManyTest_planInputEnvelope
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
  }

  export type test_executionsUncheckedCreateNestedManyWithoutTest_plansInput = {
    create?: XOR<test_executionsCreateWithoutTest_plansInput, test_executionsUncheckedCreateWithoutTest_plansInput> | test_executionsCreateWithoutTest_plansInput[] | test_executionsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutTest_plansInput | test_executionsCreateOrConnectWithoutTest_plansInput[]
    createMany?: test_executionsCreateManyTest_plansInputEnvelope
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
  }

  export type study_groupsUncheckedCreateNestedManyWithoutTest_plansInput = {
    create?: XOR<study_groupsCreateWithoutTest_plansInput, study_groupsUncheckedCreateWithoutTest_plansInput> | study_groupsCreateWithoutTest_plansInput[] | study_groupsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTest_plansInput | study_groupsCreateOrConnectWithoutTest_plansInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
  }

  export type test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput = {
    create?: XOR<test_assignmentsCreateWithoutTest_planInput, test_assignmentsUncheckedCreateWithoutTest_planInput> | test_assignmentsCreateWithoutTest_planInput[] | test_assignmentsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutTest_planInput | test_assignmentsCreateOrConnectWithoutTest_planInput[]
    createMany?: test_assignmentsCreateManyTest_planInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput = {
    create?: XOR<test_plan_question_setsCreateWithoutTest_planInput, test_plan_question_setsUncheckedCreateWithoutTest_planInput> | test_plan_question_setsCreateWithoutTest_planInput[] | test_plan_question_setsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutTest_planInput | test_plan_question_setsCreateOrConnectWithoutTest_planInput[]
    createMany?: test_plan_question_setsCreateManyTest_planInputEnvelope
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
  }

  export type Enumtest_plans_test_typeFieldUpdateOperationsInput = {
    set?: $Enums.test_plans_test_type
  }

  export type Enumtest_plans_timing_typeFieldUpdateOperationsInput = {
    set?: $Enums.test_plans_timing_type
  }

  export type test_executionsUpdateManyWithoutTest_plansNestedInput = {
    create?: XOR<test_executionsCreateWithoutTest_plansInput, test_executionsUncheckedCreateWithoutTest_plansInput> | test_executionsCreateWithoutTest_plansInput[] | test_executionsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutTest_plansInput | test_executionsCreateOrConnectWithoutTest_plansInput[]
    upsert?: test_executionsUpsertWithWhereUniqueWithoutTest_plansInput | test_executionsUpsertWithWhereUniqueWithoutTest_plansInput[]
    createMany?: test_executionsCreateManyTest_plansInputEnvelope
    set?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    disconnect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    delete?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    update?: test_executionsUpdateWithWhereUniqueWithoutTest_plansInput | test_executionsUpdateWithWhereUniqueWithoutTest_plansInput[]
    updateMany?: test_executionsUpdateManyWithWhereWithoutTest_plansInput | test_executionsUpdateManyWithWhereWithoutTest_plansInput[]
    deleteMany?: test_executionsScalarWhereInput | test_executionsScalarWhereInput[]
  }

  export type test_templatesUpdateOneWithoutTest_plansNestedInput = {
    create?: XOR<test_templatesCreateWithoutTest_plansInput, test_templatesUncheckedCreateWithoutTest_plansInput>
    connectOrCreate?: test_templatesCreateOrConnectWithoutTest_plansInput
    upsert?: test_templatesUpsertWithoutTest_plansInput
    disconnect?: test_templatesWhereInput | boolean
    delete?: test_templatesWhereInput | boolean
    connect?: test_templatesWhereUniqueInput
    update?: XOR<XOR<test_templatesUpdateToOneWithWhereWithoutTest_plansInput, test_templatesUpdateWithoutTest_plansInput>, test_templatesUncheckedUpdateWithoutTest_plansInput>
  }

  export type exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput = {
    create?: XOR<exam_boardsCreateWithoutTest_plansInput, exam_boardsUncheckedCreateWithoutTest_plansInput>
    connectOrCreate?: exam_boardsCreateOrConnectWithoutTest_plansInput
    upsert?: exam_boardsUpsertWithoutTest_plansInput
    connect?: exam_boardsWhereUniqueInput
    update?: XOR<XOR<exam_boardsUpdateToOneWithWhereWithoutTest_plansInput, exam_boardsUpdateWithoutTest_plansInput>, exam_boardsUncheckedUpdateWithoutTest_plansInput>
  }

  export type usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput = {
    create?: XOR<usersCreateWithoutAssigned_test_plansInput, usersUncheckedCreateWithoutAssigned_test_plansInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssigned_test_plansInput
    upsert?: usersUpsertWithoutAssigned_test_plansInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAssigned_test_plansInput, usersUpdateWithoutAssigned_test_plansInput>, usersUncheckedUpdateWithoutAssigned_test_plansInput>
  }

  export type usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput = {
    create?: XOR<usersCreateWithoutPlanned_test_plansInput, usersUncheckedCreateWithoutPlanned_test_plansInput>
    connectOrCreate?: usersCreateOrConnectWithoutPlanned_test_plansInput
    upsert?: usersUpsertWithoutPlanned_test_plansInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPlanned_test_plansInput, usersUpdateWithoutPlanned_test_plansInput>, usersUncheckedUpdateWithoutPlanned_test_plansInput>
  }

  export type study_groupsUpdateManyWithoutTest_plansNestedInput = {
    create?: XOR<study_groupsCreateWithoutTest_plansInput, study_groupsUncheckedCreateWithoutTest_plansInput> | study_groupsCreateWithoutTest_plansInput[] | study_groupsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTest_plansInput | study_groupsCreateOrConnectWithoutTest_plansInput[]
    upsert?: study_groupsUpsertWithWhereUniqueWithoutTest_plansInput | study_groupsUpsertWithWhereUniqueWithoutTest_plansInput[]
    set?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    disconnect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    delete?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    update?: study_groupsUpdateWithWhereUniqueWithoutTest_plansInput | study_groupsUpdateWithWhereUniqueWithoutTest_plansInput[]
    updateMany?: study_groupsUpdateManyWithWhereWithoutTest_plansInput | study_groupsUpdateManyWithWhereWithoutTest_plansInput[]
    deleteMany?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
  }

  export type test_assignmentsUpdateManyWithoutTest_planNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutTest_planInput, test_assignmentsUncheckedCreateWithoutTest_planInput> | test_assignmentsCreateWithoutTest_planInput[] | test_assignmentsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutTest_planInput | test_assignmentsCreateOrConnectWithoutTest_planInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutTest_planInput | test_assignmentsUpsertWithWhereUniqueWithoutTest_planInput[]
    createMany?: test_assignmentsCreateManyTest_planInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutTest_planInput | test_assignmentsUpdateWithWhereUniqueWithoutTest_planInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutTest_planInput | test_assignmentsUpdateManyWithWhereWithoutTest_planInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type test_plan_question_setsUpdateManyWithoutTest_planNestedInput = {
    create?: XOR<test_plan_question_setsCreateWithoutTest_planInput, test_plan_question_setsUncheckedCreateWithoutTest_planInput> | test_plan_question_setsCreateWithoutTest_planInput[] | test_plan_question_setsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutTest_planInput | test_plan_question_setsCreateOrConnectWithoutTest_planInput[]
    upsert?: test_plan_question_setsUpsertWithWhereUniqueWithoutTest_planInput | test_plan_question_setsUpsertWithWhereUniqueWithoutTest_planInput[]
    createMany?: test_plan_question_setsCreateManyTest_planInputEnvelope
    set?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    disconnect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    delete?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    update?: test_plan_question_setsUpdateWithWhereUniqueWithoutTest_planInput | test_plan_question_setsUpdateWithWhereUniqueWithoutTest_planInput[]
    updateMany?: test_plan_question_setsUpdateManyWithWhereWithoutTest_planInput | test_plan_question_setsUpdateManyWithWhereWithoutTest_planInput[]
    deleteMany?: test_plan_question_setsScalarWhereInput | test_plan_question_setsScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput = {
    create?: XOR<test_executionsCreateWithoutTest_plansInput, test_executionsUncheckedCreateWithoutTest_plansInput> | test_executionsCreateWithoutTest_plansInput[] | test_executionsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutTest_plansInput | test_executionsCreateOrConnectWithoutTest_plansInput[]
    upsert?: test_executionsUpsertWithWhereUniqueWithoutTest_plansInput | test_executionsUpsertWithWhereUniqueWithoutTest_plansInput[]
    createMany?: test_executionsCreateManyTest_plansInputEnvelope
    set?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    disconnect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    delete?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    update?: test_executionsUpdateWithWhereUniqueWithoutTest_plansInput | test_executionsUpdateWithWhereUniqueWithoutTest_plansInput[]
    updateMany?: test_executionsUpdateManyWithWhereWithoutTest_plansInput | test_executionsUpdateManyWithWhereWithoutTest_plansInput[]
    deleteMany?: test_executionsScalarWhereInput | test_executionsScalarWhereInput[]
  }

  export type study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput = {
    create?: XOR<study_groupsCreateWithoutTest_plansInput, study_groupsUncheckedCreateWithoutTest_plansInput> | study_groupsCreateWithoutTest_plansInput[] | study_groupsUncheckedCreateWithoutTest_plansInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTest_plansInput | study_groupsCreateOrConnectWithoutTest_plansInput[]
    upsert?: study_groupsUpsertWithWhereUniqueWithoutTest_plansInput | study_groupsUpsertWithWhereUniqueWithoutTest_plansInput[]
    set?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    disconnect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    delete?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    update?: study_groupsUpdateWithWhereUniqueWithoutTest_plansInput | study_groupsUpdateWithWhereUniqueWithoutTest_plansInput[]
    updateMany?: study_groupsUpdateManyWithWhereWithoutTest_plansInput | study_groupsUpdateManyWithWhereWithoutTest_plansInput[]
    deleteMany?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
  }

  export type test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutTest_planInput, test_assignmentsUncheckedCreateWithoutTest_planInput> | test_assignmentsCreateWithoutTest_planInput[] | test_assignmentsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutTest_planInput | test_assignmentsCreateOrConnectWithoutTest_planInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutTest_planInput | test_assignmentsUpsertWithWhereUniqueWithoutTest_planInput[]
    createMany?: test_assignmentsCreateManyTest_planInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutTest_planInput | test_assignmentsUpdateWithWhereUniqueWithoutTest_planInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutTest_planInput | test_assignmentsUpdateManyWithWhereWithoutTest_planInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput = {
    create?: XOR<test_plan_question_setsCreateWithoutTest_planInput, test_plan_question_setsUncheckedCreateWithoutTest_planInput> | test_plan_question_setsCreateWithoutTest_planInput[] | test_plan_question_setsUncheckedCreateWithoutTest_planInput[]
    connectOrCreate?: test_plan_question_setsCreateOrConnectWithoutTest_planInput | test_plan_question_setsCreateOrConnectWithoutTest_planInput[]
    upsert?: test_plan_question_setsUpsertWithWhereUniqueWithoutTest_planInput | test_plan_question_setsUpsertWithWhereUniqueWithoutTest_planInput[]
    createMany?: test_plan_question_setsCreateManyTest_planInputEnvelope
    set?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    disconnect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    delete?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    connect?: test_plan_question_setsWhereUniqueInput | test_plan_question_setsWhereUniqueInput[]
    update?: test_plan_question_setsUpdateWithWhereUniqueWithoutTest_planInput | test_plan_question_setsUpdateWithWhereUniqueWithoutTest_planInput[]
    updateMany?: test_plan_question_setsUpdateManyWithWhereWithoutTest_planInput | test_plan_question_setsUpdateManyWithWhereWithoutTest_planInput[]
    deleteMany?: test_plan_question_setsScalarWhereInput | test_plan_question_setsScalarWhereInput[]
  }

  export type test_plansCreateNestedManyWithoutTest_templatesInput = {
    create?: XOR<test_plansCreateWithoutTest_templatesInput, test_plansUncheckedCreateWithoutTest_templatesInput> | test_plansCreateWithoutTest_templatesInput[] | test_plansUncheckedCreateWithoutTest_templatesInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutTest_templatesInput | test_plansCreateOrConnectWithoutTest_templatesInput[]
    createMany?: test_plansCreateManyTest_templatesInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTest_templatesInput = {
    create?: XOR<usersCreateWithoutTest_templatesInput, usersUncheckedCreateWithoutTest_templatesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_templatesInput
    connect?: usersWhereUniqueInput
  }

  export type exam_boardsCreateNestedOneWithoutTest_templatesInput = {
    create?: XOR<exam_boardsCreateWithoutTest_templatesInput, exam_boardsUncheckedCreateWithoutTest_templatesInput>
    connectOrCreate?: exam_boardsCreateOrConnectWithoutTest_templatesInput
    connect?: exam_boardsWhereUniqueInput
  }

  export type test_plansUncheckedCreateNestedManyWithoutTest_templatesInput = {
    create?: XOR<test_plansCreateWithoutTest_templatesInput, test_plansUncheckedCreateWithoutTest_templatesInput> | test_plansCreateWithoutTest_templatesInput[] | test_plansUncheckedCreateWithoutTest_templatesInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutTest_templatesInput | test_plansCreateOrConnectWithoutTest_templatesInput[]
    createMany?: test_plansCreateManyTest_templatesInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type Enumtest_templates_sourceFieldUpdateOperationsInput = {
    set?: $Enums.test_templates_source
  }

  export type Enumtest_templates_test_typeFieldUpdateOperationsInput = {
    set?: $Enums.test_templates_test_type
  }

  export type Enumtest_templates_timing_typeFieldUpdateOperationsInput = {
    set?: $Enums.test_templates_timing_type
  }

  export type test_plansUpdateManyWithoutTest_templatesNestedInput = {
    create?: XOR<test_plansCreateWithoutTest_templatesInput, test_plansUncheckedCreateWithoutTest_templatesInput> | test_plansCreateWithoutTest_templatesInput[] | test_plansUncheckedCreateWithoutTest_templatesInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutTest_templatesInput | test_plansCreateOrConnectWithoutTest_templatesInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutTest_templatesInput | test_plansUpsertWithWhereUniqueWithoutTest_templatesInput[]
    createMany?: test_plansCreateManyTest_templatesInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutTest_templatesInput | test_plansUpdateWithWhereUniqueWithoutTest_templatesInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutTest_templatesInput | test_plansUpdateManyWithWhereWithoutTest_templatesInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutTest_templatesNestedInput = {
    create?: XOR<usersCreateWithoutTest_templatesInput, usersUncheckedCreateWithoutTest_templatesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_templatesInput
    upsert?: usersUpsertWithoutTest_templatesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTest_templatesInput, usersUpdateWithoutTest_templatesInput>, usersUncheckedUpdateWithoutTest_templatesInput>
  }

  export type exam_boardsUpdateOneRequiredWithoutTest_templatesNestedInput = {
    create?: XOR<exam_boardsCreateWithoutTest_templatesInput, exam_boardsUncheckedCreateWithoutTest_templatesInput>
    connectOrCreate?: exam_boardsCreateOrConnectWithoutTest_templatesInput
    upsert?: exam_boardsUpsertWithoutTest_templatesInput
    connect?: exam_boardsWhereUniqueInput
    update?: XOR<XOR<exam_boardsUpdateToOneWithWhereWithoutTest_templatesInput, exam_boardsUpdateWithoutTest_templatesInput>, exam_boardsUncheckedUpdateWithoutTest_templatesInput>
  }

  export type test_plansUncheckedUpdateManyWithoutTest_templatesNestedInput = {
    create?: XOR<test_plansCreateWithoutTest_templatesInput, test_plansUncheckedCreateWithoutTest_templatesInput> | test_plansCreateWithoutTest_templatesInput[] | test_plansUncheckedCreateWithoutTest_templatesInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutTest_templatesInput | test_plansCreateOrConnectWithoutTest_templatesInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutTest_templatesInput | test_plansUpsertWithWhereUniqueWithoutTest_templatesInput[]
    createMany?: test_plansCreateManyTest_templatesInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutTest_templatesInput | test_plansUpdateWithWhereUniqueWithoutTest_templatesInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutTest_templatesInput | test_plansUpdateManyWithWhereWithoutTest_templatesInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type subtopicsCreateNestedManyWithoutTopicsInput = {
    create?: XOR<subtopicsCreateWithoutTopicsInput, subtopicsUncheckedCreateWithoutTopicsInput> | subtopicsCreateWithoutTopicsInput[] | subtopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: subtopicsCreateOrConnectWithoutTopicsInput | subtopicsCreateOrConnectWithoutTopicsInput[]
    createMany?: subtopicsCreateManyTopicsInputEnvelope
    connect?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
  }

  export type subjectsCreateNestedOneWithoutTopicsInput = {
    create?: XOR<subjectsCreateWithoutTopicsInput, subjectsUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTopicsInput
    connect?: subjectsWhereUniqueInput
  }

  export type subtopicsUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<subtopicsCreateWithoutTopicsInput, subtopicsUncheckedCreateWithoutTopicsInput> | subtopicsCreateWithoutTopicsInput[] | subtopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: subtopicsCreateOrConnectWithoutTopicsInput | subtopicsCreateOrConnectWithoutTopicsInput[]
    createMany?: subtopicsCreateManyTopicsInputEnvelope
    connect?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
  }

  export type subtopicsUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<subtopicsCreateWithoutTopicsInput, subtopicsUncheckedCreateWithoutTopicsInput> | subtopicsCreateWithoutTopicsInput[] | subtopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: subtopicsCreateOrConnectWithoutTopicsInput | subtopicsCreateOrConnectWithoutTopicsInput[]
    upsert?: subtopicsUpsertWithWhereUniqueWithoutTopicsInput | subtopicsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: subtopicsCreateManyTopicsInputEnvelope
    set?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    disconnect?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    delete?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    connect?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    update?: subtopicsUpdateWithWhereUniqueWithoutTopicsInput | subtopicsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: subtopicsUpdateManyWithWhereWithoutTopicsInput | subtopicsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: subtopicsScalarWhereInput | subtopicsScalarWhereInput[]
  }

  export type subjectsUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<subjectsCreateWithoutTopicsInput, subjectsUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTopicsInput
    upsert?: subjectsUpsertWithoutTopicsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutTopicsInput, subjectsUpdateWithoutTopicsInput>, subjectsUncheckedUpdateWithoutTopicsInput>
  }

  export type subtopicsUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<subtopicsCreateWithoutTopicsInput, subtopicsUncheckedCreateWithoutTopicsInput> | subtopicsCreateWithoutTopicsInput[] | subtopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: subtopicsCreateOrConnectWithoutTopicsInput | subtopicsCreateOrConnectWithoutTopicsInput[]
    upsert?: subtopicsUpsertWithWhereUniqueWithoutTopicsInput | subtopicsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: subtopicsCreateManyTopicsInputEnvelope
    set?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    disconnect?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    delete?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    connect?: subtopicsWhereUniqueInput | subtopicsWhereUniqueInput[]
    update?: subtopicsUpdateWithWhereUniqueWithoutTopicsInput | subtopicsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: subtopicsUpdateManyWithWhereWithoutTopicsInput | subtopicsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: subtopicsScalarWhereInput | subtopicsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    upsert?: usersUpsertWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_rolesInput, usersUpdateWithoutUser_rolesInput>, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type rolesUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    upsert?: rolesUpsertWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUser_rolesInput, rolesUpdateWithoutUser_rolesInput>, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type questionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<questionsCreateWithoutUsersInput, questionsUncheckedCreateWithoutUsersInput> | questionsCreateWithoutUsersInput[] | questionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutUsersInput | questionsCreateOrConnectWithoutUsersInput[]
    createMany?: questionsCreateManyUsersInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type question_setsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<question_setsCreateWithoutCreatorInput, question_setsUncheckedCreateWithoutCreatorInput> | question_setsCreateWithoutCreatorInput[] | question_setsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: question_setsCreateOrConnectWithoutCreatorInput | question_setsCreateOrConnectWithoutCreatorInput[]
    createMany?: question_setsCreateManyCreatorInputEnvelope
    connect?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
  }

  export type test_executionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_executionsCreateWithoutUsersInput, test_executionsUncheckedCreateWithoutUsersInput> | test_executionsCreateWithoutUsersInput[] | test_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutUsersInput | test_executionsCreateOrConnectWithoutUsersInput[]
    createMany?: test_executionsCreateManyUsersInputEnvelope
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
  }

  export type test_plansCreateNestedManyWithoutStudentInput = {
    create?: XOR<test_plansCreateWithoutStudentInput, test_plansUncheckedCreateWithoutStudentInput> | test_plansCreateWithoutStudentInput[] | test_plansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudentInput | test_plansCreateOrConnectWithoutStudentInput[]
    createMany?: test_plansCreateManyStudentInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type test_plansCreateNestedManyWithoutPlannerInput = {
    create?: XOR<test_plansCreateWithoutPlannerInput, test_plansUncheckedCreateWithoutPlannerInput> | test_plansCreateWithoutPlannerInput[] | test_plansUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutPlannerInput | test_plansCreateOrConnectWithoutPlannerInput[]
    createMany?: test_plansCreateManyPlannerInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type test_templatesCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_templatesCreateWithoutUsersInput, test_templatesUncheckedCreateWithoutUsersInput> | test_templatesCreateWithoutUsersInput[] | test_templatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutUsersInput | test_templatesCreateOrConnectWithoutUsersInput[]
    createMany?: test_templatesCreateManyUsersInputEnvelope
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
  }

  export type user_rolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type student_achievementsCreateNestedManyWithoutUserInput = {
    create?: XOR<student_achievementsCreateWithoutUserInput, student_achievementsUncheckedCreateWithoutUserInput> | student_achievementsCreateWithoutUserInput[] | student_achievementsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutUserInput | student_achievementsCreateOrConnectWithoutUserInput[]
    createMany?: student_achievementsCreateManyUserInputEnvelope
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
  }

  export type study_groupsCreateNestedManyWithoutTutorInput = {
    create?: XOR<study_groupsCreateWithoutTutorInput, study_groupsUncheckedCreateWithoutTutorInput> | study_groupsCreateWithoutTutorInput[] | study_groupsUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTutorInput | study_groupsCreateOrConnectWithoutTutorInput[]
    createMany?: study_groupsCreateManyTutorInputEnvelope
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
  }

  export type study_groupsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<study_groupsCreateWithoutStudentsInput, study_groupsUncheckedCreateWithoutStudentsInput> | study_groupsCreateWithoutStudentsInput[] | study_groupsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutStudentsInput | study_groupsCreateOrConnectWithoutStudentsInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
  }

  export type group_membersCreateNestedManyWithoutStudentInput = {
    create?: XOR<group_membersCreateWithoutStudentInput, group_membersUncheckedCreateWithoutStudentInput> | group_membersCreateWithoutStudentInput[] | group_membersUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutStudentInput | group_membersCreateOrConnectWithoutStudentInput[]
    createMany?: group_membersCreateManyStudentInputEnvelope
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
  }

  export type subject_masteryCreateNestedManyWithoutUserInput = {
    create?: XOR<subject_masteryCreateWithoutUserInput, subject_masteryUncheckedCreateWithoutUserInput> | subject_masteryCreateWithoutUserInput[] | subject_masteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutUserInput | subject_masteryCreateOrConnectWithoutUserInput[]
    createMany?: subject_masteryCreateManyUserInputEnvelope
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
  }

  export type student_progressCreateNestedOneWithoutUserInput = {
    create?: XOR<student_progressCreateWithoutUserInput, student_progressUncheckedCreateWithoutUserInput>
    connectOrCreate?: student_progressCreateOrConnectWithoutUserInput
    connect?: student_progressWhereUniqueInput
  }

  export type activity_logCreateNestedManyWithoutUserInput = {
    create?: XOR<activity_logCreateWithoutUserInput, activity_logUncheckedCreateWithoutUserInput> | activity_logCreateWithoutUserInput[] | activity_logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activity_logCreateOrConnectWithoutUserInput | activity_logCreateOrConnectWithoutUserInput[]
    createMany?: activity_logCreateManyUserInputEnvelope
    connect?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
  }

  export type student_rewardsCreateNestedManyWithoutUserInput = {
    create?: XOR<student_rewardsCreateWithoutUserInput, student_rewardsUncheckedCreateWithoutUserInput> | student_rewardsCreateWithoutUserInput[] | student_rewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutUserInput | student_rewardsCreateOrConnectWithoutUserInput[]
    createMany?: student_rewardsCreateManyUserInputEnvelope
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
  }

  export type student_guardiansCreateNestedManyWithoutGuardianInput = {
    create?: XOR<student_guardiansCreateWithoutGuardianInput, student_guardiansUncheckedCreateWithoutGuardianInput> | student_guardiansCreateWithoutGuardianInput[] | student_guardiansUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutGuardianInput | student_guardiansCreateOrConnectWithoutGuardianInput[]
    createMany?: student_guardiansCreateManyGuardianInputEnvelope
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
  }

  export type student_guardiansCreateNestedManyWithoutStudentInput = {
    create?: XOR<student_guardiansCreateWithoutStudentInput, student_guardiansUncheckedCreateWithoutStudentInput> | student_guardiansCreateWithoutStudentInput[] | student_guardiansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutStudentInput | student_guardiansCreateOrConnectWithoutStudentInput[]
    createMany?: student_guardiansCreateManyStudentInputEnvelope
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
  }

  export type test_assignmentsCreateNestedManyWithoutAssignerInput = {
    create?: XOR<test_assignmentsCreateWithoutAssignerInput, test_assignmentsUncheckedCreateWithoutAssignerInput> | test_assignmentsCreateWithoutAssignerInput[] | test_assignmentsUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutAssignerInput | test_assignmentsCreateOrConnectWithoutAssignerInput[]
    createMany?: test_assignmentsCreateManyAssignerInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type test_assignmentsCreateNestedManyWithoutStudentInput = {
    create?: XOR<test_assignmentsCreateWithoutStudentInput, test_assignmentsUncheckedCreateWithoutStudentInput> | test_assignmentsCreateWithoutStudentInput[] | test_assignmentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutStudentInput | test_assignmentsCreateOrConnectWithoutStudentInput[]
    createMany?: test_assignmentsCreateManyStudentInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<questionsCreateWithoutUsersInput, questionsUncheckedCreateWithoutUsersInput> | questionsCreateWithoutUsersInput[] | questionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutUsersInput | questionsCreateOrConnectWithoutUsersInput[]
    createMany?: questionsCreateManyUsersInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type question_setsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<question_setsCreateWithoutCreatorInput, question_setsUncheckedCreateWithoutCreatorInput> | question_setsCreateWithoutCreatorInput[] | question_setsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: question_setsCreateOrConnectWithoutCreatorInput | question_setsCreateOrConnectWithoutCreatorInput[]
    createMany?: question_setsCreateManyCreatorInputEnvelope
    connect?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
  }

  export type test_executionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_executionsCreateWithoutUsersInput, test_executionsUncheckedCreateWithoutUsersInput> | test_executionsCreateWithoutUsersInput[] | test_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutUsersInput | test_executionsCreateOrConnectWithoutUsersInput[]
    createMany?: test_executionsCreateManyUsersInputEnvelope
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
  }

  export type test_plansUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<test_plansCreateWithoutStudentInput, test_plansUncheckedCreateWithoutStudentInput> | test_plansCreateWithoutStudentInput[] | test_plansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudentInput | test_plansCreateOrConnectWithoutStudentInput[]
    createMany?: test_plansCreateManyStudentInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type test_plansUncheckedCreateNestedManyWithoutPlannerInput = {
    create?: XOR<test_plansCreateWithoutPlannerInput, test_plansUncheckedCreateWithoutPlannerInput> | test_plansCreateWithoutPlannerInput[] | test_plansUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutPlannerInput | test_plansCreateOrConnectWithoutPlannerInput[]
    createMany?: test_plansCreateManyPlannerInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type test_templatesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_templatesCreateWithoutUsersInput, test_templatesUncheckedCreateWithoutUsersInput> | test_templatesCreateWithoutUsersInput[] | test_templatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutUsersInput | test_templatesCreateOrConnectWithoutUsersInput[]
    createMany?: test_templatesCreateManyUsersInputEnvelope
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type student_achievementsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<student_achievementsCreateWithoutUserInput, student_achievementsUncheckedCreateWithoutUserInput> | student_achievementsCreateWithoutUserInput[] | student_achievementsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutUserInput | student_achievementsCreateOrConnectWithoutUserInput[]
    createMany?: student_achievementsCreateManyUserInputEnvelope
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
  }

  export type study_groupsUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<study_groupsCreateWithoutTutorInput, study_groupsUncheckedCreateWithoutTutorInput> | study_groupsCreateWithoutTutorInput[] | study_groupsUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTutorInput | study_groupsCreateOrConnectWithoutTutorInput[]
    createMany?: study_groupsCreateManyTutorInputEnvelope
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
  }

  export type study_groupsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<study_groupsCreateWithoutStudentsInput, study_groupsUncheckedCreateWithoutStudentsInput> | study_groupsCreateWithoutStudentsInput[] | study_groupsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutStudentsInput | study_groupsCreateOrConnectWithoutStudentsInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
  }

  export type group_membersUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<group_membersCreateWithoutStudentInput, group_membersUncheckedCreateWithoutStudentInput> | group_membersCreateWithoutStudentInput[] | group_membersUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutStudentInput | group_membersCreateOrConnectWithoutStudentInput[]
    createMany?: group_membersCreateManyStudentInputEnvelope
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
  }

  export type subject_masteryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<subject_masteryCreateWithoutUserInput, subject_masteryUncheckedCreateWithoutUserInput> | subject_masteryCreateWithoutUserInput[] | subject_masteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutUserInput | subject_masteryCreateOrConnectWithoutUserInput[]
    createMany?: subject_masteryCreateManyUserInputEnvelope
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
  }

  export type student_progressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<student_progressCreateWithoutUserInput, student_progressUncheckedCreateWithoutUserInput>
    connectOrCreate?: student_progressCreateOrConnectWithoutUserInput
    connect?: student_progressWhereUniqueInput
  }

  export type activity_logUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<activity_logCreateWithoutUserInput, activity_logUncheckedCreateWithoutUserInput> | activity_logCreateWithoutUserInput[] | activity_logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activity_logCreateOrConnectWithoutUserInput | activity_logCreateOrConnectWithoutUserInput[]
    createMany?: activity_logCreateManyUserInputEnvelope
    connect?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
  }

  export type student_rewardsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<student_rewardsCreateWithoutUserInput, student_rewardsUncheckedCreateWithoutUserInput> | student_rewardsCreateWithoutUserInput[] | student_rewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutUserInput | student_rewardsCreateOrConnectWithoutUserInput[]
    createMany?: student_rewardsCreateManyUserInputEnvelope
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
  }

  export type student_guardiansUncheckedCreateNestedManyWithoutGuardianInput = {
    create?: XOR<student_guardiansCreateWithoutGuardianInput, student_guardiansUncheckedCreateWithoutGuardianInput> | student_guardiansCreateWithoutGuardianInput[] | student_guardiansUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutGuardianInput | student_guardiansCreateOrConnectWithoutGuardianInput[]
    createMany?: student_guardiansCreateManyGuardianInputEnvelope
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
  }

  export type student_guardiansUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<student_guardiansCreateWithoutStudentInput, student_guardiansUncheckedCreateWithoutStudentInput> | student_guardiansCreateWithoutStudentInput[] | student_guardiansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutStudentInput | student_guardiansCreateOrConnectWithoutStudentInput[]
    createMany?: student_guardiansCreateManyStudentInputEnvelope
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
  }

  export type test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput = {
    create?: XOR<test_assignmentsCreateWithoutAssignerInput, test_assignmentsUncheckedCreateWithoutAssignerInput> | test_assignmentsCreateWithoutAssignerInput[] | test_assignmentsUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutAssignerInput | test_assignmentsCreateOrConnectWithoutAssignerInput[]
    createMany?: test_assignmentsCreateManyAssignerInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type test_assignmentsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<test_assignmentsCreateWithoutStudentInput, test_assignmentsUncheckedCreateWithoutStudentInput> | test_assignmentsCreateWithoutStudentInput[] | test_assignmentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutStudentInput | test_assignmentsCreateOrConnectWithoutStudentInput[]
    createMany?: test_assignmentsCreateManyStudentInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<questionsCreateWithoutUsersInput, questionsUncheckedCreateWithoutUsersInput> | questionsCreateWithoutUsersInput[] | questionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutUsersInput | questionsCreateOrConnectWithoutUsersInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutUsersInput | questionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: questionsCreateManyUsersInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutUsersInput | questionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutUsersInput | questionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type question_setsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<question_setsCreateWithoutCreatorInput, question_setsUncheckedCreateWithoutCreatorInput> | question_setsCreateWithoutCreatorInput[] | question_setsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: question_setsCreateOrConnectWithoutCreatorInput | question_setsCreateOrConnectWithoutCreatorInput[]
    upsert?: question_setsUpsertWithWhereUniqueWithoutCreatorInput | question_setsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: question_setsCreateManyCreatorInputEnvelope
    set?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    disconnect?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    delete?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    connect?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    update?: question_setsUpdateWithWhereUniqueWithoutCreatorInput | question_setsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: question_setsUpdateManyWithWhereWithoutCreatorInput | question_setsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: question_setsScalarWhereInput | question_setsScalarWhereInput[]
  }

  export type test_executionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_executionsCreateWithoutUsersInput, test_executionsUncheckedCreateWithoutUsersInput> | test_executionsCreateWithoutUsersInput[] | test_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutUsersInput | test_executionsCreateOrConnectWithoutUsersInput[]
    upsert?: test_executionsUpsertWithWhereUniqueWithoutUsersInput | test_executionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_executionsCreateManyUsersInputEnvelope
    set?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    disconnect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    delete?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    update?: test_executionsUpdateWithWhereUniqueWithoutUsersInput | test_executionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_executionsUpdateManyWithWhereWithoutUsersInput | test_executionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_executionsScalarWhereInput | test_executionsScalarWhereInput[]
  }

  export type test_plansUpdateManyWithoutStudentNestedInput = {
    create?: XOR<test_plansCreateWithoutStudentInput, test_plansUncheckedCreateWithoutStudentInput> | test_plansCreateWithoutStudentInput[] | test_plansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudentInput | test_plansCreateOrConnectWithoutStudentInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutStudentInput | test_plansUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: test_plansCreateManyStudentInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutStudentInput | test_plansUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutStudentInput | test_plansUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_plansUpdateManyWithoutPlannerNestedInput = {
    create?: XOR<test_plansCreateWithoutPlannerInput, test_plansUncheckedCreateWithoutPlannerInput> | test_plansCreateWithoutPlannerInput[] | test_plansUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutPlannerInput | test_plansCreateOrConnectWithoutPlannerInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutPlannerInput | test_plansUpsertWithWhereUniqueWithoutPlannerInput[]
    createMany?: test_plansCreateManyPlannerInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutPlannerInput | test_plansUpdateWithWhereUniqueWithoutPlannerInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutPlannerInput | test_plansUpdateManyWithWhereWithoutPlannerInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_templatesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_templatesCreateWithoutUsersInput, test_templatesUncheckedCreateWithoutUsersInput> | test_templatesCreateWithoutUsersInput[] | test_templatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutUsersInput | test_templatesCreateOrConnectWithoutUsersInput[]
    upsert?: test_templatesUpsertWithWhereUniqueWithoutUsersInput | test_templatesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_templatesCreateManyUsersInputEnvelope
    set?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    disconnect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    delete?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    update?: test_templatesUpdateWithWhereUniqueWithoutUsersInput | test_templatesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_templatesUpdateManyWithWhereWithoutUsersInput | test_templatesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_templatesScalarWhereInput | test_templatesScalarWhereInput[]
  }

  export type user_rolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type student_achievementsUpdateManyWithoutUserNestedInput = {
    create?: XOR<student_achievementsCreateWithoutUserInput, student_achievementsUncheckedCreateWithoutUserInput> | student_achievementsCreateWithoutUserInput[] | student_achievementsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutUserInput | student_achievementsCreateOrConnectWithoutUserInput[]
    upsert?: student_achievementsUpsertWithWhereUniqueWithoutUserInput | student_achievementsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: student_achievementsCreateManyUserInputEnvelope
    set?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    disconnect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    delete?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    update?: student_achievementsUpdateWithWhereUniqueWithoutUserInput | student_achievementsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: student_achievementsUpdateManyWithWhereWithoutUserInput | student_achievementsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: student_achievementsScalarWhereInput | student_achievementsScalarWhereInput[]
  }

  export type study_groupsUpdateManyWithoutTutorNestedInput = {
    create?: XOR<study_groupsCreateWithoutTutorInput, study_groupsUncheckedCreateWithoutTutorInput> | study_groupsCreateWithoutTutorInput[] | study_groupsUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTutorInput | study_groupsCreateOrConnectWithoutTutorInput[]
    upsert?: study_groupsUpsertWithWhereUniqueWithoutTutorInput | study_groupsUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: study_groupsCreateManyTutorInputEnvelope
    set?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    disconnect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    delete?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    update?: study_groupsUpdateWithWhereUniqueWithoutTutorInput | study_groupsUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: study_groupsUpdateManyWithWhereWithoutTutorInput | study_groupsUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
  }

  export type study_groupsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<study_groupsCreateWithoutStudentsInput, study_groupsUncheckedCreateWithoutStudentsInput> | study_groupsCreateWithoutStudentsInput[] | study_groupsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutStudentsInput | study_groupsCreateOrConnectWithoutStudentsInput[]
    upsert?: study_groupsUpsertWithWhereUniqueWithoutStudentsInput | study_groupsUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    disconnect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    delete?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    update?: study_groupsUpdateWithWhereUniqueWithoutStudentsInput | study_groupsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: study_groupsUpdateManyWithWhereWithoutStudentsInput | study_groupsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
  }

  export type group_membersUpdateManyWithoutStudentNestedInput = {
    create?: XOR<group_membersCreateWithoutStudentInput, group_membersUncheckedCreateWithoutStudentInput> | group_membersCreateWithoutStudentInput[] | group_membersUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutStudentInput | group_membersCreateOrConnectWithoutStudentInput[]
    upsert?: group_membersUpsertWithWhereUniqueWithoutStudentInput | group_membersUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: group_membersCreateManyStudentInputEnvelope
    set?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    disconnect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    delete?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    update?: group_membersUpdateWithWhereUniqueWithoutStudentInput | group_membersUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: group_membersUpdateManyWithWhereWithoutStudentInput | group_membersUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: group_membersScalarWhereInput | group_membersScalarWhereInput[]
  }

  export type subject_masteryUpdateManyWithoutUserNestedInput = {
    create?: XOR<subject_masteryCreateWithoutUserInput, subject_masteryUncheckedCreateWithoutUserInput> | subject_masteryCreateWithoutUserInput[] | subject_masteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutUserInput | subject_masteryCreateOrConnectWithoutUserInput[]
    upsert?: subject_masteryUpsertWithWhereUniqueWithoutUserInput | subject_masteryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: subject_masteryCreateManyUserInputEnvelope
    set?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    disconnect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    delete?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    update?: subject_masteryUpdateWithWhereUniqueWithoutUserInput | subject_masteryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: subject_masteryUpdateManyWithWhereWithoutUserInput | subject_masteryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: subject_masteryScalarWhereInput | subject_masteryScalarWhereInput[]
  }

  export type student_progressUpdateOneWithoutUserNestedInput = {
    create?: XOR<student_progressCreateWithoutUserInput, student_progressUncheckedCreateWithoutUserInput>
    connectOrCreate?: student_progressCreateOrConnectWithoutUserInput
    upsert?: student_progressUpsertWithoutUserInput
    disconnect?: student_progressWhereInput | boolean
    delete?: student_progressWhereInput | boolean
    connect?: student_progressWhereUniqueInput
    update?: XOR<XOR<student_progressUpdateToOneWithWhereWithoutUserInput, student_progressUpdateWithoutUserInput>, student_progressUncheckedUpdateWithoutUserInput>
  }

  export type activity_logUpdateManyWithoutUserNestedInput = {
    create?: XOR<activity_logCreateWithoutUserInput, activity_logUncheckedCreateWithoutUserInput> | activity_logCreateWithoutUserInput[] | activity_logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activity_logCreateOrConnectWithoutUserInput | activity_logCreateOrConnectWithoutUserInput[]
    upsert?: activity_logUpsertWithWhereUniqueWithoutUserInput | activity_logUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activity_logCreateManyUserInputEnvelope
    set?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    disconnect?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    delete?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    connect?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    update?: activity_logUpdateWithWhereUniqueWithoutUserInput | activity_logUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activity_logUpdateManyWithWhereWithoutUserInput | activity_logUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activity_logScalarWhereInput | activity_logScalarWhereInput[]
  }

  export type student_rewardsUpdateManyWithoutUserNestedInput = {
    create?: XOR<student_rewardsCreateWithoutUserInput, student_rewardsUncheckedCreateWithoutUserInput> | student_rewardsCreateWithoutUserInput[] | student_rewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutUserInput | student_rewardsCreateOrConnectWithoutUserInput[]
    upsert?: student_rewardsUpsertWithWhereUniqueWithoutUserInput | student_rewardsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: student_rewardsCreateManyUserInputEnvelope
    set?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    disconnect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    delete?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    update?: student_rewardsUpdateWithWhereUniqueWithoutUserInput | student_rewardsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: student_rewardsUpdateManyWithWhereWithoutUserInput | student_rewardsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: student_rewardsScalarWhereInput | student_rewardsScalarWhereInput[]
  }

  export type student_guardiansUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<student_guardiansCreateWithoutGuardianInput, student_guardiansUncheckedCreateWithoutGuardianInput> | student_guardiansCreateWithoutGuardianInput[] | student_guardiansUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutGuardianInput | student_guardiansCreateOrConnectWithoutGuardianInput[]
    upsert?: student_guardiansUpsertWithWhereUniqueWithoutGuardianInput | student_guardiansUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: student_guardiansCreateManyGuardianInputEnvelope
    set?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    disconnect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    delete?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    update?: student_guardiansUpdateWithWhereUniqueWithoutGuardianInput | student_guardiansUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: student_guardiansUpdateManyWithWhereWithoutGuardianInput | student_guardiansUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: student_guardiansScalarWhereInput | student_guardiansScalarWhereInput[]
  }

  export type student_guardiansUpdateManyWithoutStudentNestedInput = {
    create?: XOR<student_guardiansCreateWithoutStudentInput, student_guardiansUncheckedCreateWithoutStudentInput> | student_guardiansCreateWithoutStudentInput[] | student_guardiansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutStudentInput | student_guardiansCreateOrConnectWithoutStudentInput[]
    upsert?: student_guardiansUpsertWithWhereUniqueWithoutStudentInput | student_guardiansUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: student_guardiansCreateManyStudentInputEnvelope
    set?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    disconnect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    delete?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    update?: student_guardiansUpdateWithWhereUniqueWithoutStudentInput | student_guardiansUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: student_guardiansUpdateManyWithWhereWithoutStudentInput | student_guardiansUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: student_guardiansScalarWhereInput | student_guardiansScalarWhereInput[]
  }

  export type test_assignmentsUpdateManyWithoutAssignerNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutAssignerInput, test_assignmentsUncheckedCreateWithoutAssignerInput> | test_assignmentsCreateWithoutAssignerInput[] | test_assignmentsUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutAssignerInput | test_assignmentsCreateOrConnectWithoutAssignerInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutAssignerInput | test_assignmentsUpsertWithWhereUniqueWithoutAssignerInput[]
    createMany?: test_assignmentsCreateManyAssignerInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutAssignerInput | test_assignmentsUpdateWithWhereUniqueWithoutAssignerInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutAssignerInput | test_assignmentsUpdateManyWithWhereWithoutAssignerInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type test_assignmentsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutStudentInput, test_assignmentsUncheckedCreateWithoutStudentInput> | test_assignmentsCreateWithoutStudentInput[] | test_assignmentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutStudentInput | test_assignmentsCreateOrConnectWithoutStudentInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutStudentInput | test_assignmentsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: test_assignmentsCreateManyStudentInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutStudentInput | test_assignmentsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutStudentInput | test_assignmentsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<questionsCreateWithoutUsersInput, questionsUncheckedCreateWithoutUsersInput> | questionsCreateWithoutUsersInput[] | questionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutUsersInput | questionsCreateOrConnectWithoutUsersInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutUsersInput | questionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: questionsCreateManyUsersInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutUsersInput | questionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutUsersInput | questionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type question_setsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<question_setsCreateWithoutCreatorInput, question_setsUncheckedCreateWithoutCreatorInput> | question_setsCreateWithoutCreatorInput[] | question_setsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: question_setsCreateOrConnectWithoutCreatorInput | question_setsCreateOrConnectWithoutCreatorInput[]
    upsert?: question_setsUpsertWithWhereUniqueWithoutCreatorInput | question_setsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: question_setsCreateManyCreatorInputEnvelope
    set?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    disconnect?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    delete?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    connect?: question_setsWhereUniqueInput | question_setsWhereUniqueInput[]
    update?: question_setsUpdateWithWhereUniqueWithoutCreatorInput | question_setsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: question_setsUpdateManyWithWhereWithoutCreatorInput | question_setsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: question_setsScalarWhereInput | question_setsScalarWhereInput[]
  }

  export type test_executionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_executionsCreateWithoutUsersInput, test_executionsUncheckedCreateWithoutUsersInput> | test_executionsCreateWithoutUsersInput[] | test_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_executionsCreateOrConnectWithoutUsersInput | test_executionsCreateOrConnectWithoutUsersInput[]
    upsert?: test_executionsUpsertWithWhereUniqueWithoutUsersInput | test_executionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_executionsCreateManyUsersInputEnvelope
    set?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    disconnect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    delete?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    connect?: test_executionsWhereUniqueInput | test_executionsWhereUniqueInput[]
    update?: test_executionsUpdateWithWhereUniqueWithoutUsersInput | test_executionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_executionsUpdateManyWithWhereWithoutUsersInput | test_executionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_executionsScalarWhereInput | test_executionsScalarWhereInput[]
  }

  export type test_plansUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<test_plansCreateWithoutStudentInput, test_plansUncheckedCreateWithoutStudentInput> | test_plansCreateWithoutStudentInput[] | test_plansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudentInput | test_plansCreateOrConnectWithoutStudentInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutStudentInput | test_plansUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: test_plansCreateManyStudentInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutStudentInput | test_plansUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutStudentInput | test_plansUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_plansUncheckedUpdateManyWithoutPlannerNestedInput = {
    create?: XOR<test_plansCreateWithoutPlannerInput, test_plansUncheckedCreateWithoutPlannerInput> | test_plansCreateWithoutPlannerInput[] | test_plansUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutPlannerInput | test_plansCreateOrConnectWithoutPlannerInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutPlannerInput | test_plansUpsertWithWhereUniqueWithoutPlannerInput[]
    createMany?: test_plansCreateManyPlannerInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutPlannerInput | test_plansUpdateWithWhereUniqueWithoutPlannerInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutPlannerInput | test_plansUpdateManyWithWhereWithoutPlannerInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_templatesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_templatesCreateWithoutUsersInput, test_templatesUncheckedCreateWithoutUsersInput> | test_templatesCreateWithoutUsersInput[] | test_templatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_templatesCreateOrConnectWithoutUsersInput | test_templatesCreateOrConnectWithoutUsersInput[]
    upsert?: test_templatesUpsertWithWhereUniqueWithoutUsersInput | test_templatesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_templatesCreateManyUsersInputEnvelope
    set?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    disconnect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    delete?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    connect?: test_templatesWhereUniqueInput | test_templatesWhereUniqueInput[]
    update?: test_templatesUpdateWithWhereUniqueWithoutUsersInput | test_templatesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_templatesUpdateManyWithWhereWithoutUsersInput | test_templatesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_templatesScalarWhereInput | test_templatesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type student_achievementsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<student_achievementsCreateWithoutUserInput, student_achievementsUncheckedCreateWithoutUserInput> | student_achievementsCreateWithoutUserInput[] | student_achievementsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutUserInput | student_achievementsCreateOrConnectWithoutUserInput[]
    upsert?: student_achievementsUpsertWithWhereUniqueWithoutUserInput | student_achievementsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: student_achievementsCreateManyUserInputEnvelope
    set?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    disconnect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    delete?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    update?: student_achievementsUpdateWithWhereUniqueWithoutUserInput | student_achievementsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: student_achievementsUpdateManyWithWhereWithoutUserInput | student_achievementsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: student_achievementsScalarWhereInput | student_achievementsScalarWhereInput[]
  }

  export type study_groupsUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<study_groupsCreateWithoutTutorInput, study_groupsUncheckedCreateWithoutTutorInput> | study_groupsCreateWithoutTutorInput[] | study_groupsUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutTutorInput | study_groupsCreateOrConnectWithoutTutorInput[]
    upsert?: study_groupsUpsertWithWhereUniqueWithoutTutorInput | study_groupsUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: study_groupsCreateManyTutorInputEnvelope
    set?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    disconnect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    delete?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    update?: study_groupsUpdateWithWhereUniqueWithoutTutorInput | study_groupsUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: study_groupsUpdateManyWithWhereWithoutTutorInput | study_groupsUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
  }

  export type study_groupsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<study_groupsCreateWithoutStudentsInput, study_groupsUncheckedCreateWithoutStudentsInput> | study_groupsCreateWithoutStudentsInput[] | study_groupsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: study_groupsCreateOrConnectWithoutStudentsInput | study_groupsCreateOrConnectWithoutStudentsInput[]
    upsert?: study_groupsUpsertWithWhereUniqueWithoutStudentsInput | study_groupsUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    disconnect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    delete?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    connect?: study_groupsWhereUniqueInput | study_groupsWhereUniqueInput[]
    update?: study_groupsUpdateWithWhereUniqueWithoutStudentsInput | study_groupsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: study_groupsUpdateManyWithWhereWithoutStudentsInput | study_groupsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
  }

  export type group_membersUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<group_membersCreateWithoutStudentInput, group_membersUncheckedCreateWithoutStudentInput> | group_membersCreateWithoutStudentInput[] | group_membersUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutStudentInput | group_membersCreateOrConnectWithoutStudentInput[]
    upsert?: group_membersUpsertWithWhereUniqueWithoutStudentInput | group_membersUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: group_membersCreateManyStudentInputEnvelope
    set?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    disconnect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    delete?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    update?: group_membersUpdateWithWhereUniqueWithoutStudentInput | group_membersUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: group_membersUpdateManyWithWhereWithoutStudentInput | group_membersUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: group_membersScalarWhereInput | group_membersScalarWhereInput[]
  }

  export type subject_masteryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<subject_masteryCreateWithoutUserInput, subject_masteryUncheckedCreateWithoutUserInput> | subject_masteryCreateWithoutUserInput[] | subject_masteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subject_masteryCreateOrConnectWithoutUserInput | subject_masteryCreateOrConnectWithoutUserInput[]
    upsert?: subject_masteryUpsertWithWhereUniqueWithoutUserInput | subject_masteryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: subject_masteryCreateManyUserInputEnvelope
    set?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    disconnect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    delete?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    connect?: subject_masteryWhereUniqueInput | subject_masteryWhereUniqueInput[]
    update?: subject_masteryUpdateWithWhereUniqueWithoutUserInput | subject_masteryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: subject_masteryUpdateManyWithWhereWithoutUserInput | subject_masteryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: subject_masteryScalarWhereInput | subject_masteryScalarWhereInput[]
  }

  export type student_progressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<student_progressCreateWithoutUserInput, student_progressUncheckedCreateWithoutUserInput>
    connectOrCreate?: student_progressCreateOrConnectWithoutUserInput
    upsert?: student_progressUpsertWithoutUserInput
    disconnect?: student_progressWhereInput | boolean
    delete?: student_progressWhereInput | boolean
    connect?: student_progressWhereUniqueInput
    update?: XOR<XOR<student_progressUpdateToOneWithWhereWithoutUserInput, student_progressUpdateWithoutUserInput>, student_progressUncheckedUpdateWithoutUserInput>
  }

  export type activity_logUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<activity_logCreateWithoutUserInput, activity_logUncheckedCreateWithoutUserInput> | activity_logCreateWithoutUserInput[] | activity_logUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activity_logCreateOrConnectWithoutUserInput | activity_logCreateOrConnectWithoutUserInput[]
    upsert?: activity_logUpsertWithWhereUniqueWithoutUserInput | activity_logUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activity_logCreateManyUserInputEnvelope
    set?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    disconnect?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    delete?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    connect?: activity_logWhereUniqueInput | activity_logWhereUniqueInput[]
    update?: activity_logUpdateWithWhereUniqueWithoutUserInput | activity_logUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activity_logUpdateManyWithWhereWithoutUserInput | activity_logUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activity_logScalarWhereInput | activity_logScalarWhereInput[]
  }

  export type student_rewardsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<student_rewardsCreateWithoutUserInput, student_rewardsUncheckedCreateWithoutUserInput> | student_rewardsCreateWithoutUserInput[] | student_rewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutUserInput | student_rewardsCreateOrConnectWithoutUserInput[]
    upsert?: student_rewardsUpsertWithWhereUniqueWithoutUserInput | student_rewardsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: student_rewardsCreateManyUserInputEnvelope
    set?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    disconnect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    delete?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    update?: student_rewardsUpdateWithWhereUniqueWithoutUserInput | student_rewardsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: student_rewardsUpdateManyWithWhereWithoutUserInput | student_rewardsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: student_rewardsScalarWhereInput | student_rewardsScalarWhereInput[]
  }

  export type student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<student_guardiansCreateWithoutGuardianInput, student_guardiansUncheckedCreateWithoutGuardianInput> | student_guardiansCreateWithoutGuardianInput[] | student_guardiansUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutGuardianInput | student_guardiansCreateOrConnectWithoutGuardianInput[]
    upsert?: student_guardiansUpsertWithWhereUniqueWithoutGuardianInput | student_guardiansUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: student_guardiansCreateManyGuardianInputEnvelope
    set?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    disconnect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    delete?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    update?: student_guardiansUpdateWithWhereUniqueWithoutGuardianInput | student_guardiansUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: student_guardiansUpdateManyWithWhereWithoutGuardianInput | student_guardiansUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: student_guardiansScalarWhereInput | student_guardiansScalarWhereInput[]
  }

  export type student_guardiansUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<student_guardiansCreateWithoutStudentInput, student_guardiansUncheckedCreateWithoutStudentInput> | student_guardiansCreateWithoutStudentInput[] | student_guardiansUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_guardiansCreateOrConnectWithoutStudentInput | student_guardiansCreateOrConnectWithoutStudentInput[]
    upsert?: student_guardiansUpsertWithWhereUniqueWithoutStudentInput | student_guardiansUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: student_guardiansCreateManyStudentInputEnvelope
    set?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    disconnect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    delete?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    connect?: student_guardiansWhereUniqueInput | student_guardiansWhereUniqueInput[]
    update?: student_guardiansUpdateWithWhereUniqueWithoutStudentInput | student_guardiansUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: student_guardiansUpdateManyWithWhereWithoutStudentInput | student_guardiansUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: student_guardiansScalarWhereInput | student_guardiansScalarWhereInput[]
  }

  export type test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutAssignerInput, test_assignmentsUncheckedCreateWithoutAssignerInput> | test_assignmentsCreateWithoutAssignerInput[] | test_assignmentsUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutAssignerInput | test_assignmentsCreateOrConnectWithoutAssignerInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutAssignerInput | test_assignmentsUpsertWithWhereUniqueWithoutAssignerInput[]
    createMany?: test_assignmentsCreateManyAssignerInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutAssignerInput | test_assignmentsUpdateWithWhereUniqueWithoutAssignerInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutAssignerInput | test_assignmentsUpdateManyWithWhereWithoutAssignerInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutStudentInput, test_assignmentsUncheckedCreateWithoutStudentInput> | test_assignmentsCreateWithoutStudentInput[] | test_assignmentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutStudentInput | test_assignmentsCreateOrConnectWithoutStudentInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutStudentInput | test_assignmentsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: test_assignmentsCreateManyStudentInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutStudentInput | test_assignmentsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutStudentInput | test_assignmentsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type subjectsCreateNestedOneWithoutDifficulty_levelsInput = {
    create?: XOR<subjectsCreateWithoutDifficulty_levelsInput, subjectsUncheckedCreateWithoutDifficulty_levelsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutDifficulty_levelsInput
    connect?: subjectsWhereUniqueInput
  }

  export type subjectsUpdateOneRequiredWithoutDifficulty_levelsNestedInput = {
    create?: XOR<subjectsCreateWithoutDifficulty_levelsInput, subjectsUncheckedCreateWithoutDifficulty_levelsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutDifficulty_levelsInput
    upsert?: subjectsUpsertWithoutDifficulty_levelsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutDifficulty_levelsInput, subjectsUpdateWithoutDifficulty_levelsInput>, subjectsUncheckedUpdateWithoutDifficulty_levelsInput>
  }

  export type usersCreateNestedOneWithoutStudent_progressInput = {
    create?: XOR<usersCreateWithoutStudent_progressInput, usersUncheckedCreateWithoutStudent_progressInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_progressInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutStudent_progressNestedInput = {
    create?: XOR<usersCreateWithoutStudent_progressInput, usersUncheckedCreateWithoutStudent_progressInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_progressInput
    upsert?: usersUpsertWithoutStudent_progressInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudent_progressInput, usersUpdateWithoutStudent_progressInput>, usersUncheckedUpdateWithoutStudent_progressInput>
  }

  export type student_achievementsCreateNestedManyWithoutAchievementsInput = {
    create?: XOR<student_achievementsCreateWithoutAchievementsInput, student_achievementsUncheckedCreateWithoutAchievementsInput> | student_achievementsCreateWithoutAchievementsInput[] | student_achievementsUncheckedCreateWithoutAchievementsInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutAchievementsInput | student_achievementsCreateOrConnectWithoutAchievementsInput[]
    createMany?: student_achievementsCreateManyAchievementsInputEnvelope
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
  }

  export type student_achievementsUncheckedCreateNestedManyWithoutAchievementsInput = {
    create?: XOR<student_achievementsCreateWithoutAchievementsInput, student_achievementsUncheckedCreateWithoutAchievementsInput> | student_achievementsCreateWithoutAchievementsInput[] | student_achievementsUncheckedCreateWithoutAchievementsInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutAchievementsInput | student_achievementsCreateOrConnectWithoutAchievementsInput[]
    createMany?: student_achievementsCreateManyAchievementsInputEnvelope
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
  }

  export type student_achievementsUpdateManyWithoutAchievementsNestedInput = {
    create?: XOR<student_achievementsCreateWithoutAchievementsInput, student_achievementsUncheckedCreateWithoutAchievementsInput> | student_achievementsCreateWithoutAchievementsInput[] | student_achievementsUncheckedCreateWithoutAchievementsInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutAchievementsInput | student_achievementsCreateOrConnectWithoutAchievementsInput[]
    upsert?: student_achievementsUpsertWithWhereUniqueWithoutAchievementsInput | student_achievementsUpsertWithWhereUniqueWithoutAchievementsInput[]
    createMany?: student_achievementsCreateManyAchievementsInputEnvelope
    set?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    disconnect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    delete?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    update?: student_achievementsUpdateWithWhereUniqueWithoutAchievementsInput | student_achievementsUpdateWithWhereUniqueWithoutAchievementsInput[]
    updateMany?: student_achievementsUpdateManyWithWhereWithoutAchievementsInput | student_achievementsUpdateManyWithWhereWithoutAchievementsInput[]
    deleteMany?: student_achievementsScalarWhereInput | student_achievementsScalarWhereInput[]
  }

  export type student_achievementsUncheckedUpdateManyWithoutAchievementsNestedInput = {
    create?: XOR<student_achievementsCreateWithoutAchievementsInput, student_achievementsUncheckedCreateWithoutAchievementsInput> | student_achievementsCreateWithoutAchievementsInput[] | student_achievementsUncheckedCreateWithoutAchievementsInput[]
    connectOrCreate?: student_achievementsCreateOrConnectWithoutAchievementsInput | student_achievementsCreateOrConnectWithoutAchievementsInput[]
    upsert?: student_achievementsUpsertWithWhereUniqueWithoutAchievementsInput | student_achievementsUpsertWithWhereUniqueWithoutAchievementsInput[]
    createMany?: student_achievementsCreateManyAchievementsInputEnvelope
    set?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    disconnect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    delete?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    connect?: student_achievementsWhereUniqueInput | student_achievementsWhereUniqueInput[]
    update?: student_achievementsUpdateWithWhereUniqueWithoutAchievementsInput | student_achievementsUpdateWithWhereUniqueWithoutAchievementsInput[]
    updateMany?: student_achievementsUpdateManyWithWhereWithoutAchievementsInput | student_achievementsUpdateManyWithWhereWithoutAchievementsInput[]
    deleteMany?: student_achievementsScalarWhereInput | student_achievementsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutAchievements_earnedInput = {
    create?: XOR<usersCreateWithoutAchievements_earnedInput, usersUncheckedCreateWithoutAchievements_earnedInput>
    connectOrCreate?: usersCreateOrConnectWithoutAchievements_earnedInput
    connect?: usersWhereUniqueInput
  }

  export type achievementsCreateNestedOneWithoutStudent_achievementsInput = {
    create?: XOR<achievementsCreateWithoutStudent_achievementsInput, achievementsUncheckedCreateWithoutStudent_achievementsInput>
    connectOrCreate?: achievementsCreateOrConnectWithoutStudent_achievementsInput
    connect?: achievementsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAchievements_earnedNestedInput = {
    create?: XOR<usersCreateWithoutAchievements_earnedInput, usersUncheckedCreateWithoutAchievements_earnedInput>
    connectOrCreate?: usersCreateOrConnectWithoutAchievements_earnedInput
    upsert?: usersUpsertWithoutAchievements_earnedInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAchievements_earnedInput, usersUpdateWithoutAchievements_earnedInput>, usersUncheckedUpdateWithoutAchievements_earnedInput>
  }

  export type achievementsUpdateOneRequiredWithoutStudent_achievementsNestedInput = {
    create?: XOR<achievementsCreateWithoutStudent_achievementsInput, achievementsUncheckedCreateWithoutStudent_achievementsInput>
    connectOrCreate?: achievementsCreateOrConnectWithoutStudent_achievementsInput
    upsert?: achievementsUpsertWithoutStudent_achievementsInput
    connect?: achievementsWhereUniqueInput
    update?: XOR<XOR<achievementsUpdateToOneWithWhereWithoutStudent_achievementsInput, achievementsUpdateWithoutStudent_achievementsInput>, achievementsUncheckedUpdateWithoutStudent_achievementsInput>
  }

  export type student_rewardsCreateNestedManyWithoutRewardsInput = {
    create?: XOR<student_rewardsCreateWithoutRewardsInput, student_rewardsUncheckedCreateWithoutRewardsInput> | student_rewardsCreateWithoutRewardsInput[] | student_rewardsUncheckedCreateWithoutRewardsInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutRewardsInput | student_rewardsCreateOrConnectWithoutRewardsInput[]
    createMany?: student_rewardsCreateManyRewardsInputEnvelope
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
  }

  export type student_rewardsUncheckedCreateNestedManyWithoutRewardsInput = {
    create?: XOR<student_rewardsCreateWithoutRewardsInput, student_rewardsUncheckedCreateWithoutRewardsInput> | student_rewardsCreateWithoutRewardsInput[] | student_rewardsUncheckedCreateWithoutRewardsInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutRewardsInput | student_rewardsCreateOrConnectWithoutRewardsInput[]
    createMany?: student_rewardsCreateManyRewardsInputEnvelope
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
  }

  export type student_rewardsUpdateManyWithoutRewardsNestedInput = {
    create?: XOR<student_rewardsCreateWithoutRewardsInput, student_rewardsUncheckedCreateWithoutRewardsInput> | student_rewardsCreateWithoutRewardsInput[] | student_rewardsUncheckedCreateWithoutRewardsInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutRewardsInput | student_rewardsCreateOrConnectWithoutRewardsInput[]
    upsert?: student_rewardsUpsertWithWhereUniqueWithoutRewardsInput | student_rewardsUpsertWithWhereUniqueWithoutRewardsInput[]
    createMany?: student_rewardsCreateManyRewardsInputEnvelope
    set?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    disconnect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    delete?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    update?: student_rewardsUpdateWithWhereUniqueWithoutRewardsInput | student_rewardsUpdateWithWhereUniqueWithoutRewardsInput[]
    updateMany?: student_rewardsUpdateManyWithWhereWithoutRewardsInput | student_rewardsUpdateManyWithWhereWithoutRewardsInput[]
    deleteMany?: student_rewardsScalarWhereInput | student_rewardsScalarWhereInput[]
  }

  export type student_rewardsUncheckedUpdateManyWithoutRewardsNestedInput = {
    create?: XOR<student_rewardsCreateWithoutRewardsInput, student_rewardsUncheckedCreateWithoutRewardsInput> | student_rewardsCreateWithoutRewardsInput[] | student_rewardsUncheckedCreateWithoutRewardsInput[]
    connectOrCreate?: student_rewardsCreateOrConnectWithoutRewardsInput | student_rewardsCreateOrConnectWithoutRewardsInput[]
    upsert?: student_rewardsUpsertWithWhereUniqueWithoutRewardsInput | student_rewardsUpsertWithWhereUniqueWithoutRewardsInput[]
    createMany?: student_rewardsCreateManyRewardsInputEnvelope
    set?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    disconnect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    delete?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    connect?: student_rewardsWhereUniqueInput | student_rewardsWhereUniqueInput[]
    update?: student_rewardsUpdateWithWhereUniqueWithoutRewardsInput | student_rewardsUpdateWithWhereUniqueWithoutRewardsInput[]
    updateMany?: student_rewardsUpdateManyWithWhereWithoutRewardsInput | student_rewardsUpdateManyWithWhereWithoutRewardsInput[]
    deleteMany?: student_rewardsScalarWhereInput | student_rewardsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutStudent_rewardsInput = {
    create?: XOR<usersCreateWithoutStudent_rewardsInput, usersUncheckedCreateWithoutStudent_rewardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_rewardsInput
    connect?: usersWhereUniqueInput
  }

  export type rewardsCreateNestedOneWithoutStudent_rewardsInput = {
    create?: XOR<rewardsCreateWithoutStudent_rewardsInput, rewardsUncheckedCreateWithoutStudent_rewardsInput>
    connectOrCreate?: rewardsCreateOrConnectWithoutStudent_rewardsInput
    connect?: rewardsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutStudent_rewardsNestedInput = {
    create?: XOR<usersCreateWithoutStudent_rewardsInput, usersUncheckedCreateWithoutStudent_rewardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_rewardsInput
    upsert?: usersUpsertWithoutStudent_rewardsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudent_rewardsInput, usersUpdateWithoutStudent_rewardsInput>, usersUncheckedUpdateWithoutStudent_rewardsInput>
  }

  export type rewardsUpdateOneRequiredWithoutStudent_rewardsNestedInput = {
    create?: XOR<rewardsCreateWithoutStudent_rewardsInput, rewardsUncheckedCreateWithoutStudent_rewardsInput>
    connectOrCreate?: rewardsCreateOrConnectWithoutStudent_rewardsInput
    upsert?: rewardsUpsertWithoutStudent_rewardsInput
    connect?: rewardsWhereUniqueInput
    update?: XOR<XOR<rewardsUpdateToOneWithWhereWithoutStudent_rewardsInput, rewardsUpdateWithoutStudent_rewardsInput>, rewardsUncheckedUpdateWithoutStudent_rewardsInput>
  }

  export type usersCreateNestedOneWithoutSubject_masteryInput = {
    create?: XOR<usersCreateWithoutSubject_masteryInput, usersUncheckedCreateWithoutSubject_masteryInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubject_masteryInput
    connect?: usersWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutSubject_masteryInput = {
    create?: XOR<subjectsCreateWithoutSubject_masteryInput, subjectsUncheckedCreateWithoutSubject_masteryInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_masteryInput
    connect?: subjectsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSubject_masteryNestedInput = {
    create?: XOR<usersCreateWithoutSubject_masteryInput, usersUncheckedCreateWithoutSubject_masteryInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubject_masteryInput
    upsert?: usersUpsertWithoutSubject_masteryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSubject_masteryInput, usersUpdateWithoutSubject_masteryInput>, usersUncheckedUpdateWithoutSubject_masteryInput>
  }

  export type subjectsUpdateOneRequiredWithoutSubject_masteryNestedInput = {
    create?: XOR<subjectsCreateWithoutSubject_masteryInput, subjectsUncheckedCreateWithoutSubject_masteryInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_masteryInput
    upsert?: subjectsUpsertWithoutSubject_masteryInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutSubject_masteryInput, subjectsUpdateWithoutSubject_masteryInput>, subjectsUncheckedUpdateWithoutSubject_masteryInput>
  }

  export type usersCreateNestedOneWithoutActivity_logsInput = {
    create?: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutActivity_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutActivity_logsNestedInput = {
    create?: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutActivity_logsInput
    upsert?: usersUpsertWithoutActivity_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutActivity_logsInput, usersUpdateWithoutActivity_logsInput>, usersUncheckedUpdateWithoutActivity_logsInput>
  }

  export type usersCreateNestedOneWithoutTutor_groupsInput = {
    create?: XOR<usersCreateWithoutTutor_groupsInput, usersUncheckedCreateWithoutTutor_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTutor_groupsInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutStudent_groupsInput = {
    create?: XOR<usersCreateWithoutStudent_groupsInput, usersUncheckedCreateWithoutStudent_groupsInput> | usersCreateWithoutStudent_groupsInput[] | usersUncheckedCreateWithoutStudent_groupsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStudent_groupsInput | usersCreateOrConnectWithoutStudent_groupsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type group_membersCreateNestedManyWithoutGroupInput = {
    create?: XOR<group_membersCreateWithoutGroupInput, group_membersUncheckedCreateWithoutGroupInput> | group_membersCreateWithoutGroupInput[] | group_membersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutGroupInput | group_membersCreateOrConnectWithoutGroupInput[]
    createMany?: group_membersCreateManyGroupInputEnvelope
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
  }

  export type test_assignmentsCreateNestedManyWithoutGroupInput = {
    create?: XOR<test_assignmentsCreateWithoutGroupInput, test_assignmentsUncheckedCreateWithoutGroupInput> | test_assignmentsCreateWithoutGroupInput[] | test_assignmentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutGroupInput | test_assignmentsCreateOrConnectWithoutGroupInput[]
    createMany?: test_assignmentsCreateManyGroupInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type test_plansCreateNestedManyWithoutStudy_groupsInput = {
    create?: XOR<test_plansCreateWithoutStudy_groupsInput, test_plansUncheckedCreateWithoutStudy_groupsInput> | test_plansCreateWithoutStudy_groupsInput[] | test_plansUncheckedCreateWithoutStudy_groupsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudy_groupsInput | test_plansCreateOrConnectWithoutStudy_groupsInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutStudent_groupsInput = {
    create?: XOR<usersCreateWithoutStudent_groupsInput, usersUncheckedCreateWithoutStudent_groupsInput> | usersCreateWithoutStudent_groupsInput[] | usersUncheckedCreateWithoutStudent_groupsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStudent_groupsInput | usersCreateOrConnectWithoutStudent_groupsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type group_membersUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<group_membersCreateWithoutGroupInput, group_membersUncheckedCreateWithoutGroupInput> | group_membersCreateWithoutGroupInput[] | group_membersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutGroupInput | group_membersCreateOrConnectWithoutGroupInput[]
    createMany?: group_membersCreateManyGroupInputEnvelope
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
  }

  export type test_assignmentsUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<test_assignmentsCreateWithoutGroupInput, test_assignmentsUncheckedCreateWithoutGroupInput> | test_assignmentsCreateWithoutGroupInput[] | test_assignmentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutGroupInput | test_assignmentsCreateOrConnectWithoutGroupInput[]
    createMany?: test_assignmentsCreateManyGroupInputEnvelope
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
  }

  export type test_plansUncheckedCreateNestedManyWithoutStudy_groupsInput = {
    create?: XOR<test_plansCreateWithoutStudy_groupsInput, test_plansUncheckedCreateWithoutStudy_groupsInput> | test_plansCreateWithoutStudy_groupsInput[] | test_plansUncheckedCreateWithoutStudy_groupsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudy_groupsInput | test_plansCreateOrConnectWithoutStudy_groupsInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutTutor_groupsNestedInput = {
    create?: XOR<usersCreateWithoutTutor_groupsInput, usersUncheckedCreateWithoutTutor_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTutor_groupsInput
    upsert?: usersUpsertWithoutTutor_groupsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTutor_groupsInput, usersUpdateWithoutTutor_groupsInput>, usersUncheckedUpdateWithoutTutor_groupsInput>
  }

  export type usersUpdateManyWithoutStudent_groupsNestedInput = {
    create?: XOR<usersCreateWithoutStudent_groupsInput, usersUncheckedCreateWithoutStudent_groupsInput> | usersCreateWithoutStudent_groupsInput[] | usersUncheckedCreateWithoutStudent_groupsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStudent_groupsInput | usersCreateOrConnectWithoutStudent_groupsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutStudent_groupsInput | usersUpsertWithWhereUniqueWithoutStudent_groupsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutStudent_groupsInput | usersUpdateWithWhereUniqueWithoutStudent_groupsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutStudent_groupsInput | usersUpdateManyWithWhereWithoutStudent_groupsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type group_membersUpdateManyWithoutGroupNestedInput = {
    create?: XOR<group_membersCreateWithoutGroupInput, group_membersUncheckedCreateWithoutGroupInput> | group_membersCreateWithoutGroupInput[] | group_membersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutGroupInput | group_membersCreateOrConnectWithoutGroupInput[]
    upsert?: group_membersUpsertWithWhereUniqueWithoutGroupInput | group_membersUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: group_membersCreateManyGroupInputEnvelope
    set?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    disconnect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    delete?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    update?: group_membersUpdateWithWhereUniqueWithoutGroupInput | group_membersUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: group_membersUpdateManyWithWhereWithoutGroupInput | group_membersUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: group_membersScalarWhereInput | group_membersScalarWhereInput[]
  }

  export type test_assignmentsUpdateManyWithoutGroupNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutGroupInput, test_assignmentsUncheckedCreateWithoutGroupInput> | test_assignmentsCreateWithoutGroupInput[] | test_assignmentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutGroupInput | test_assignmentsCreateOrConnectWithoutGroupInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutGroupInput | test_assignmentsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: test_assignmentsCreateManyGroupInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutGroupInput | test_assignmentsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutGroupInput | test_assignmentsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type test_plansUpdateManyWithoutStudy_groupsNestedInput = {
    create?: XOR<test_plansCreateWithoutStudy_groupsInput, test_plansUncheckedCreateWithoutStudy_groupsInput> | test_plansCreateWithoutStudy_groupsInput[] | test_plansUncheckedCreateWithoutStudy_groupsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudy_groupsInput | test_plansCreateOrConnectWithoutStudy_groupsInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutStudy_groupsInput | test_plansUpsertWithWhereUniqueWithoutStudy_groupsInput[]
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutStudy_groupsInput | test_plansUpdateWithWhereUniqueWithoutStudy_groupsInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutStudy_groupsInput | test_plansUpdateManyWithWhereWithoutStudy_groupsInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutStudent_groupsNestedInput = {
    create?: XOR<usersCreateWithoutStudent_groupsInput, usersUncheckedCreateWithoutStudent_groupsInput> | usersCreateWithoutStudent_groupsInput[] | usersUncheckedCreateWithoutStudent_groupsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStudent_groupsInput | usersCreateOrConnectWithoutStudent_groupsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutStudent_groupsInput | usersUpsertWithWhereUniqueWithoutStudent_groupsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutStudent_groupsInput | usersUpdateWithWhereUniqueWithoutStudent_groupsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutStudent_groupsInput | usersUpdateManyWithWhereWithoutStudent_groupsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type group_membersUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<group_membersCreateWithoutGroupInput, group_membersUncheckedCreateWithoutGroupInput> | group_membersCreateWithoutGroupInput[] | group_membersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: group_membersCreateOrConnectWithoutGroupInput | group_membersCreateOrConnectWithoutGroupInput[]
    upsert?: group_membersUpsertWithWhereUniqueWithoutGroupInput | group_membersUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: group_membersCreateManyGroupInputEnvelope
    set?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    disconnect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    delete?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    connect?: group_membersWhereUniqueInput | group_membersWhereUniqueInput[]
    update?: group_membersUpdateWithWhereUniqueWithoutGroupInput | group_membersUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: group_membersUpdateManyWithWhereWithoutGroupInput | group_membersUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: group_membersScalarWhereInput | group_membersScalarWhereInput[]
  }

  export type test_assignmentsUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<test_assignmentsCreateWithoutGroupInput, test_assignmentsUncheckedCreateWithoutGroupInput> | test_assignmentsCreateWithoutGroupInput[] | test_assignmentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: test_assignmentsCreateOrConnectWithoutGroupInput | test_assignmentsCreateOrConnectWithoutGroupInput[]
    upsert?: test_assignmentsUpsertWithWhereUniqueWithoutGroupInput | test_assignmentsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: test_assignmentsCreateManyGroupInputEnvelope
    set?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    disconnect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    delete?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    connect?: test_assignmentsWhereUniqueInput | test_assignmentsWhereUniqueInput[]
    update?: test_assignmentsUpdateWithWhereUniqueWithoutGroupInput | test_assignmentsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: test_assignmentsUpdateManyWithWhereWithoutGroupInput | test_assignmentsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
  }

  export type test_plansUncheckedUpdateManyWithoutStudy_groupsNestedInput = {
    create?: XOR<test_plansCreateWithoutStudy_groupsInput, test_plansUncheckedCreateWithoutStudy_groupsInput> | test_plansCreateWithoutStudy_groupsInput[] | test_plansUncheckedCreateWithoutStudy_groupsInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutStudy_groupsInput | test_plansCreateOrConnectWithoutStudy_groupsInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutStudy_groupsInput | test_plansUpsertWithWhereUniqueWithoutStudy_groupsInput[]
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutStudy_groupsInput | test_plansUpdateWithWhereUniqueWithoutStudy_groupsInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutStudy_groupsInput | test_plansUpdateManyWithWhereWithoutStudy_groupsInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutGuardian_relationshipsInput = {
    create?: XOR<usersCreateWithoutGuardian_relationshipsInput, usersUncheckedCreateWithoutGuardian_relationshipsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGuardian_relationshipsInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutStudent_relationshipsInput = {
    create?: XOR<usersCreateWithoutStudent_relationshipsInput, usersUncheckedCreateWithoutStudent_relationshipsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_relationshipsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumGuardianRelationTypeFieldUpdateOperationsInput = {
    set?: $Enums.GuardianRelationType
  }

  export type EnumGuardianRelationStatusFieldUpdateOperationsInput = {
    set?: $Enums.GuardianRelationStatus
  }

  export type usersUpdateOneRequiredWithoutGuardian_relationshipsNestedInput = {
    create?: XOR<usersCreateWithoutGuardian_relationshipsInput, usersUncheckedCreateWithoutGuardian_relationshipsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGuardian_relationshipsInput
    upsert?: usersUpsertWithoutGuardian_relationshipsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGuardian_relationshipsInput, usersUpdateWithoutGuardian_relationshipsInput>, usersUncheckedUpdateWithoutGuardian_relationshipsInput>
  }

  export type usersUpdateOneRequiredWithoutStudent_relationshipsNestedInput = {
    create?: XOR<usersCreateWithoutStudent_relationshipsInput, usersUncheckedCreateWithoutStudent_relationshipsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_relationshipsInput
    upsert?: usersUpsertWithoutStudent_relationshipsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudent_relationshipsInput, usersUpdateWithoutStudent_relationshipsInput>, usersUncheckedUpdateWithoutStudent_relationshipsInput>
  }

  export type study_groupsCreateNestedOneWithoutMembersInput = {
    create?: XOR<study_groupsCreateWithoutMembersInput, study_groupsUncheckedCreateWithoutMembersInput>
    connectOrCreate?: study_groupsCreateOrConnectWithoutMembersInput
    connect?: study_groupsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutGroup_membershipsInput = {
    create?: XOR<usersCreateWithoutGroup_membershipsInput, usersUncheckedCreateWithoutGroup_membershipsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGroup_membershipsInput
    connect?: usersWhereUniqueInput
  }

  export type study_groupsUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<study_groupsCreateWithoutMembersInput, study_groupsUncheckedCreateWithoutMembersInput>
    connectOrCreate?: study_groupsCreateOrConnectWithoutMembersInput
    upsert?: study_groupsUpsertWithoutMembersInput
    connect?: study_groupsWhereUniqueInput
    update?: XOR<XOR<study_groupsUpdateToOneWithWhereWithoutMembersInput, study_groupsUpdateWithoutMembersInput>, study_groupsUncheckedUpdateWithoutMembersInput>
  }

  export type usersUpdateOneRequiredWithoutGroup_membershipsNestedInput = {
    create?: XOR<usersCreateWithoutGroup_membershipsInput, usersUncheckedCreateWithoutGroup_membershipsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGroup_membershipsInput
    upsert?: usersUpsertWithoutGroup_membershipsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGroup_membershipsInput, usersUpdateWithoutGroup_membershipsInput>, usersUncheckedUpdateWithoutGroup_membershipsInput>
  }

  export type test_plansCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<test_plansCreateWithoutAssignmentsInput, test_plansUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutAssignmentsInput
    connect?: test_plansWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAssignments_createdInput = {
    create?: XOR<usersCreateWithoutAssignments_createdInput, usersUncheckedCreateWithoutAssignments_createdInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssignments_createdInput
    connect?: usersWhereUniqueInput
  }

  export type study_groupsCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<study_groupsCreateWithoutAssignmentsInput, study_groupsUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: study_groupsCreateOrConnectWithoutAssignmentsInput
    connect?: study_groupsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAssignments_receivedInput = {
    create?: XOR<usersCreateWithoutAssignments_receivedInput, usersUncheckedCreateWithoutAssignments_receivedInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssignments_receivedInput
    connect?: usersWhereUniqueInput
  }

  export type EnumTestAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.TestAssignmentStatus
  }

  export type test_plansUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<test_plansCreateWithoutAssignmentsInput, test_plansUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutAssignmentsInput
    upsert?: test_plansUpsertWithoutAssignmentsInput
    connect?: test_plansWhereUniqueInput
    update?: XOR<XOR<test_plansUpdateToOneWithWhereWithoutAssignmentsInput, test_plansUpdateWithoutAssignmentsInput>, test_plansUncheckedUpdateWithoutAssignmentsInput>
  }

  export type usersUpdateOneRequiredWithoutAssignments_createdNestedInput = {
    create?: XOR<usersCreateWithoutAssignments_createdInput, usersUncheckedCreateWithoutAssignments_createdInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssignments_createdInput
    upsert?: usersUpsertWithoutAssignments_createdInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAssignments_createdInput, usersUpdateWithoutAssignments_createdInput>, usersUncheckedUpdateWithoutAssignments_createdInput>
  }

  export type study_groupsUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<study_groupsCreateWithoutAssignmentsInput, study_groupsUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: study_groupsCreateOrConnectWithoutAssignmentsInput
    upsert?: study_groupsUpsertWithoutAssignmentsInput
    disconnect?: study_groupsWhereInput | boolean
    delete?: study_groupsWhereInput | boolean
    connect?: study_groupsWhereUniqueInput
    update?: XOR<XOR<study_groupsUpdateToOneWithWhereWithoutAssignmentsInput, study_groupsUpdateWithoutAssignmentsInput>, study_groupsUncheckedUpdateWithoutAssignmentsInput>
  }

  export type usersUpdateOneWithoutAssignments_receivedNestedInput = {
    create?: XOR<usersCreateWithoutAssignments_receivedInput, usersUncheckedCreateWithoutAssignments_receivedInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssignments_receivedInput
    upsert?: usersUpsertWithoutAssignments_receivedInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAssignments_receivedInput, usersUpdateWithoutAssignments_receivedInput>, usersUncheckedUpdateWithoutAssignments_receivedInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumexam_boards_input_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.exam_boards_input_type | Enumexam_boards_input_typeFieldRefInput<$PrismaModel>
    in?: $Enums.exam_boards_input_type[]
    notIn?: $Enums.exam_boards_input_type[]
    not?: NestedEnumexam_boards_input_typeFilter<$PrismaModel> | $Enums.exam_boards_input_type
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumexam_boards_input_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.exam_boards_input_type | Enumexam_boards_input_typeFieldRefInput<$PrismaModel>
    in?: $Enums.exam_boards_input_type[]
    notIn?: $Enums.exam_boards_input_type[]
    not?: NestedEnumexam_boards_input_typeWithAggregatesFilter<$PrismaModel> | $Enums.exam_boards_input_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumexam_boards_input_typeFilter<$PrismaModel>
    _max?: NestedEnumexam_boards_input_typeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumtest_executions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_executions_status | Enumtest_executions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_executions_status[]
    notIn?: $Enums.test_executions_status[]
    not?: NestedEnumtest_executions_statusFilter<$PrismaModel> | $Enums.test_executions_status
  }

  export type NestedEnumtest_executions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_executions_status | Enumtest_executions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_executions_status[]
    notIn?: $Enums.test_executions_status[]
    not?: NestedEnumtest_executions_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_executions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_executions_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_executions_statusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumtest_plans_test_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_test_type | Enumtest_plans_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_test_type[]
    notIn?: $Enums.test_plans_test_type[]
    not?: NestedEnumtest_plans_test_typeFilter<$PrismaModel> | $Enums.test_plans_test_type
  }

  export type NestedEnumtest_plans_timing_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_timing_type | Enumtest_plans_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_timing_type[]
    notIn?: $Enums.test_plans_timing_type[]
    not?: NestedEnumtest_plans_timing_typeFilter<$PrismaModel> | $Enums.test_plans_timing_type
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumtest_plans_test_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_test_type | Enumtest_plans_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_test_type[]
    notIn?: $Enums.test_plans_test_type[]
    not?: NestedEnumtest_plans_test_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_plans_test_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plans_test_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_plans_test_typeFilter<$PrismaModel>
  }

  export type NestedEnumtest_plans_timing_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plans_timing_type | Enumtest_plans_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plans_timing_type[]
    notIn?: $Enums.test_plans_timing_type[]
    not?: NestedEnumtest_plans_timing_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_plans_timing_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plans_timing_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_plans_timing_typeFilter<$PrismaModel>
  }

  export type NestedEnumtest_templates_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_source | Enumtest_templates_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_source[]
    notIn?: $Enums.test_templates_source[]
    not?: NestedEnumtest_templates_sourceFilter<$PrismaModel> | $Enums.test_templates_source
  }

  export type NestedEnumtest_templates_test_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_test_type | Enumtest_templates_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_test_type[]
    notIn?: $Enums.test_templates_test_type[]
    not?: NestedEnumtest_templates_test_typeFilter<$PrismaModel> | $Enums.test_templates_test_type
  }

  export type NestedEnumtest_templates_timing_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_timing_type | Enumtest_templates_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_timing_type[]
    notIn?: $Enums.test_templates_timing_type[]
    not?: NestedEnumtest_templates_timing_typeFilter<$PrismaModel> | $Enums.test_templates_timing_type
  }

  export type NestedEnumtest_templates_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_source | Enumtest_templates_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_source[]
    notIn?: $Enums.test_templates_source[]
    not?: NestedEnumtest_templates_sourceWithAggregatesFilter<$PrismaModel> | $Enums.test_templates_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_templates_sourceFilter<$PrismaModel>
    _max?: NestedEnumtest_templates_sourceFilter<$PrismaModel>
  }

  export type NestedEnumtest_templates_test_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_test_type | Enumtest_templates_test_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_test_type[]
    notIn?: $Enums.test_templates_test_type[]
    not?: NestedEnumtest_templates_test_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_templates_test_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_templates_test_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_templates_test_typeFilter<$PrismaModel>
  }

  export type NestedEnumtest_templates_timing_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_templates_timing_type | Enumtest_templates_timing_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_templates_timing_type[]
    notIn?: $Enums.test_templates_timing_type[]
    not?: NestedEnumtest_templates_timing_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_templates_timing_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_templates_timing_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_templates_timing_typeFilter<$PrismaModel>
  }

  export type NestedEnumGuardianRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationType | EnumGuardianRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationType[]
    notIn?: $Enums.GuardianRelationType[]
    not?: NestedEnumGuardianRelationTypeFilter<$PrismaModel> | $Enums.GuardianRelationType
  }

  export type NestedEnumGuardianRelationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationStatus | EnumGuardianRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationStatus[]
    notIn?: $Enums.GuardianRelationStatus[]
    not?: NestedEnumGuardianRelationStatusFilter<$PrismaModel> | $Enums.GuardianRelationStatus
  }

  export type NestedEnumGuardianRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationType | EnumGuardianRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationType[]
    notIn?: $Enums.GuardianRelationType[]
    not?: NestedEnumGuardianRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.GuardianRelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuardianRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumGuardianRelationTypeFilter<$PrismaModel>
  }

  export type NestedEnumGuardianRelationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuardianRelationStatus | EnumGuardianRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuardianRelationStatus[]
    notIn?: $Enums.GuardianRelationStatus[]
    not?: NestedEnumGuardianRelationStatusWithAggregatesFilter<$PrismaModel> | $Enums.GuardianRelationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuardianRelationStatusFilter<$PrismaModel>
    _max?: NestedEnumGuardianRelationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTestAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestAssignmentStatus | EnumTestAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestAssignmentStatus[]
    notIn?: $Enums.TestAssignmentStatus[]
    not?: NestedEnumTestAssignmentStatusFilter<$PrismaModel> | $Enums.TestAssignmentStatus
  }

  export type NestedEnumTestAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestAssignmentStatus | EnumTestAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestAssignmentStatus[]
    notIn?: $Enums.TestAssignmentStatus[]
    not?: NestedEnumTestAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestAssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumTestAssignmentStatusFilter<$PrismaModel>
  }

  export type test_plansCreateWithoutExam_boardsInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutExam_boardsInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutExam_boardsInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutExam_boardsInput, test_plansUncheckedCreateWithoutExam_boardsInput>
  }

  export type test_plansCreateManyExam_boardsInputEnvelope = {
    data: test_plansCreateManyExam_boardsInput | test_plansCreateManyExam_boardsInput[]
    skipDuplicates?: boolean
  }

  export type test_templatesCreateWithoutExam_boardsInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_at?: Date | string | null
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    test_plans?: test_plansCreateNestedManyWithoutTest_templatesInput
    users: usersCreateNestedOneWithoutTest_templatesInput
  }

  export type test_templatesUncheckedCreateWithoutExam_boardsInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_by: bigint | number
    created_at?: Date | string | null
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    test_plans?: test_plansUncheckedCreateNestedManyWithoutTest_templatesInput
  }

  export type test_templatesCreateOrConnectWithoutExam_boardsInput = {
    where: test_templatesWhereUniqueInput
    create: XOR<test_templatesCreateWithoutExam_boardsInput, test_templatesUncheckedCreateWithoutExam_boardsInput>
  }

  export type test_templatesCreateManyExam_boardsInputEnvelope = {
    data: test_templatesCreateManyExam_boardsInput | test_templatesCreateManyExam_boardsInput[]
    skipDuplicates?: boolean
  }

  export type test_plansUpsertWithWhereUniqueWithoutExam_boardsInput = {
    where: test_plansWhereUniqueInput
    update: XOR<test_plansUpdateWithoutExam_boardsInput, test_plansUncheckedUpdateWithoutExam_boardsInput>
    create: XOR<test_plansCreateWithoutExam_boardsInput, test_plansUncheckedCreateWithoutExam_boardsInput>
  }

  export type test_plansUpdateWithWhereUniqueWithoutExam_boardsInput = {
    where: test_plansWhereUniqueInput
    data: XOR<test_plansUpdateWithoutExam_boardsInput, test_plansUncheckedUpdateWithoutExam_boardsInput>
  }

  export type test_plansUpdateManyWithWhereWithoutExam_boardsInput = {
    where: test_plansScalarWhereInput
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyWithoutExam_boardsInput>
  }

  export type test_plansScalarWhereInput = {
    AND?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
    OR?: test_plansScalarWhereInput[]
    NOT?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
    test_plan_id?: BigIntFilter<"test_plans"> | bigint | number
    template_id?: BigIntNullableFilter<"test_plans"> | bigint | number | null
    board_id?: IntFilter<"test_plans"> | number
    test_type?: Enumtest_plans_test_typeFilter<"test_plans"> | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFilter<"test_plans"> | $Enums.test_plans_timing_type
    time_limit?: IntNullableFilter<"test_plans"> | number | null
    student_id?: BigIntFilter<"test_plans"> | bigint | number
    planned_by?: BigIntFilter<"test_plans"> | bigint | number
    planned_at?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    configuration?: StringFilter<"test_plans"> | string
  }

  export type test_templatesUpsertWithWhereUniqueWithoutExam_boardsInput = {
    where: test_templatesWhereUniqueInput
    update: XOR<test_templatesUpdateWithoutExam_boardsInput, test_templatesUncheckedUpdateWithoutExam_boardsInput>
    create: XOR<test_templatesCreateWithoutExam_boardsInput, test_templatesUncheckedCreateWithoutExam_boardsInput>
  }

  export type test_templatesUpdateWithWhereUniqueWithoutExam_boardsInput = {
    where: test_templatesWhereUniqueInput
    data: XOR<test_templatesUpdateWithoutExam_boardsInput, test_templatesUncheckedUpdateWithoutExam_boardsInput>
  }

  export type test_templatesUpdateManyWithWhereWithoutExam_boardsInput = {
    where: test_templatesScalarWhereInput
    data: XOR<test_templatesUpdateManyMutationInput, test_templatesUncheckedUpdateManyWithoutExam_boardsInput>
  }

  export type test_templatesScalarWhereInput = {
    AND?: test_templatesScalarWhereInput | test_templatesScalarWhereInput[]
    OR?: test_templatesScalarWhereInput[]
    NOT?: test_templatesScalarWhereInput | test_templatesScalarWhereInput[]
    template_id?: BigIntFilter<"test_templates"> | bigint | number
    template_name?: StringFilter<"test_templates"> | string
    source?: Enumtest_templates_sourceFilter<"test_templates"> | $Enums.test_templates_source
    created_by?: BigIntFilter<"test_templates"> | bigint | number
    created_at?: DateTimeNullableFilter<"test_templates"> | Date | string | null
    board_id?: IntFilter<"test_templates"> | number
    test_type?: Enumtest_templates_test_typeFilter<"test_templates"> | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFilter<"test_templates"> | $Enums.test_templates_timing_type
    time_limit?: IntNullableFilter<"test_templates"> | number | null
    configuration?: StringFilter<"test_templates"> | string
    active?: BoolNullableFilter<"test_templates"> | boolean | null
  }

  export type subtopicsCreateWithoutQuestionsInput = {
    subtopic_name: string
    description?: string | null
    topics: topicsCreateNestedOneWithoutSubtopicsInput
  }

  export type subtopicsUncheckedCreateWithoutQuestionsInput = {
    subtopic_id?: number
    topic_id: number
    subtopic_name: string
    description?: string | null
  }

  export type subtopicsCreateOrConnectWithoutQuestionsInput = {
    where: subtopicsWhereUniqueInput
    create: XOR<subtopicsCreateWithoutQuestionsInput, subtopicsUncheckedCreateWithoutQuestionsInput>
  }

  export type usersCreateWithoutQuestionsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutQuestionsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutQuestionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutQuestionsInput, usersUncheckedCreateWithoutQuestionsInput>
  }

  export type question_set_itemsCreateWithoutQuestionInput = {
    item_id?: bigint | number
    sequence: number
    created_at?: Date | string
    question_set: question_setsCreateNestedOneWithoutQuestion_set_itemsInput
  }

  export type question_set_itemsUncheckedCreateWithoutQuestionInput = {
    item_id?: bigint | number
    set_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type question_set_itemsCreateOrConnectWithoutQuestionInput = {
    where: question_set_itemsWhereUniqueInput
    create: XOR<question_set_itemsCreateWithoutQuestionInput, question_set_itemsUncheckedCreateWithoutQuestionInput>
  }

  export type question_set_itemsCreateManyQuestionInputEnvelope = {
    data: question_set_itemsCreateManyQuestionInput | question_set_itemsCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type subtopicsUpsertWithoutQuestionsInput = {
    update: XOR<subtopicsUpdateWithoutQuestionsInput, subtopicsUncheckedUpdateWithoutQuestionsInput>
    create: XOR<subtopicsCreateWithoutQuestionsInput, subtopicsUncheckedCreateWithoutQuestionsInput>
    where?: subtopicsWhereInput
  }

  export type subtopicsUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: subtopicsWhereInput
    data: XOR<subtopicsUpdateWithoutQuestionsInput, subtopicsUncheckedUpdateWithoutQuestionsInput>
  }

  export type subtopicsUpdateWithoutQuestionsInput = {
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUpdateOneRequiredWithoutSubtopicsNestedInput
  }

  export type subtopicsUncheckedUpdateWithoutQuestionsInput = {
    subtopic_id?: IntFieldUpdateOperationsInput | number
    topic_id?: IntFieldUpdateOperationsInput | number
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpsertWithoutQuestionsInput = {
    update: XOR<usersUpdateWithoutQuestionsInput, usersUncheckedUpdateWithoutQuestionsInput>
    create: XOR<usersCreateWithoutQuestionsInput, usersUncheckedCreateWithoutQuestionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutQuestionsInput, usersUncheckedUpdateWithoutQuestionsInput>
  }

  export type usersUpdateWithoutQuestionsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutQuestionsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type question_set_itemsUpsertWithWhereUniqueWithoutQuestionInput = {
    where: question_set_itemsWhereUniqueInput
    update: XOR<question_set_itemsUpdateWithoutQuestionInput, question_set_itemsUncheckedUpdateWithoutQuestionInput>
    create: XOR<question_set_itemsCreateWithoutQuestionInput, question_set_itemsUncheckedCreateWithoutQuestionInput>
  }

  export type question_set_itemsUpdateWithWhereUniqueWithoutQuestionInput = {
    where: question_set_itemsWhereUniqueInput
    data: XOR<question_set_itemsUpdateWithoutQuestionInput, question_set_itemsUncheckedUpdateWithoutQuestionInput>
  }

  export type question_set_itemsUpdateManyWithWhereWithoutQuestionInput = {
    where: question_set_itemsScalarWhereInput
    data: XOR<question_set_itemsUpdateManyMutationInput, question_set_itemsUncheckedUpdateManyWithoutQuestionInput>
  }

  export type question_set_itemsScalarWhereInput = {
    AND?: question_set_itemsScalarWhereInput | question_set_itemsScalarWhereInput[]
    OR?: question_set_itemsScalarWhereInput[]
    NOT?: question_set_itemsScalarWhereInput | question_set_itemsScalarWhereInput[]
    item_id?: BigIntFilter<"question_set_items"> | bigint | number
    set_id?: BigIntFilter<"question_set_items"> | bigint | number
    question_id?: BigIntFilter<"question_set_items"> | bigint | number
    sequence?: IntFilter<"question_set_items"> | number
    created_at?: DateTimeFilter<"question_set_items"> | Date | string
  }

  export type question_setsCreateWithoutQuestion_set_itemsInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    creator: usersCreateNestedOneWithoutCreated_question_setsInput
    test_plan_links?: test_plan_question_setsCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsUncheckedCreateWithoutQuestion_set_itemsInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_by: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    test_plan_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsCreateOrConnectWithoutQuestion_set_itemsInput = {
    where: question_setsWhereUniqueInput
    create: XOR<question_setsCreateWithoutQuestion_set_itemsInput, question_setsUncheckedCreateWithoutQuestion_set_itemsInput>
  }

  export type questionsCreateWithoutQuestion_set_itemsInput = {
    question_id?: bigint | number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    active?: boolean | null
    subtopics: subtopicsCreateNestedOneWithoutQuestionsInput
    users: usersCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestion_set_itemsInput = {
    question_id?: bigint | number
    subtopic_id: number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    created_by: bigint | number
    active?: boolean | null
  }

  export type questionsCreateOrConnectWithoutQuestion_set_itemsInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestion_set_itemsInput, questionsUncheckedCreateWithoutQuestion_set_itemsInput>
  }

  export type question_setsUpsertWithoutQuestion_set_itemsInput = {
    update: XOR<question_setsUpdateWithoutQuestion_set_itemsInput, question_setsUncheckedUpdateWithoutQuestion_set_itemsInput>
    create: XOR<question_setsCreateWithoutQuestion_set_itemsInput, question_setsUncheckedCreateWithoutQuestion_set_itemsInput>
    where?: question_setsWhereInput
  }

  export type question_setsUpdateToOneWithWhereWithoutQuestion_set_itemsInput = {
    where?: question_setsWhereInput
    data: XOR<question_setsUpdateWithoutQuestion_set_itemsInput, question_setsUncheckedUpdateWithoutQuestion_set_itemsInput>
  }

  export type question_setsUpdateWithoutQuestion_set_itemsInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: usersUpdateOneRequiredWithoutCreated_question_setsNestedInput
    test_plan_links?: test_plan_question_setsUpdateManyWithoutQuestion_setNestedInput
  }

  export type question_setsUncheckedUpdateWithoutQuestion_set_itemsInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    test_plan_links?: test_plan_question_setsUncheckedUpdateManyWithoutQuestion_setNestedInput
  }

  export type questionsUpsertWithoutQuestion_set_itemsInput = {
    update: XOR<questionsUpdateWithoutQuestion_set_itemsInput, questionsUncheckedUpdateWithoutQuestion_set_itemsInput>
    create: XOR<questionsCreateWithoutQuestion_set_itemsInput, questionsUncheckedCreateWithoutQuestion_set_itemsInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutQuestion_set_itemsInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutQuestion_set_itemsInput, questionsUncheckedUpdateWithoutQuestion_set_itemsInput>
  }

  export type questionsUpdateWithoutQuestion_set_itemsInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    subtopics?: subtopicsUpdateOneRequiredWithoutQuestionsNestedInput
    users?: usersUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestion_set_itemsInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subtopic_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersCreateWithoutCreated_question_setsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutCreated_question_setsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutCreated_question_setsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCreated_question_setsInput, usersUncheckedCreateWithoutCreated_question_setsInput>
  }

  export type question_set_itemsCreateWithoutQuestion_setInput = {
    item_id?: bigint | number
    sequence: number
    created_at?: Date | string
    question: questionsCreateNestedOneWithoutQuestion_set_itemsInput
  }

  export type question_set_itemsUncheckedCreateWithoutQuestion_setInput = {
    item_id?: bigint | number
    question_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type question_set_itemsCreateOrConnectWithoutQuestion_setInput = {
    where: question_set_itemsWhereUniqueInput
    create: XOR<question_set_itemsCreateWithoutQuestion_setInput, question_set_itemsUncheckedCreateWithoutQuestion_setInput>
  }

  export type question_set_itemsCreateManyQuestion_setInputEnvelope = {
    data: question_set_itemsCreateManyQuestion_setInput | question_set_itemsCreateManyQuestion_setInput[]
    skipDuplicates?: boolean
  }

  export type test_plan_question_setsCreateWithoutQuestion_setInput = {
    link_id?: bigint | number
    sequence: number
    created_at?: Date | string
    test_plan: test_plansCreateNestedOneWithoutQuestion_set_linksInput
  }

  export type test_plan_question_setsUncheckedCreateWithoutQuestion_setInput = {
    link_id?: bigint | number
    test_plan_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type test_plan_question_setsCreateOrConnectWithoutQuestion_setInput = {
    where: test_plan_question_setsWhereUniqueInput
    create: XOR<test_plan_question_setsCreateWithoutQuestion_setInput, test_plan_question_setsUncheckedCreateWithoutQuestion_setInput>
  }

  export type test_plan_question_setsCreateManyQuestion_setInputEnvelope = {
    data: test_plan_question_setsCreateManyQuestion_setInput | test_plan_question_setsCreateManyQuestion_setInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutCreated_question_setsInput = {
    update: XOR<usersUpdateWithoutCreated_question_setsInput, usersUncheckedUpdateWithoutCreated_question_setsInput>
    create: XOR<usersCreateWithoutCreated_question_setsInput, usersUncheckedCreateWithoutCreated_question_setsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCreated_question_setsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCreated_question_setsInput, usersUncheckedUpdateWithoutCreated_question_setsInput>
  }

  export type usersUpdateWithoutCreated_question_setsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutCreated_question_setsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type question_set_itemsUpsertWithWhereUniqueWithoutQuestion_setInput = {
    where: question_set_itemsWhereUniqueInput
    update: XOR<question_set_itemsUpdateWithoutQuestion_setInput, question_set_itemsUncheckedUpdateWithoutQuestion_setInput>
    create: XOR<question_set_itemsCreateWithoutQuestion_setInput, question_set_itemsUncheckedCreateWithoutQuestion_setInput>
  }

  export type question_set_itemsUpdateWithWhereUniqueWithoutQuestion_setInput = {
    where: question_set_itemsWhereUniqueInput
    data: XOR<question_set_itemsUpdateWithoutQuestion_setInput, question_set_itemsUncheckedUpdateWithoutQuestion_setInput>
  }

  export type question_set_itemsUpdateManyWithWhereWithoutQuestion_setInput = {
    where: question_set_itemsScalarWhereInput
    data: XOR<question_set_itemsUpdateManyMutationInput, question_set_itemsUncheckedUpdateManyWithoutQuestion_setInput>
  }

  export type test_plan_question_setsUpsertWithWhereUniqueWithoutQuestion_setInput = {
    where: test_plan_question_setsWhereUniqueInput
    update: XOR<test_plan_question_setsUpdateWithoutQuestion_setInput, test_plan_question_setsUncheckedUpdateWithoutQuestion_setInput>
    create: XOR<test_plan_question_setsCreateWithoutQuestion_setInput, test_plan_question_setsUncheckedCreateWithoutQuestion_setInput>
  }

  export type test_plan_question_setsUpdateWithWhereUniqueWithoutQuestion_setInput = {
    where: test_plan_question_setsWhereUniqueInput
    data: XOR<test_plan_question_setsUpdateWithoutQuestion_setInput, test_plan_question_setsUncheckedUpdateWithoutQuestion_setInput>
  }

  export type test_plan_question_setsUpdateManyWithWhereWithoutQuestion_setInput = {
    where: test_plan_question_setsScalarWhereInput
    data: XOR<test_plan_question_setsUpdateManyMutationInput, test_plan_question_setsUncheckedUpdateManyWithoutQuestion_setInput>
  }

  export type test_plan_question_setsScalarWhereInput = {
    AND?: test_plan_question_setsScalarWhereInput | test_plan_question_setsScalarWhereInput[]
    OR?: test_plan_question_setsScalarWhereInput[]
    NOT?: test_plan_question_setsScalarWhereInput | test_plan_question_setsScalarWhereInput[]
    link_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    test_plan_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    set_id?: BigIntFilter<"test_plan_question_sets"> | bigint | number
    sequence?: IntFilter<"test_plan_question_sets"> | number
    created_at?: DateTimeFilter<"test_plan_question_sets"> | Date | string
  }

  export type user_rolesCreateWithoutRolesInput = {
    users: usersCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutRolesInput = {
    user_id: bigint | number
  }

  export type user_rolesCreateOrConnectWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesCreateManyRolesInputEnvelope = {
    data: user_rolesCreateManyRolesInput | user_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type user_rolesScalarWhereInput = {
    AND?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    OR?: user_rolesScalarWhereInput[]
    NOT?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    user_id?: BigIntFilter<"user_roles"> | bigint | number
    role_id?: IntFilter<"user_roles"> | number
  }

  export type topicsCreateWithoutSubjectsInput = {
    topic_name: string
    description?: string | null
    subtopics?: subtopicsCreateNestedManyWithoutTopicsInput
  }

  export type topicsUncheckedCreateWithoutSubjectsInput = {
    topic_id?: number
    topic_name: string
    description?: string | null
    subtopics?: subtopicsUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type topicsCreateOrConnectWithoutSubjectsInput = {
    where: topicsWhereUniqueInput
    create: XOR<topicsCreateWithoutSubjectsInput, topicsUncheckedCreateWithoutSubjectsInput>
  }

  export type topicsCreateManySubjectsInputEnvelope = {
    data: topicsCreateManySubjectsInput | topicsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type subject_masteryCreateWithoutSubjectsInput = {
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
    user: usersCreateNestedOneWithoutSubject_masteryInput
  }

  export type subject_masteryUncheckedCreateWithoutSubjectsInput = {
    user_id: bigint | number
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
  }

  export type subject_masteryCreateOrConnectWithoutSubjectsInput = {
    where: subject_masteryWhereUniqueInput
    create: XOR<subject_masteryCreateWithoutSubjectsInput, subject_masteryUncheckedCreateWithoutSubjectsInput>
  }

  export type subject_masteryCreateManySubjectsInputEnvelope = {
    data: subject_masteryCreateManySubjectsInput | subject_masteryCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type difficulty_levelsCreateWithoutSubjectInput = {
    level_name: string
    level_value: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required?: string | null
    created_at?: Date | string | null
    active?: boolean | null
  }

  export type difficulty_levelsUncheckedCreateWithoutSubjectInput = {
    level_id?: number
    level_name: string
    level_value: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required?: string | null
    created_at?: Date | string | null
    active?: boolean | null
  }

  export type difficulty_levelsCreateOrConnectWithoutSubjectInput = {
    where: difficulty_levelsWhereUniqueInput
    create: XOR<difficulty_levelsCreateWithoutSubjectInput, difficulty_levelsUncheckedCreateWithoutSubjectInput>
  }

  export type difficulty_levelsCreateManySubjectInputEnvelope = {
    data: difficulty_levelsCreateManySubjectInput | difficulty_levelsCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type topicsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: topicsWhereUniqueInput
    update: XOR<topicsUpdateWithoutSubjectsInput, topicsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<topicsCreateWithoutSubjectsInput, topicsUncheckedCreateWithoutSubjectsInput>
  }

  export type topicsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: topicsWhereUniqueInput
    data: XOR<topicsUpdateWithoutSubjectsInput, topicsUncheckedUpdateWithoutSubjectsInput>
  }

  export type topicsUpdateManyWithWhereWithoutSubjectsInput = {
    where: topicsScalarWhereInput
    data: XOR<topicsUpdateManyMutationInput, topicsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type topicsScalarWhereInput = {
    AND?: topicsScalarWhereInput | topicsScalarWhereInput[]
    OR?: topicsScalarWhereInput[]
    NOT?: topicsScalarWhereInput | topicsScalarWhereInput[]
    topic_id?: IntFilter<"topics"> | number
    subject_id?: IntFilter<"topics"> | number
    topic_name?: StringFilter<"topics"> | string
    description?: StringNullableFilter<"topics"> | string | null
  }

  export type subject_masteryUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: subject_masteryWhereUniqueInput
    update: XOR<subject_masteryUpdateWithoutSubjectsInput, subject_masteryUncheckedUpdateWithoutSubjectsInput>
    create: XOR<subject_masteryCreateWithoutSubjectsInput, subject_masteryUncheckedCreateWithoutSubjectsInput>
  }

  export type subject_masteryUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: subject_masteryWhereUniqueInput
    data: XOR<subject_masteryUpdateWithoutSubjectsInput, subject_masteryUncheckedUpdateWithoutSubjectsInput>
  }

  export type subject_masteryUpdateManyWithWhereWithoutSubjectsInput = {
    where: subject_masteryScalarWhereInput
    data: XOR<subject_masteryUpdateManyMutationInput, subject_masteryUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type subject_masteryScalarWhereInput = {
    AND?: subject_masteryScalarWhereInput | subject_masteryScalarWhereInput[]
    OR?: subject_masteryScalarWhereInput[]
    NOT?: subject_masteryScalarWhereInput | subject_masteryScalarWhereInput[]
    user_id?: BigIntFilter<"subject_mastery"> | bigint | number
    subject_id?: IntFilter<"subject_mastery"> | number
    mastery_level?: IntFilter<"subject_mastery"> | number
    total_questions_attempted?: IntFilter<"subject_mastery"> | number
    correct_answers?: IntFilter<"subject_mastery"> | number
    last_test_date?: DateTimeNullableFilter<"subject_mastery"> | Date | string | null
  }

  export type difficulty_levelsUpsertWithWhereUniqueWithoutSubjectInput = {
    where: difficulty_levelsWhereUniqueInput
    update: XOR<difficulty_levelsUpdateWithoutSubjectInput, difficulty_levelsUncheckedUpdateWithoutSubjectInput>
    create: XOR<difficulty_levelsCreateWithoutSubjectInput, difficulty_levelsUncheckedCreateWithoutSubjectInput>
  }

  export type difficulty_levelsUpdateWithWhereUniqueWithoutSubjectInput = {
    where: difficulty_levelsWhereUniqueInput
    data: XOR<difficulty_levelsUpdateWithoutSubjectInput, difficulty_levelsUncheckedUpdateWithoutSubjectInput>
  }

  export type difficulty_levelsUpdateManyWithWhereWithoutSubjectInput = {
    where: difficulty_levelsScalarWhereInput
    data: XOR<difficulty_levelsUpdateManyMutationInput, difficulty_levelsUncheckedUpdateManyWithoutSubjectInput>
  }

  export type difficulty_levelsScalarWhereInput = {
    AND?: difficulty_levelsScalarWhereInput | difficulty_levelsScalarWhereInput[]
    OR?: difficulty_levelsScalarWhereInput[]
    NOT?: difficulty_levelsScalarWhereInput | difficulty_levelsScalarWhereInput[]
    level_id?: IntFilter<"difficulty_levels"> | number
    level_name?: StringFilter<"difficulty_levels"> | string
    level_value?: IntFilter<"difficulty_levels"> | number
    subject_id?: IntFilter<"difficulty_levels"> | number
    purpose?: StringFilter<"difficulty_levels"> | string
    characteristics?: StringFilter<"difficulty_levels"> | string
    focus_area?: StringFilter<"difficulty_levels"> | string
    steps_required?: StringNullableFilter<"difficulty_levels"> | string | null
    created_at?: DateTimeNullableFilter<"difficulty_levels"> | Date | string | null
    active?: BoolNullableFilter<"difficulty_levels"> | boolean | null
  }

  export type questionsCreateWithoutSubtopicsInput = {
    question_id?: bigint | number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    active?: boolean | null
    users: usersCreateNestedOneWithoutQuestionsInput
    question_set_items?: question_set_itemsCreateNestedManyWithoutQuestionInput
  }

  export type questionsUncheckedCreateWithoutSubtopicsInput = {
    question_id?: bigint | number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    created_by: bigint | number
    active?: boolean | null
    question_set_items?: question_set_itemsUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutSubtopicsInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutSubtopicsInput, questionsUncheckedCreateWithoutSubtopicsInput>
  }

  export type questionsCreateManySubtopicsInputEnvelope = {
    data: questionsCreateManySubtopicsInput | questionsCreateManySubtopicsInput[]
    skipDuplicates?: boolean
  }

  export type topicsCreateWithoutSubtopicsInput = {
    topic_name: string
    description?: string | null
    subjects: subjectsCreateNestedOneWithoutTopicsInput
  }

  export type topicsUncheckedCreateWithoutSubtopicsInput = {
    topic_id?: number
    subject_id: number
    topic_name: string
    description?: string | null
  }

  export type topicsCreateOrConnectWithoutSubtopicsInput = {
    where: topicsWhereUniqueInput
    create: XOR<topicsCreateWithoutSubtopicsInput, topicsUncheckedCreateWithoutSubtopicsInput>
  }

  export type questionsUpsertWithWhereUniqueWithoutSubtopicsInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutSubtopicsInput, questionsUncheckedUpdateWithoutSubtopicsInput>
    create: XOR<questionsCreateWithoutSubtopicsInput, questionsUncheckedCreateWithoutSubtopicsInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutSubtopicsInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutSubtopicsInput, questionsUncheckedUpdateWithoutSubtopicsInput>
  }

  export type questionsUpdateManyWithWhereWithoutSubtopicsInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutSubtopicsInput>
  }

  export type questionsScalarWhereInput = {
    AND?: questionsScalarWhereInput | questionsScalarWhereInput[]
    OR?: questionsScalarWhereInput[]
    NOT?: questionsScalarWhereInput | questionsScalarWhereInput[]
    question_id?: BigIntFilter<"questions"> | bigint | number
    subtopic_id?: IntFilter<"questions"> | number
    question_text?: StringFilter<"questions"> | string
    question_text_plain?: StringFilter<"questions"> | string
    options?: StringFilter<"questions"> | string
    correct_answer?: StringFilter<"questions"> | string
    correct_answer_plain?: StringFilter<"questions"> | string
    solution?: StringFilter<"questions"> | string
    solution_plain?: StringFilter<"questions"> | string
    difficulty_level?: IntFilter<"questions"> | number
    created_at?: DateTimeNullableFilter<"questions"> | Date | string | null
    created_by?: BigIntFilter<"questions"> | bigint | number
    active?: BoolNullableFilter<"questions"> | boolean | null
  }

  export type topicsUpsertWithoutSubtopicsInput = {
    update: XOR<topicsUpdateWithoutSubtopicsInput, topicsUncheckedUpdateWithoutSubtopicsInput>
    create: XOR<topicsCreateWithoutSubtopicsInput, topicsUncheckedCreateWithoutSubtopicsInput>
    where?: topicsWhereInput
  }

  export type topicsUpdateToOneWithWhereWithoutSubtopicsInput = {
    where?: topicsWhereInput
    data: XOR<topicsUpdateWithoutSubtopicsInput, topicsUncheckedUpdateWithoutSubtopicsInput>
  }

  export type topicsUpdateWithoutSubtopicsInput = {
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: subjectsUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type topicsUncheckedUpdateWithoutSubtopicsInput = {
    topic_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_plansCreateWithoutTest_executionsInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutTest_executionsInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutTest_executionsInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutTest_executionsInput, test_plansUncheckedCreateWithoutTest_executionsInput>
  }

  export type usersCreateWithoutTest_executionsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutTest_executionsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutTest_executionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTest_executionsInput, usersUncheckedCreateWithoutTest_executionsInput>
  }

  export type test_plansUpsertWithoutTest_executionsInput = {
    update: XOR<test_plansUpdateWithoutTest_executionsInput, test_plansUncheckedUpdateWithoutTest_executionsInput>
    create: XOR<test_plansCreateWithoutTest_executionsInput, test_plansUncheckedCreateWithoutTest_executionsInput>
    where?: test_plansWhereInput
  }

  export type test_plansUpdateToOneWithWhereWithoutTest_executionsInput = {
    where?: test_plansWhereInput
    data: XOR<test_plansUpdateWithoutTest_executionsInput, test_plansUncheckedUpdateWithoutTest_executionsInput>
  }

  export type test_plansUpdateWithoutTest_executionsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutTest_executionsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type usersUpsertWithoutTest_executionsInput = {
    update: XOR<usersUpdateWithoutTest_executionsInput, usersUncheckedUpdateWithoutTest_executionsInput>
    create: XOR<usersCreateWithoutTest_executionsInput, usersUncheckedCreateWithoutTest_executionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTest_executionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTest_executionsInput, usersUncheckedUpdateWithoutTest_executionsInput>
  }

  export type usersUpdateWithoutTest_executionsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutTest_executionsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type test_plansCreateWithoutQuestion_set_linksInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutQuestion_set_linksInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutQuestion_set_linksInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutQuestion_set_linksInput, test_plansUncheckedCreateWithoutQuestion_set_linksInput>
  }

  export type question_setsCreateWithoutTest_plan_linksInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    creator: usersCreateNestedOneWithoutCreated_question_setsInput
    question_set_items?: question_set_itemsCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsUncheckedCreateWithoutTest_plan_linksInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_by: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    question_set_items?: question_set_itemsUncheckedCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsCreateOrConnectWithoutTest_plan_linksInput = {
    where: question_setsWhereUniqueInput
    create: XOR<question_setsCreateWithoutTest_plan_linksInput, question_setsUncheckedCreateWithoutTest_plan_linksInput>
  }

  export type test_plansUpsertWithoutQuestion_set_linksInput = {
    update: XOR<test_plansUpdateWithoutQuestion_set_linksInput, test_plansUncheckedUpdateWithoutQuestion_set_linksInput>
    create: XOR<test_plansCreateWithoutQuestion_set_linksInput, test_plansUncheckedCreateWithoutQuestion_set_linksInput>
    where?: test_plansWhereInput
  }

  export type test_plansUpdateToOneWithWhereWithoutQuestion_set_linksInput = {
    where?: test_plansWhereInput
    data: XOR<test_plansUpdateWithoutQuestion_set_linksInput, test_plansUncheckedUpdateWithoutQuestion_set_linksInput>
  }

  export type test_plansUpdateWithoutQuestion_set_linksInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutQuestion_set_linksInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type question_setsUpsertWithoutTest_plan_linksInput = {
    update: XOR<question_setsUpdateWithoutTest_plan_linksInput, question_setsUncheckedUpdateWithoutTest_plan_linksInput>
    create: XOR<question_setsCreateWithoutTest_plan_linksInput, question_setsUncheckedCreateWithoutTest_plan_linksInput>
    where?: question_setsWhereInput
  }

  export type question_setsUpdateToOneWithWhereWithoutTest_plan_linksInput = {
    where?: question_setsWhereInput
    data: XOR<question_setsUpdateWithoutTest_plan_linksInput, question_setsUncheckedUpdateWithoutTest_plan_linksInput>
  }

  export type question_setsUpdateWithoutTest_plan_linksInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: usersUpdateOneRequiredWithoutCreated_question_setsNestedInput
    question_set_items?: question_set_itemsUpdateManyWithoutQuestion_setNestedInput
  }

  export type question_setsUncheckedUpdateWithoutTest_plan_linksInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    question_set_items?: question_set_itemsUncheckedUpdateManyWithoutQuestion_setNestedInput
  }

  export type test_executionsCreateWithoutTest_plansInput = {
    execution_id?: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
    users: usersCreateNestedOneWithoutTest_executionsInput
  }

  export type test_executionsUncheckedCreateWithoutTest_plansInput = {
    execution_id?: bigint | number
    student_id: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
  }

  export type test_executionsCreateOrConnectWithoutTest_plansInput = {
    where: test_executionsWhereUniqueInput
    create: XOR<test_executionsCreateWithoutTest_plansInput, test_executionsUncheckedCreateWithoutTest_plansInput>
  }

  export type test_executionsCreateManyTest_plansInputEnvelope = {
    data: test_executionsCreateManyTest_plansInput | test_executionsCreateManyTest_plansInput[]
    skipDuplicates?: boolean
  }

  export type test_templatesCreateWithoutTest_plansInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_at?: Date | string | null
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    users: usersCreateNestedOneWithoutTest_templatesInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_templatesInput
  }

  export type test_templatesUncheckedCreateWithoutTest_plansInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_by: bigint | number
    created_at?: Date | string | null
    board_id: number
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
  }

  export type test_templatesCreateOrConnectWithoutTest_plansInput = {
    where: test_templatesWhereUniqueInput
    create: XOR<test_templatesCreateWithoutTest_plansInput, test_templatesUncheckedCreateWithoutTest_plansInput>
  }

  export type exam_boardsCreateWithoutTest_plansInput = {
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
    test_templates?: test_templatesCreateNestedManyWithoutExam_boardsInput
  }

  export type exam_boardsUncheckedCreateWithoutTest_plansInput = {
    board_id?: number
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutExam_boardsInput
  }

  export type exam_boardsCreateOrConnectWithoutTest_plansInput = {
    where: exam_boardsWhereUniqueInput
    create: XOR<exam_boardsCreateWithoutTest_plansInput, exam_boardsUncheckedCreateWithoutTest_plansInput>
  }

  export type usersCreateWithoutAssigned_test_plansInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutAssigned_test_plansInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutAssigned_test_plansInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAssigned_test_plansInput, usersUncheckedCreateWithoutAssigned_test_plansInput>
  }

  export type usersCreateWithoutPlanned_test_plansInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutPlanned_test_plansInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutPlanned_test_plansInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPlanned_test_plansInput, usersUncheckedCreateWithoutPlanned_test_plansInput>
  }

  export type study_groupsCreateWithoutTest_plansInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tutor: usersCreateNestedOneWithoutTutor_groupsInput
    students?: usersCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsCreateNestedManyWithoutGroupInput
  }

  export type study_groupsUncheckedCreateWithoutTest_plansInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    tutor_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students?: usersUncheckedCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersUncheckedCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutGroupInput
  }

  export type study_groupsCreateOrConnectWithoutTest_plansInput = {
    where: study_groupsWhereUniqueInput
    create: XOR<study_groupsCreateWithoutTest_plansInput, study_groupsUncheckedCreateWithoutTest_plansInput>
  }

  export type test_assignmentsCreateWithoutTest_planInput = {
    assignment_id?: bigint | number
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
    assigner: usersCreateNestedOneWithoutAssignments_createdInput
    group?: study_groupsCreateNestedOneWithoutAssignmentsInput
    student?: usersCreateNestedOneWithoutAssignments_receivedInput
  }

  export type test_assignmentsUncheckedCreateWithoutTest_planInput = {
    assignment_id?: bigint | number
    assigned_by: bigint | number
    group_id?: bigint | number | null
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsCreateOrConnectWithoutTest_planInput = {
    where: test_assignmentsWhereUniqueInput
    create: XOR<test_assignmentsCreateWithoutTest_planInput, test_assignmentsUncheckedCreateWithoutTest_planInput>
  }

  export type test_assignmentsCreateManyTest_planInputEnvelope = {
    data: test_assignmentsCreateManyTest_planInput | test_assignmentsCreateManyTest_planInput[]
    skipDuplicates?: boolean
  }

  export type test_plan_question_setsCreateWithoutTest_planInput = {
    link_id?: bigint | number
    sequence: number
    created_at?: Date | string
    question_set: question_setsCreateNestedOneWithoutTest_plan_linksInput
  }

  export type test_plan_question_setsUncheckedCreateWithoutTest_planInput = {
    link_id?: bigint | number
    set_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type test_plan_question_setsCreateOrConnectWithoutTest_planInput = {
    where: test_plan_question_setsWhereUniqueInput
    create: XOR<test_plan_question_setsCreateWithoutTest_planInput, test_plan_question_setsUncheckedCreateWithoutTest_planInput>
  }

  export type test_plan_question_setsCreateManyTest_planInputEnvelope = {
    data: test_plan_question_setsCreateManyTest_planInput | test_plan_question_setsCreateManyTest_planInput[]
    skipDuplicates?: boolean
  }

  export type test_executionsUpsertWithWhereUniqueWithoutTest_plansInput = {
    where: test_executionsWhereUniqueInput
    update: XOR<test_executionsUpdateWithoutTest_plansInput, test_executionsUncheckedUpdateWithoutTest_plansInput>
    create: XOR<test_executionsCreateWithoutTest_plansInput, test_executionsUncheckedCreateWithoutTest_plansInput>
  }

  export type test_executionsUpdateWithWhereUniqueWithoutTest_plansInput = {
    where: test_executionsWhereUniqueInput
    data: XOR<test_executionsUpdateWithoutTest_plansInput, test_executionsUncheckedUpdateWithoutTest_plansInput>
  }

  export type test_executionsUpdateManyWithWhereWithoutTest_plansInput = {
    where: test_executionsScalarWhereInput
    data: XOR<test_executionsUpdateManyMutationInput, test_executionsUncheckedUpdateManyWithoutTest_plansInput>
  }

  export type test_executionsScalarWhereInput = {
    AND?: test_executionsScalarWhereInput | test_executionsScalarWhereInput[]
    OR?: test_executionsScalarWhereInput[]
    NOT?: test_executionsScalarWhereInput | test_executionsScalarWhereInput[]
    execution_id?: BigIntFilter<"test_executions"> | bigint | number
    test_plan_id?: BigIntFilter<"test_executions"> | bigint | number
    student_id?: BigIntFilter<"test_executions"> | bigint | number
    status?: Enumtest_executions_statusFilter<"test_executions"> | $Enums.test_executions_status
    started_at?: DateTimeNullableFilter<"test_executions"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"test_executions"> | Date | string | null
    test_data?: StringFilter<"test_executions"> | string
    score?: IntNullableFilter<"test_executions"> | number | null
  }

  export type test_templatesUpsertWithoutTest_plansInput = {
    update: XOR<test_templatesUpdateWithoutTest_plansInput, test_templatesUncheckedUpdateWithoutTest_plansInput>
    create: XOR<test_templatesCreateWithoutTest_plansInput, test_templatesUncheckedCreateWithoutTest_plansInput>
    where?: test_templatesWhereInput
  }

  export type test_templatesUpdateToOneWithWhereWithoutTest_plansInput = {
    where?: test_templatesWhereInput
    data: XOR<test_templatesUpdateWithoutTest_plansInput, test_templatesUncheckedUpdateWithoutTest_plansInput>
  }

  export type test_templatesUpdateWithoutTest_plansInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutTest_templatesNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_templatesNestedInput
  }

  export type test_templatesUncheckedUpdateWithoutTest_plansInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type exam_boardsUpsertWithoutTest_plansInput = {
    update: XOR<exam_boardsUpdateWithoutTest_plansInput, exam_boardsUncheckedUpdateWithoutTest_plansInput>
    create: XOR<exam_boardsCreateWithoutTest_plansInput, exam_boardsUncheckedCreateWithoutTest_plansInput>
    where?: exam_boardsWhereInput
  }

  export type exam_boardsUpdateToOneWithWhereWithoutTest_plansInput = {
    where?: exam_boardsWhereInput
    data: XOR<exam_boardsUpdateWithoutTest_plansInput, exam_boardsUncheckedUpdateWithoutTest_plansInput>
  }

  export type exam_boardsUpdateWithoutTest_plansInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
    test_templates?: test_templatesUpdateManyWithoutExam_boardsNestedInput
  }

  export type exam_boardsUncheckedUpdateWithoutTest_plansInput = {
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
    test_templates?: test_templatesUncheckedUpdateManyWithoutExam_boardsNestedInput
  }

  export type usersUpsertWithoutAssigned_test_plansInput = {
    update: XOR<usersUpdateWithoutAssigned_test_plansInput, usersUncheckedUpdateWithoutAssigned_test_plansInput>
    create: XOR<usersCreateWithoutAssigned_test_plansInput, usersUncheckedCreateWithoutAssigned_test_plansInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAssigned_test_plansInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAssigned_test_plansInput, usersUncheckedUpdateWithoutAssigned_test_plansInput>
  }

  export type usersUpdateWithoutAssigned_test_plansInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutAssigned_test_plansInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type usersUpsertWithoutPlanned_test_plansInput = {
    update: XOR<usersUpdateWithoutPlanned_test_plansInput, usersUncheckedUpdateWithoutPlanned_test_plansInput>
    create: XOR<usersCreateWithoutPlanned_test_plansInput, usersUncheckedCreateWithoutPlanned_test_plansInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPlanned_test_plansInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPlanned_test_plansInput, usersUncheckedUpdateWithoutPlanned_test_plansInput>
  }

  export type usersUpdateWithoutPlanned_test_plansInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutPlanned_test_plansInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type study_groupsUpsertWithWhereUniqueWithoutTest_plansInput = {
    where: study_groupsWhereUniqueInput
    update: XOR<study_groupsUpdateWithoutTest_plansInput, study_groupsUncheckedUpdateWithoutTest_plansInput>
    create: XOR<study_groupsCreateWithoutTest_plansInput, study_groupsUncheckedCreateWithoutTest_plansInput>
  }

  export type study_groupsUpdateWithWhereUniqueWithoutTest_plansInput = {
    where: study_groupsWhereUniqueInput
    data: XOR<study_groupsUpdateWithoutTest_plansInput, study_groupsUncheckedUpdateWithoutTest_plansInput>
  }

  export type study_groupsUpdateManyWithWhereWithoutTest_plansInput = {
    where: study_groupsScalarWhereInput
    data: XOR<study_groupsUpdateManyMutationInput, study_groupsUncheckedUpdateManyWithoutTest_plansInput>
  }

  export type study_groupsScalarWhereInput = {
    AND?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
    OR?: study_groupsScalarWhereInput[]
    NOT?: study_groupsScalarWhereInput | study_groupsScalarWhereInput[]
    group_id?: BigIntFilter<"study_groups"> | bigint | number
    group_name?: StringFilter<"study_groups"> | string
    description?: StringNullableFilter<"study_groups"> | string | null
    tutor_id?: BigIntFilter<"study_groups"> | bigint | number
    created_at?: DateTimeNullableFilter<"study_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"study_groups"> | Date | string | null
  }

  export type test_assignmentsUpsertWithWhereUniqueWithoutTest_planInput = {
    where: test_assignmentsWhereUniqueInput
    update: XOR<test_assignmentsUpdateWithoutTest_planInput, test_assignmentsUncheckedUpdateWithoutTest_planInput>
    create: XOR<test_assignmentsCreateWithoutTest_planInput, test_assignmentsUncheckedCreateWithoutTest_planInput>
  }

  export type test_assignmentsUpdateWithWhereUniqueWithoutTest_planInput = {
    where: test_assignmentsWhereUniqueInput
    data: XOR<test_assignmentsUpdateWithoutTest_planInput, test_assignmentsUncheckedUpdateWithoutTest_planInput>
  }

  export type test_assignmentsUpdateManyWithWhereWithoutTest_planInput = {
    where: test_assignmentsScalarWhereInput
    data: XOR<test_assignmentsUpdateManyMutationInput, test_assignmentsUncheckedUpdateManyWithoutTest_planInput>
  }

  export type test_assignmentsScalarWhereInput = {
    AND?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
    OR?: test_assignmentsScalarWhereInput[]
    NOT?: test_assignmentsScalarWhereInput | test_assignmentsScalarWhereInput[]
    assignment_id?: BigIntFilter<"test_assignments"> | bigint | number
    test_plan_id?: BigIntFilter<"test_assignments"> | bigint | number
    assigned_by?: BigIntFilter<"test_assignments"> | bigint | number
    group_id?: BigIntNullableFilter<"test_assignments"> | bigint | number | null
    student_id?: BigIntNullableFilter<"test_assignments"> | bigint | number | null
    due_date?: DateTimeFilter<"test_assignments"> | Date | string
    status?: EnumTestAssignmentStatusFilter<"test_assignments"> | $Enums.TestAssignmentStatus
    created_at?: DateTimeNullableFilter<"test_assignments"> | Date | string | null
  }

  export type test_plan_question_setsUpsertWithWhereUniqueWithoutTest_planInput = {
    where: test_plan_question_setsWhereUniqueInput
    update: XOR<test_plan_question_setsUpdateWithoutTest_planInput, test_plan_question_setsUncheckedUpdateWithoutTest_planInput>
    create: XOR<test_plan_question_setsCreateWithoutTest_planInput, test_plan_question_setsUncheckedCreateWithoutTest_planInput>
  }

  export type test_plan_question_setsUpdateWithWhereUniqueWithoutTest_planInput = {
    where: test_plan_question_setsWhereUniqueInput
    data: XOR<test_plan_question_setsUpdateWithoutTest_planInput, test_plan_question_setsUncheckedUpdateWithoutTest_planInput>
  }

  export type test_plan_question_setsUpdateManyWithWhereWithoutTest_planInput = {
    where: test_plan_question_setsScalarWhereInput
    data: XOR<test_plan_question_setsUpdateManyMutationInput, test_plan_question_setsUncheckedUpdateManyWithoutTest_planInput>
  }

  export type test_plansCreateWithoutTest_templatesInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutTest_templatesInput = {
    test_plan_id?: bigint | number
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutTest_templatesInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutTest_templatesInput, test_plansUncheckedCreateWithoutTest_templatesInput>
  }

  export type test_plansCreateManyTest_templatesInputEnvelope = {
    data: test_plansCreateManyTest_templatesInput | test_plansCreateManyTest_templatesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTest_templatesInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutTest_templatesInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutTest_templatesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTest_templatesInput, usersUncheckedCreateWithoutTest_templatesInput>
  }

  export type exam_boardsCreateWithoutTest_templatesInput = {
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
    test_plans?: test_plansCreateNestedManyWithoutExam_boardsInput
  }

  export type exam_boardsUncheckedCreateWithoutTest_templatesInput = {
    board_id?: number
    board_name: string
    description?: string | null
    input_type: $Enums.exam_boards_input_type
    test_plans?: test_plansUncheckedCreateNestedManyWithoutExam_boardsInput
  }

  export type exam_boardsCreateOrConnectWithoutTest_templatesInput = {
    where: exam_boardsWhereUniqueInput
    create: XOR<exam_boardsCreateWithoutTest_templatesInput, exam_boardsUncheckedCreateWithoutTest_templatesInput>
  }

  export type test_plansUpsertWithWhereUniqueWithoutTest_templatesInput = {
    where: test_plansWhereUniqueInput
    update: XOR<test_plansUpdateWithoutTest_templatesInput, test_plansUncheckedUpdateWithoutTest_templatesInput>
    create: XOR<test_plansCreateWithoutTest_templatesInput, test_plansUncheckedCreateWithoutTest_templatesInput>
  }

  export type test_plansUpdateWithWhereUniqueWithoutTest_templatesInput = {
    where: test_plansWhereUniqueInput
    data: XOR<test_plansUpdateWithoutTest_templatesInput, test_plansUncheckedUpdateWithoutTest_templatesInput>
  }

  export type test_plansUpdateManyWithWhereWithoutTest_templatesInput = {
    where: test_plansScalarWhereInput
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyWithoutTest_templatesInput>
  }

  export type usersUpsertWithoutTest_templatesInput = {
    update: XOR<usersUpdateWithoutTest_templatesInput, usersUncheckedUpdateWithoutTest_templatesInput>
    create: XOR<usersCreateWithoutTest_templatesInput, usersUncheckedCreateWithoutTest_templatesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTest_templatesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTest_templatesInput, usersUncheckedUpdateWithoutTest_templatesInput>
  }

  export type usersUpdateWithoutTest_templatesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutTest_templatesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type exam_boardsUpsertWithoutTest_templatesInput = {
    update: XOR<exam_boardsUpdateWithoutTest_templatesInput, exam_boardsUncheckedUpdateWithoutTest_templatesInput>
    create: XOR<exam_boardsCreateWithoutTest_templatesInput, exam_boardsUncheckedCreateWithoutTest_templatesInput>
    where?: exam_boardsWhereInput
  }

  export type exam_boardsUpdateToOneWithWhereWithoutTest_templatesInput = {
    where?: exam_boardsWhereInput
    data: XOR<exam_boardsUpdateWithoutTest_templatesInput, exam_boardsUncheckedUpdateWithoutTest_templatesInput>
  }

  export type exam_boardsUpdateWithoutTest_templatesInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
    test_plans?: test_plansUpdateManyWithoutExam_boardsNestedInput
  }

  export type exam_boardsUncheckedUpdateWithoutTest_templatesInput = {
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    input_type?: Enumexam_boards_input_typeFieldUpdateOperationsInput | $Enums.exam_boards_input_type
    test_plans?: test_plansUncheckedUpdateManyWithoutExam_boardsNestedInput
  }

  export type subtopicsCreateWithoutTopicsInput = {
    subtopic_name: string
    description?: string | null
    questions?: questionsCreateNestedManyWithoutSubtopicsInput
  }

  export type subtopicsUncheckedCreateWithoutTopicsInput = {
    subtopic_id?: number
    subtopic_name: string
    description?: string | null
    questions?: questionsUncheckedCreateNestedManyWithoutSubtopicsInput
  }

  export type subtopicsCreateOrConnectWithoutTopicsInput = {
    where: subtopicsWhereUniqueInput
    create: XOR<subtopicsCreateWithoutTopicsInput, subtopicsUncheckedCreateWithoutTopicsInput>
  }

  export type subtopicsCreateManyTopicsInputEnvelope = {
    data: subtopicsCreateManyTopicsInput | subtopicsCreateManyTopicsInput[]
    skipDuplicates?: boolean
  }

  export type subjectsCreateWithoutTopicsInput = {
    subject_name: string
    description?: string | null
    subject_mastery?: subject_masteryCreateNestedManyWithoutSubjectsInput
    difficulty_levels?: difficulty_levelsCreateNestedManyWithoutSubjectInput
  }

  export type subjectsUncheckedCreateWithoutTopicsInput = {
    subject_id?: number
    subject_name: string
    description?: string | null
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutSubjectsInput
    difficulty_levels?: difficulty_levelsUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectsCreateOrConnectWithoutTopicsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutTopicsInput, subjectsUncheckedCreateWithoutTopicsInput>
  }

  export type subtopicsUpsertWithWhereUniqueWithoutTopicsInput = {
    where: subtopicsWhereUniqueInput
    update: XOR<subtopicsUpdateWithoutTopicsInput, subtopicsUncheckedUpdateWithoutTopicsInput>
    create: XOR<subtopicsCreateWithoutTopicsInput, subtopicsUncheckedCreateWithoutTopicsInput>
  }

  export type subtopicsUpdateWithWhereUniqueWithoutTopicsInput = {
    where: subtopicsWhereUniqueInput
    data: XOR<subtopicsUpdateWithoutTopicsInput, subtopicsUncheckedUpdateWithoutTopicsInput>
  }

  export type subtopicsUpdateManyWithWhereWithoutTopicsInput = {
    where: subtopicsScalarWhereInput
    data: XOR<subtopicsUpdateManyMutationInput, subtopicsUncheckedUpdateManyWithoutTopicsInput>
  }

  export type subtopicsScalarWhereInput = {
    AND?: subtopicsScalarWhereInput | subtopicsScalarWhereInput[]
    OR?: subtopicsScalarWhereInput[]
    NOT?: subtopicsScalarWhereInput | subtopicsScalarWhereInput[]
    subtopic_id?: IntFilter<"subtopics"> | number
    topic_id?: IntFilter<"subtopics"> | number
    subtopic_name?: StringFilter<"subtopics"> | string
    description?: StringNullableFilter<"subtopics"> | string | null
  }

  export type subjectsUpsertWithoutTopicsInput = {
    update: XOR<subjectsUpdateWithoutTopicsInput, subjectsUncheckedUpdateWithoutTopicsInput>
    create: XOR<subjectsCreateWithoutTopicsInput, subjectsUncheckedCreateWithoutTopicsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutTopicsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutTopicsInput, subjectsUncheckedUpdateWithoutTopicsInput>
  }

  export type subjectsUpdateWithoutTopicsInput = {
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject_mastery?: subject_masteryUpdateManyWithoutSubjectsNestedInput
    difficulty_levels?: difficulty_levelsUpdateManyWithoutSubjectNestedInput
  }

  export type subjectsUncheckedUpdateWithoutTopicsInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutSubjectsNestedInput
    difficulty_levels?: difficulty_levelsUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type usersCreateWithoutUser_rolesInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutUser_rolesInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutUser_rolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
  }

  export type rolesCreateWithoutUser_rolesInput = {
    role_name: string
    description?: string | null
  }

  export type rolesUncheckedCreateWithoutUser_rolesInput = {
    role_id?: number
    role_name: string
    description?: string | null
  }

  export type rolesCreateOrConnectWithoutUser_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
  }

  export type usersUpsertWithoutUser_rolesInput = {
    update: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type usersUpdateWithoutUser_rolesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_rolesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type rolesUpsertWithoutUser_rolesInput = {
    update: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type rolesUpdateWithoutUser_rolesInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesUncheckedUpdateWithoutUser_rolesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionsCreateWithoutUsersInput = {
    question_id?: bigint | number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    active?: boolean | null
    subtopics: subtopicsCreateNestedOneWithoutQuestionsInput
    question_set_items?: question_set_itemsCreateNestedManyWithoutQuestionInput
  }

  export type questionsUncheckedCreateWithoutUsersInput = {
    question_id?: bigint | number
    subtopic_id: number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    active?: boolean | null
    question_set_items?: question_set_itemsUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutUsersInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutUsersInput, questionsUncheckedCreateWithoutUsersInput>
  }

  export type questionsCreateManyUsersInputEnvelope = {
    data: questionsCreateManyUsersInput | questionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type question_setsCreateWithoutCreatorInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    question_set_items?: question_set_itemsCreateNestedManyWithoutQuestion_setInput
    test_plan_links?: test_plan_question_setsCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsUncheckedCreateWithoutCreatorInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
    question_set_items?: question_set_itemsUncheckedCreateNestedManyWithoutQuestion_setInput
    test_plan_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutQuestion_setInput
  }

  export type question_setsCreateOrConnectWithoutCreatorInput = {
    where: question_setsWhereUniqueInput
    create: XOR<question_setsCreateWithoutCreatorInput, question_setsUncheckedCreateWithoutCreatorInput>
  }

  export type question_setsCreateManyCreatorInputEnvelope = {
    data: question_setsCreateManyCreatorInput | question_setsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type test_executionsCreateWithoutUsersInput = {
    execution_id?: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
    test_plans: test_plansCreateNestedOneWithoutTest_executionsInput
  }

  export type test_executionsUncheckedCreateWithoutUsersInput = {
    execution_id?: bigint | number
    test_plan_id: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
  }

  export type test_executionsCreateOrConnectWithoutUsersInput = {
    where: test_executionsWhereUniqueInput
    create: XOR<test_executionsCreateWithoutUsersInput, test_executionsUncheckedCreateWithoutUsersInput>
  }

  export type test_executionsCreateManyUsersInputEnvelope = {
    data: test_executionsCreateManyUsersInput | test_executionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type test_plansCreateWithoutStudentInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutStudentInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutStudentInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutStudentInput, test_plansUncheckedCreateWithoutStudentInput>
  }

  export type test_plansCreateManyStudentInputEnvelope = {
    data: test_plansCreateManyStudentInput | test_plansCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type test_plansCreateWithoutPlannerInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutPlannerInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutPlannerInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutPlannerInput, test_plansUncheckedCreateWithoutPlannerInput>
  }

  export type test_plansCreateManyPlannerInputEnvelope = {
    data: test_plansCreateManyPlannerInput | test_plansCreateManyPlannerInput[]
    skipDuplicates?: boolean
  }

  export type test_templatesCreateWithoutUsersInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_at?: Date | string | null
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    test_plans?: test_plansCreateNestedManyWithoutTest_templatesInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_templatesInput
  }

  export type test_templatesUncheckedCreateWithoutUsersInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_at?: Date | string | null
    board_id: number
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
    test_plans?: test_plansUncheckedCreateNestedManyWithoutTest_templatesInput
  }

  export type test_templatesCreateOrConnectWithoutUsersInput = {
    where: test_templatesWhereUniqueInput
    create: XOR<test_templatesCreateWithoutUsersInput, test_templatesUncheckedCreateWithoutUsersInput>
  }

  export type test_templatesCreateManyUsersInputEnvelope = {
    data: test_templatesCreateManyUsersInput | test_templatesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesCreateWithoutUsersInput = {
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutUsersInput = {
    role_id: number
  }

  export type user_rolesCreateOrConnectWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesCreateManyUsersInputEnvelope = {
    data: user_rolesCreateManyUsersInput | user_rolesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type student_achievementsCreateWithoutUserInput = {
    unlocked_at?: Date | string | null
    progress?: number
    achievements: achievementsCreateNestedOneWithoutStudent_achievementsInput
  }

  export type student_achievementsUncheckedCreateWithoutUserInput = {
    achievement_id: bigint | number
    unlocked_at?: Date | string | null
    progress?: number
  }

  export type student_achievementsCreateOrConnectWithoutUserInput = {
    where: student_achievementsWhereUniqueInput
    create: XOR<student_achievementsCreateWithoutUserInput, student_achievementsUncheckedCreateWithoutUserInput>
  }

  export type student_achievementsCreateManyUserInputEnvelope = {
    data: student_achievementsCreateManyUserInput | student_achievementsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type study_groupsCreateWithoutTutorInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students?: usersCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsCreateNestedManyWithoutGroupInput
    test_plans?: test_plansCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsUncheckedCreateWithoutTutorInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students?: usersUncheckedCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersUncheckedCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutGroupInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsCreateOrConnectWithoutTutorInput = {
    where: study_groupsWhereUniqueInput
    create: XOR<study_groupsCreateWithoutTutorInput, study_groupsUncheckedCreateWithoutTutorInput>
  }

  export type study_groupsCreateManyTutorInputEnvelope = {
    data: study_groupsCreateManyTutorInput | study_groupsCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type study_groupsCreateWithoutStudentsInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tutor: usersCreateNestedOneWithoutTutor_groupsInput
    members?: group_membersCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsCreateNestedManyWithoutGroupInput
    test_plans?: test_plansCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsUncheckedCreateWithoutStudentsInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    tutor_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    members?: group_membersUncheckedCreateNestedManyWithoutGroupInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutGroupInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsCreateOrConnectWithoutStudentsInput = {
    where: study_groupsWhereUniqueInput
    create: XOR<study_groupsCreateWithoutStudentsInput, study_groupsUncheckedCreateWithoutStudentsInput>
  }

  export type group_membersCreateWithoutStudentInput = {
    joined_at?: Date | string | null
    group: study_groupsCreateNestedOneWithoutMembersInput
  }

  export type group_membersUncheckedCreateWithoutStudentInput = {
    group_id: bigint | number
    joined_at?: Date | string | null
  }

  export type group_membersCreateOrConnectWithoutStudentInput = {
    where: group_membersWhereUniqueInput
    create: XOR<group_membersCreateWithoutStudentInput, group_membersUncheckedCreateWithoutStudentInput>
  }

  export type group_membersCreateManyStudentInputEnvelope = {
    data: group_membersCreateManyStudentInput | group_membersCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type subject_masteryCreateWithoutUserInput = {
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
    subjects: subjectsCreateNestedOneWithoutSubject_masteryInput
  }

  export type subject_masteryUncheckedCreateWithoutUserInput = {
    subject_id: number
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
  }

  export type subject_masteryCreateOrConnectWithoutUserInput = {
    where: subject_masteryWhereUniqueInput
    create: XOR<subject_masteryCreateWithoutUserInput, subject_masteryUncheckedCreateWithoutUserInput>
  }

  export type subject_masteryCreateManyUserInputEnvelope = {
    data: subject_masteryCreateManyUserInput | subject_masteryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type student_progressCreateWithoutUserInput = {
    level?: number
    current_xp?: number
    next_level_xp?: number
    streak_days?: number
    last_activity_date?: Date | string | null
    total_points?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_progressUncheckedCreateWithoutUserInput = {
    level?: number
    current_xp?: number
    next_level_xp?: number
    streak_days?: number
    last_activity_date?: Date | string | null
    total_points?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_progressCreateOrConnectWithoutUserInput = {
    where: student_progressWhereUniqueInput
    create: XOR<student_progressCreateWithoutUserInput, student_progressUncheckedCreateWithoutUserInput>
  }

  export type activity_logCreateWithoutUserInput = {
    activity_id?: bigint | number
    activity_type: string
    xp_earned?: number
    details?: string | null
    created_at?: Date | string | null
  }

  export type activity_logUncheckedCreateWithoutUserInput = {
    activity_id?: bigint | number
    activity_type: string
    xp_earned?: number
    details?: string | null
    created_at?: Date | string | null
  }

  export type activity_logCreateOrConnectWithoutUserInput = {
    where: activity_logWhereUniqueInput
    create: XOR<activity_logCreateWithoutUserInput, activity_logUncheckedCreateWithoutUserInput>
  }

  export type activity_logCreateManyUserInputEnvelope = {
    data: activity_logCreateManyUserInput | activity_logCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type student_rewardsCreateWithoutUserInput = {
    purchased_at?: Date | string | null
    rewards: rewardsCreateNestedOneWithoutStudent_rewardsInput
  }

  export type student_rewardsUncheckedCreateWithoutUserInput = {
    reward_id: bigint | number
    purchased_at?: Date | string | null
  }

  export type student_rewardsCreateOrConnectWithoutUserInput = {
    where: student_rewardsWhereUniqueInput
    create: XOR<student_rewardsCreateWithoutUserInput, student_rewardsUncheckedCreateWithoutUserInput>
  }

  export type student_rewardsCreateManyUserInputEnvelope = {
    data: student_rewardsCreateManyUserInput | student_rewardsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type student_guardiansCreateWithoutGuardianInput = {
    relationship_id?: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
    student: usersCreateNestedOneWithoutStudent_relationshipsInput
  }

  export type student_guardiansUncheckedCreateWithoutGuardianInput = {
    relationship_id?: bigint | number
    student_id: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_guardiansCreateOrConnectWithoutGuardianInput = {
    where: student_guardiansWhereUniqueInput
    create: XOR<student_guardiansCreateWithoutGuardianInput, student_guardiansUncheckedCreateWithoutGuardianInput>
  }

  export type student_guardiansCreateManyGuardianInputEnvelope = {
    data: student_guardiansCreateManyGuardianInput | student_guardiansCreateManyGuardianInput[]
    skipDuplicates?: boolean
  }

  export type student_guardiansCreateWithoutStudentInput = {
    relationship_id?: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
    guardian: usersCreateNestedOneWithoutGuardian_relationshipsInput
  }

  export type student_guardiansUncheckedCreateWithoutStudentInput = {
    relationship_id?: bigint | number
    guardian_id: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_guardiansCreateOrConnectWithoutStudentInput = {
    where: student_guardiansWhereUniqueInput
    create: XOR<student_guardiansCreateWithoutStudentInput, student_guardiansUncheckedCreateWithoutStudentInput>
  }

  export type student_guardiansCreateManyStudentInputEnvelope = {
    data: student_guardiansCreateManyStudentInput | student_guardiansCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type test_assignmentsCreateWithoutAssignerInput = {
    assignment_id?: bigint | number
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
    test_plan: test_plansCreateNestedOneWithoutAssignmentsInput
    group?: study_groupsCreateNestedOneWithoutAssignmentsInput
    student?: usersCreateNestedOneWithoutAssignments_receivedInput
  }

  export type test_assignmentsUncheckedCreateWithoutAssignerInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    group_id?: bigint | number | null
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsCreateOrConnectWithoutAssignerInput = {
    where: test_assignmentsWhereUniqueInput
    create: XOR<test_assignmentsCreateWithoutAssignerInput, test_assignmentsUncheckedCreateWithoutAssignerInput>
  }

  export type test_assignmentsCreateManyAssignerInputEnvelope = {
    data: test_assignmentsCreateManyAssignerInput | test_assignmentsCreateManyAssignerInput[]
    skipDuplicates?: boolean
  }

  export type test_assignmentsCreateWithoutStudentInput = {
    assignment_id?: bigint | number
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
    test_plan: test_plansCreateNestedOneWithoutAssignmentsInput
    assigner: usersCreateNestedOneWithoutAssignments_createdInput
    group?: study_groupsCreateNestedOneWithoutAssignmentsInput
  }

  export type test_assignmentsUncheckedCreateWithoutStudentInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    assigned_by: bigint | number
    group_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsCreateOrConnectWithoutStudentInput = {
    where: test_assignmentsWhereUniqueInput
    create: XOR<test_assignmentsCreateWithoutStudentInput, test_assignmentsUncheckedCreateWithoutStudentInput>
  }

  export type test_assignmentsCreateManyStudentInputEnvelope = {
    data: test_assignmentsCreateManyStudentInput | test_assignmentsCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type questionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutUsersInput, questionsUncheckedUpdateWithoutUsersInput>
    create: XOR<questionsCreateWithoutUsersInput, questionsUncheckedCreateWithoutUsersInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutUsersInput, questionsUncheckedUpdateWithoutUsersInput>
  }

  export type questionsUpdateManyWithWhereWithoutUsersInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type question_setsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: question_setsWhereUniqueInput
    update: XOR<question_setsUpdateWithoutCreatorInput, question_setsUncheckedUpdateWithoutCreatorInput>
    create: XOR<question_setsCreateWithoutCreatorInput, question_setsUncheckedCreateWithoutCreatorInput>
  }

  export type question_setsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: question_setsWhereUniqueInput
    data: XOR<question_setsUpdateWithoutCreatorInput, question_setsUncheckedUpdateWithoutCreatorInput>
  }

  export type question_setsUpdateManyWithWhereWithoutCreatorInput = {
    where: question_setsScalarWhereInput
    data: XOR<question_setsUpdateManyMutationInput, question_setsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type question_setsScalarWhereInput = {
    AND?: question_setsScalarWhereInput | question_setsScalarWhereInput[]
    OR?: question_setsScalarWhereInput[]
    NOT?: question_setsScalarWhereInput | question_setsScalarWhereInput[]
    set_id?: BigIntFilter<"question_sets"> | bigint | number
    name?: StringFilter<"question_sets"> | string
    description?: StringNullableFilter<"question_sets"> | string | null
    created_by?: BigIntFilter<"question_sets"> | bigint | number
    created_at?: DateTimeFilter<"question_sets"> | Date | string
    updated_at?: DateTimeFilter<"question_sets"> | Date | string
    active?: BoolFilter<"question_sets"> | boolean
    metadata?: StringNullableFilter<"question_sets"> | string | null
  }

  export type test_executionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: test_executionsWhereUniqueInput
    update: XOR<test_executionsUpdateWithoutUsersInput, test_executionsUncheckedUpdateWithoutUsersInput>
    create: XOR<test_executionsCreateWithoutUsersInput, test_executionsUncheckedCreateWithoutUsersInput>
  }

  export type test_executionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: test_executionsWhereUniqueInput
    data: XOR<test_executionsUpdateWithoutUsersInput, test_executionsUncheckedUpdateWithoutUsersInput>
  }

  export type test_executionsUpdateManyWithWhereWithoutUsersInput = {
    where: test_executionsScalarWhereInput
    data: XOR<test_executionsUpdateManyMutationInput, test_executionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type test_plansUpsertWithWhereUniqueWithoutStudentInput = {
    where: test_plansWhereUniqueInput
    update: XOR<test_plansUpdateWithoutStudentInput, test_plansUncheckedUpdateWithoutStudentInput>
    create: XOR<test_plansCreateWithoutStudentInput, test_plansUncheckedCreateWithoutStudentInput>
  }

  export type test_plansUpdateWithWhereUniqueWithoutStudentInput = {
    where: test_plansWhereUniqueInput
    data: XOR<test_plansUpdateWithoutStudentInput, test_plansUncheckedUpdateWithoutStudentInput>
  }

  export type test_plansUpdateManyWithWhereWithoutStudentInput = {
    where: test_plansScalarWhereInput
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyWithoutStudentInput>
  }

  export type test_plansUpsertWithWhereUniqueWithoutPlannerInput = {
    where: test_plansWhereUniqueInput
    update: XOR<test_plansUpdateWithoutPlannerInput, test_plansUncheckedUpdateWithoutPlannerInput>
    create: XOR<test_plansCreateWithoutPlannerInput, test_plansUncheckedCreateWithoutPlannerInput>
  }

  export type test_plansUpdateWithWhereUniqueWithoutPlannerInput = {
    where: test_plansWhereUniqueInput
    data: XOR<test_plansUpdateWithoutPlannerInput, test_plansUncheckedUpdateWithoutPlannerInput>
  }

  export type test_plansUpdateManyWithWhereWithoutPlannerInput = {
    where: test_plansScalarWhereInput
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyWithoutPlannerInput>
  }

  export type test_templatesUpsertWithWhereUniqueWithoutUsersInput = {
    where: test_templatesWhereUniqueInput
    update: XOR<test_templatesUpdateWithoutUsersInput, test_templatesUncheckedUpdateWithoutUsersInput>
    create: XOR<test_templatesCreateWithoutUsersInput, test_templatesUncheckedCreateWithoutUsersInput>
  }

  export type test_templatesUpdateWithWhereUniqueWithoutUsersInput = {
    where: test_templatesWhereUniqueInput
    data: XOR<test_templatesUpdateWithoutUsersInput, test_templatesUncheckedUpdateWithoutUsersInput>
  }

  export type test_templatesUpdateManyWithWhereWithoutUsersInput = {
    where: test_templatesScalarWhereInput
    data: XOR<test_templatesUpdateManyMutationInput, test_templatesUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_rolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutUsersInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type student_achievementsUpsertWithWhereUniqueWithoutUserInput = {
    where: student_achievementsWhereUniqueInput
    update: XOR<student_achievementsUpdateWithoutUserInput, student_achievementsUncheckedUpdateWithoutUserInput>
    create: XOR<student_achievementsCreateWithoutUserInput, student_achievementsUncheckedCreateWithoutUserInput>
  }

  export type student_achievementsUpdateWithWhereUniqueWithoutUserInput = {
    where: student_achievementsWhereUniqueInput
    data: XOR<student_achievementsUpdateWithoutUserInput, student_achievementsUncheckedUpdateWithoutUserInput>
  }

  export type student_achievementsUpdateManyWithWhereWithoutUserInput = {
    where: student_achievementsScalarWhereInput
    data: XOR<student_achievementsUpdateManyMutationInput, student_achievementsUncheckedUpdateManyWithoutUserInput>
  }

  export type student_achievementsScalarWhereInput = {
    AND?: student_achievementsScalarWhereInput | student_achievementsScalarWhereInput[]
    OR?: student_achievementsScalarWhereInput[]
    NOT?: student_achievementsScalarWhereInput | student_achievementsScalarWhereInput[]
    user_id?: BigIntFilter<"student_achievements"> | bigint | number
    achievement_id?: BigIntFilter<"student_achievements"> | bigint | number
    unlocked_at?: DateTimeNullableFilter<"student_achievements"> | Date | string | null
    progress?: IntFilter<"student_achievements"> | number
  }

  export type study_groupsUpsertWithWhereUniqueWithoutTutorInput = {
    where: study_groupsWhereUniqueInput
    update: XOR<study_groupsUpdateWithoutTutorInput, study_groupsUncheckedUpdateWithoutTutorInput>
    create: XOR<study_groupsCreateWithoutTutorInput, study_groupsUncheckedCreateWithoutTutorInput>
  }

  export type study_groupsUpdateWithWhereUniqueWithoutTutorInput = {
    where: study_groupsWhereUniqueInput
    data: XOR<study_groupsUpdateWithoutTutorInput, study_groupsUncheckedUpdateWithoutTutorInput>
  }

  export type study_groupsUpdateManyWithWhereWithoutTutorInput = {
    where: study_groupsScalarWhereInput
    data: XOR<study_groupsUpdateManyMutationInput, study_groupsUncheckedUpdateManyWithoutTutorInput>
  }

  export type study_groupsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: study_groupsWhereUniqueInput
    update: XOR<study_groupsUpdateWithoutStudentsInput, study_groupsUncheckedUpdateWithoutStudentsInput>
    create: XOR<study_groupsCreateWithoutStudentsInput, study_groupsUncheckedCreateWithoutStudentsInput>
  }

  export type study_groupsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: study_groupsWhereUniqueInput
    data: XOR<study_groupsUpdateWithoutStudentsInput, study_groupsUncheckedUpdateWithoutStudentsInput>
  }

  export type study_groupsUpdateManyWithWhereWithoutStudentsInput = {
    where: study_groupsScalarWhereInput
    data: XOR<study_groupsUpdateManyMutationInput, study_groupsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type group_membersUpsertWithWhereUniqueWithoutStudentInput = {
    where: group_membersWhereUniqueInput
    update: XOR<group_membersUpdateWithoutStudentInput, group_membersUncheckedUpdateWithoutStudentInput>
    create: XOR<group_membersCreateWithoutStudentInput, group_membersUncheckedCreateWithoutStudentInput>
  }

  export type group_membersUpdateWithWhereUniqueWithoutStudentInput = {
    where: group_membersWhereUniqueInput
    data: XOR<group_membersUpdateWithoutStudentInput, group_membersUncheckedUpdateWithoutStudentInput>
  }

  export type group_membersUpdateManyWithWhereWithoutStudentInput = {
    where: group_membersScalarWhereInput
    data: XOR<group_membersUpdateManyMutationInput, group_membersUncheckedUpdateManyWithoutStudentInput>
  }

  export type group_membersScalarWhereInput = {
    AND?: group_membersScalarWhereInput | group_membersScalarWhereInput[]
    OR?: group_membersScalarWhereInput[]
    NOT?: group_membersScalarWhereInput | group_membersScalarWhereInput[]
    group_id?: BigIntFilter<"group_members"> | bigint | number
    student_id?: BigIntFilter<"group_members"> | bigint | number
    joined_at?: DateTimeNullableFilter<"group_members"> | Date | string | null
  }

  export type subject_masteryUpsertWithWhereUniqueWithoutUserInput = {
    where: subject_masteryWhereUniqueInput
    update: XOR<subject_masteryUpdateWithoutUserInput, subject_masteryUncheckedUpdateWithoutUserInput>
    create: XOR<subject_masteryCreateWithoutUserInput, subject_masteryUncheckedCreateWithoutUserInput>
  }

  export type subject_masteryUpdateWithWhereUniqueWithoutUserInput = {
    where: subject_masteryWhereUniqueInput
    data: XOR<subject_masteryUpdateWithoutUserInput, subject_masteryUncheckedUpdateWithoutUserInput>
  }

  export type subject_masteryUpdateManyWithWhereWithoutUserInput = {
    where: subject_masteryScalarWhereInput
    data: XOR<subject_masteryUpdateManyMutationInput, subject_masteryUncheckedUpdateManyWithoutUserInput>
  }

  export type student_progressUpsertWithoutUserInput = {
    update: XOR<student_progressUpdateWithoutUserInput, student_progressUncheckedUpdateWithoutUserInput>
    create: XOR<student_progressCreateWithoutUserInput, student_progressUncheckedCreateWithoutUserInput>
    where?: student_progressWhereInput
  }

  export type student_progressUpdateToOneWithWhereWithoutUserInput = {
    where?: student_progressWhereInput
    data: XOR<student_progressUpdateWithoutUserInput, student_progressUncheckedUpdateWithoutUserInput>
  }

  export type student_progressUpdateWithoutUserInput = {
    level?: IntFieldUpdateOperationsInput | number
    current_xp?: IntFieldUpdateOperationsInput | number
    next_level_xp?: IntFieldUpdateOperationsInput | number
    streak_days?: IntFieldUpdateOperationsInput | number
    last_activity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_progressUncheckedUpdateWithoutUserInput = {
    level?: IntFieldUpdateOperationsInput | number
    current_xp?: IntFieldUpdateOperationsInput | number
    next_level_xp?: IntFieldUpdateOperationsInput | number
    streak_days?: IntFieldUpdateOperationsInput | number
    last_activity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUpsertWithWhereUniqueWithoutUserInput = {
    where: activity_logWhereUniqueInput
    update: XOR<activity_logUpdateWithoutUserInput, activity_logUncheckedUpdateWithoutUserInput>
    create: XOR<activity_logCreateWithoutUserInput, activity_logUncheckedCreateWithoutUserInput>
  }

  export type activity_logUpdateWithWhereUniqueWithoutUserInput = {
    where: activity_logWhereUniqueInput
    data: XOR<activity_logUpdateWithoutUserInput, activity_logUncheckedUpdateWithoutUserInput>
  }

  export type activity_logUpdateManyWithWhereWithoutUserInput = {
    where: activity_logScalarWhereInput
    data: XOR<activity_logUpdateManyMutationInput, activity_logUncheckedUpdateManyWithoutUserInput>
  }

  export type activity_logScalarWhereInput = {
    AND?: activity_logScalarWhereInput | activity_logScalarWhereInput[]
    OR?: activity_logScalarWhereInput[]
    NOT?: activity_logScalarWhereInput | activity_logScalarWhereInput[]
    activity_id?: BigIntFilter<"activity_log"> | bigint | number
    user_id?: BigIntFilter<"activity_log"> | bigint | number
    activity_type?: StringFilter<"activity_log"> | string
    xp_earned?: IntFilter<"activity_log"> | number
    details?: StringNullableFilter<"activity_log"> | string | null
    created_at?: DateTimeNullableFilter<"activity_log"> | Date | string | null
  }

  export type student_rewardsUpsertWithWhereUniqueWithoutUserInput = {
    where: student_rewardsWhereUniqueInput
    update: XOR<student_rewardsUpdateWithoutUserInput, student_rewardsUncheckedUpdateWithoutUserInput>
    create: XOR<student_rewardsCreateWithoutUserInput, student_rewardsUncheckedCreateWithoutUserInput>
  }

  export type student_rewardsUpdateWithWhereUniqueWithoutUserInput = {
    where: student_rewardsWhereUniqueInput
    data: XOR<student_rewardsUpdateWithoutUserInput, student_rewardsUncheckedUpdateWithoutUserInput>
  }

  export type student_rewardsUpdateManyWithWhereWithoutUserInput = {
    where: student_rewardsScalarWhereInput
    data: XOR<student_rewardsUpdateManyMutationInput, student_rewardsUncheckedUpdateManyWithoutUserInput>
  }

  export type student_rewardsScalarWhereInput = {
    AND?: student_rewardsScalarWhereInput | student_rewardsScalarWhereInput[]
    OR?: student_rewardsScalarWhereInput[]
    NOT?: student_rewardsScalarWhereInput | student_rewardsScalarWhereInput[]
    user_id?: BigIntFilter<"student_rewards"> | bigint | number
    reward_id?: BigIntFilter<"student_rewards"> | bigint | number
    purchased_at?: DateTimeNullableFilter<"student_rewards"> | Date | string | null
  }

  export type student_guardiansUpsertWithWhereUniqueWithoutGuardianInput = {
    where: student_guardiansWhereUniqueInput
    update: XOR<student_guardiansUpdateWithoutGuardianInput, student_guardiansUncheckedUpdateWithoutGuardianInput>
    create: XOR<student_guardiansCreateWithoutGuardianInput, student_guardiansUncheckedCreateWithoutGuardianInput>
  }

  export type student_guardiansUpdateWithWhereUniqueWithoutGuardianInput = {
    where: student_guardiansWhereUniqueInput
    data: XOR<student_guardiansUpdateWithoutGuardianInput, student_guardiansUncheckedUpdateWithoutGuardianInput>
  }

  export type student_guardiansUpdateManyWithWhereWithoutGuardianInput = {
    where: student_guardiansScalarWhereInput
    data: XOR<student_guardiansUpdateManyMutationInput, student_guardiansUncheckedUpdateManyWithoutGuardianInput>
  }

  export type student_guardiansScalarWhereInput = {
    AND?: student_guardiansScalarWhereInput | student_guardiansScalarWhereInput[]
    OR?: student_guardiansScalarWhereInput[]
    NOT?: student_guardiansScalarWhereInput | student_guardiansScalarWhereInput[]
    relationship_id?: BigIntFilter<"student_guardians"> | bigint | number
    guardian_id?: BigIntFilter<"student_guardians"> | bigint | number
    student_id?: BigIntFilter<"student_guardians"> | bigint | number
    relationship_type?: EnumGuardianRelationTypeFilter<"student_guardians"> | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFilter<"student_guardians"> | $Enums.GuardianRelationStatus
    created_at?: DateTimeNullableFilter<"student_guardians"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_guardians"> | Date | string | null
  }

  export type student_guardiansUpsertWithWhereUniqueWithoutStudentInput = {
    where: student_guardiansWhereUniqueInput
    update: XOR<student_guardiansUpdateWithoutStudentInput, student_guardiansUncheckedUpdateWithoutStudentInput>
    create: XOR<student_guardiansCreateWithoutStudentInput, student_guardiansUncheckedCreateWithoutStudentInput>
  }

  export type student_guardiansUpdateWithWhereUniqueWithoutStudentInput = {
    where: student_guardiansWhereUniqueInput
    data: XOR<student_guardiansUpdateWithoutStudentInput, student_guardiansUncheckedUpdateWithoutStudentInput>
  }

  export type student_guardiansUpdateManyWithWhereWithoutStudentInput = {
    where: student_guardiansScalarWhereInput
    data: XOR<student_guardiansUpdateManyMutationInput, student_guardiansUncheckedUpdateManyWithoutStudentInput>
  }

  export type test_assignmentsUpsertWithWhereUniqueWithoutAssignerInput = {
    where: test_assignmentsWhereUniqueInput
    update: XOR<test_assignmentsUpdateWithoutAssignerInput, test_assignmentsUncheckedUpdateWithoutAssignerInput>
    create: XOR<test_assignmentsCreateWithoutAssignerInput, test_assignmentsUncheckedCreateWithoutAssignerInput>
  }

  export type test_assignmentsUpdateWithWhereUniqueWithoutAssignerInput = {
    where: test_assignmentsWhereUniqueInput
    data: XOR<test_assignmentsUpdateWithoutAssignerInput, test_assignmentsUncheckedUpdateWithoutAssignerInput>
  }

  export type test_assignmentsUpdateManyWithWhereWithoutAssignerInput = {
    where: test_assignmentsScalarWhereInput
    data: XOR<test_assignmentsUpdateManyMutationInput, test_assignmentsUncheckedUpdateManyWithoutAssignerInput>
  }

  export type test_assignmentsUpsertWithWhereUniqueWithoutStudentInput = {
    where: test_assignmentsWhereUniqueInput
    update: XOR<test_assignmentsUpdateWithoutStudentInput, test_assignmentsUncheckedUpdateWithoutStudentInput>
    create: XOR<test_assignmentsCreateWithoutStudentInput, test_assignmentsUncheckedCreateWithoutStudentInput>
  }

  export type test_assignmentsUpdateWithWhereUniqueWithoutStudentInput = {
    where: test_assignmentsWhereUniqueInput
    data: XOR<test_assignmentsUpdateWithoutStudentInput, test_assignmentsUncheckedUpdateWithoutStudentInput>
  }

  export type test_assignmentsUpdateManyWithWhereWithoutStudentInput = {
    where: test_assignmentsScalarWhereInput
    data: XOR<test_assignmentsUpdateManyMutationInput, test_assignmentsUncheckedUpdateManyWithoutStudentInput>
  }

  export type subjectsCreateWithoutDifficulty_levelsInput = {
    subject_name: string
    description?: string | null
    topics?: topicsCreateNestedManyWithoutSubjectsInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutDifficulty_levelsInput = {
    subject_id?: number
    subject_name: string
    description?: string | null
    topics?: topicsUncheckedCreateNestedManyWithoutSubjectsInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutDifficulty_levelsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutDifficulty_levelsInput, subjectsUncheckedCreateWithoutDifficulty_levelsInput>
  }

  export type subjectsUpsertWithoutDifficulty_levelsInput = {
    update: XOR<subjectsUpdateWithoutDifficulty_levelsInput, subjectsUncheckedUpdateWithoutDifficulty_levelsInput>
    create: XOR<subjectsCreateWithoutDifficulty_levelsInput, subjectsUncheckedCreateWithoutDifficulty_levelsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutDifficulty_levelsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutDifficulty_levelsInput, subjectsUncheckedUpdateWithoutDifficulty_levelsInput>
  }

  export type subjectsUpdateWithoutDifficulty_levelsInput = {
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUpdateManyWithoutSubjectsNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutDifficulty_levelsInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUncheckedUpdateManyWithoutSubjectsNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersCreateWithoutStudent_progressInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutStudent_progressInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutStudent_progressInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudent_progressInput, usersUncheckedCreateWithoutStudent_progressInput>
  }

  export type usersUpsertWithoutStudent_progressInput = {
    update: XOR<usersUpdateWithoutStudent_progressInput, usersUncheckedUpdateWithoutStudent_progressInput>
    create: XOR<usersCreateWithoutStudent_progressInput, usersUncheckedCreateWithoutStudent_progressInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudent_progressInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudent_progressInput, usersUncheckedUpdateWithoutStudent_progressInput>
  }

  export type usersUpdateWithoutStudent_progressInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutStudent_progressInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type student_achievementsCreateWithoutAchievementsInput = {
    unlocked_at?: Date | string | null
    progress?: number
    user: usersCreateNestedOneWithoutAchievements_earnedInput
  }

  export type student_achievementsUncheckedCreateWithoutAchievementsInput = {
    user_id: bigint | number
    unlocked_at?: Date | string | null
    progress?: number
  }

  export type student_achievementsCreateOrConnectWithoutAchievementsInput = {
    where: student_achievementsWhereUniqueInput
    create: XOR<student_achievementsCreateWithoutAchievementsInput, student_achievementsUncheckedCreateWithoutAchievementsInput>
  }

  export type student_achievementsCreateManyAchievementsInputEnvelope = {
    data: student_achievementsCreateManyAchievementsInput | student_achievementsCreateManyAchievementsInput[]
    skipDuplicates?: boolean
  }

  export type student_achievementsUpsertWithWhereUniqueWithoutAchievementsInput = {
    where: student_achievementsWhereUniqueInput
    update: XOR<student_achievementsUpdateWithoutAchievementsInput, student_achievementsUncheckedUpdateWithoutAchievementsInput>
    create: XOR<student_achievementsCreateWithoutAchievementsInput, student_achievementsUncheckedCreateWithoutAchievementsInput>
  }

  export type student_achievementsUpdateWithWhereUniqueWithoutAchievementsInput = {
    where: student_achievementsWhereUniqueInput
    data: XOR<student_achievementsUpdateWithoutAchievementsInput, student_achievementsUncheckedUpdateWithoutAchievementsInput>
  }

  export type student_achievementsUpdateManyWithWhereWithoutAchievementsInput = {
    where: student_achievementsScalarWhereInput
    data: XOR<student_achievementsUpdateManyMutationInput, student_achievementsUncheckedUpdateManyWithoutAchievementsInput>
  }

  export type usersCreateWithoutAchievements_earnedInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutAchievements_earnedInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutAchievements_earnedInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAchievements_earnedInput, usersUncheckedCreateWithoutAchievements_earnedInput>
  }

  export type achievementsCreateWithoutStudent_achievementsInput = {
    achievement_id?: bigint | number
    title: string
    description: string
    category: string
    points: number
    icon?: string | null
    required_criteria: string
    created_at?: Date | string | null
  }

  export type achievementsUncheckedCreateWithoutStudent_achievementsInput = {
    achievement_id?: bigint | number
    title: string
    description: string
    category: string
    points: number
    icon?: string | null
    required_criteria: string
    created_at?: Date | string | null
  }

  export type achievementsCreateOrConnectWithoutStudent_achievementsInput = {
    where: achievementsWhereUniqueInput
    create: XOR<achievementsCreateWithoutStudent_achievementsInput, achievementsUncheckedCreateWithoutStudent_achievementsInput>
  }

  export type usersUpsertWithoutAchievements_earnedInput = {
    update: XOR<usersUpdateWithoutAchievements_earnedInput, usersUncheckedUpdateWithoutAchievements_earnedInput>
    create: XOR<usersCreateWithoutAchievements_earnedInput, usersUncheckedCreateWithoutAchievements_earnedInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAchievements_earnedInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAchievements_earnedInput, usersUncheckedUpdateWithoutAchievements_earnedInput>
  }

  export type usersUpdateWithoutAchievements_earnedInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutAchievements_earnedInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type achievementsUpsertWithoutStudent_achievementsInput = {
    update: XOR<achievementsUpdateWithoutStudent_achievementsInput, achievementsUncheckedUpdateWithoutStudent_achievementsInput>
    create: XOR<achievementsCreateWithoutStudent_achievementsInput, achievementsUncheckedCreateWithoutStudent_achievementsInput>
    where?: achievementsWhereInput
  }

  export type achievementsUpdateToOneWithWhereWithoutStudent_achievementsInput = {
    where?: achievementsWhereInput
    data: XOR<achievementsUpdateWithoutStudent_achievementsInput, achievementsUncheckedUpdateWithoutStudent_achievementsInput>
  }

  export type achievementsUpdateWithoutStudent_achievementsInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    required_criteria?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type achievementsUncheckedUpdateWithoutStudent_achievementsInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    required_criteria?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsCreateWithoutRewardsInput = {
    purchased_at?: Date | string | null
    user: usersCreateNestedOneWithoutStudent_rewardsInput
  }

  export type student_rewardsUncheckedCreateWithoutRewardsInput = {
    user_id: bigint | number
    purchased_at?: Date | string | null
  }

  export type student_rewardsCreateOrConnectWithoutRewardsInput = {
    where: student_rewardsWhereUniqueInput
    create: XOR<student_rewardsCreateWithoutRewardsInput, student_rewardsUncheckedCreateWithoutRewardsInput>
  }

  export type student_rewardsCreateManyRewardsInputEnvelope = {
    data: student_rewardsCreateManyRewardsInput | student_rewardsCreateManyRewardsInput[]
    skipDuplicates?: boolean
  }

  export type student_rewardsUpsertWithWhereUniqueWithoutRewardsInput = {
    where: student_rewardsWhereUniqueInput
    update: XOR<student_rewardsUpdateWithoutRewardsInput, student_rewardsUncheckedUpdateWithoutRewardsInput>
    create: XOR<student_rewardsCreateWithoutRewardsInput, student_rewardsUncheckedCreateWithoutRewardsInput>
  }

  export type student_rewardsUpdateWithWhereUniqueWithoutRewardsInput = {
    where: student_rewardsWhereUniqueInput
    data: XOR<student_rewardsUpdateWithoutRewardsInput, student_rewardsUncheckedUpdateWithoutRewardsInput>
  }

  export type student_rewardsUpdateManyWithWhereWithoutRewardsInput = {
    where: student_rewardsScalarWhereInput
    data: XOR<student_rewardsUpdateManyMutationInput, student_rewardsUncheckedUpdateManyWithoutRewardsInput>
  }

  export type usersCreateWithoutStudent_rewardsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutStudent_rewardsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutStudent_rewardsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudent_rewardsInput, usersUncheckedCreateWithoutStudent_rewardsInput>
  }

  export type rewardsCreateWithoutStudent_rewardsInput = {
    reward_id?: bigint | number
    title: string
    description: string
    category: string
    cost: number
    icon?: string | null
    created_at?: Date | string | null
  }

  export type rewardsUncheckedCreateWithoutStudent_rewardsInput = {
    reward_id?: bigint | number
    title: string
    description: string
    category: string
    cost: number
    icon?: string | null
    created_at?: Date | string | null
  }

  export type rewardsCreateOrConnectWithoutStudent_rewardsInput = {
    where: rewardsWhereUniqueInput
    create: XOR<rewardsCreateWithoutStudent_rewardsInput, rewardsUncheckedCreateWithoutStudent_rewardsInput>
  }

  export type usersUpsertWithoutStudent_rewardsInput = {
    update: XOR<usersUpdateWithoutStudent_rewardsInput, usersUncheckedUpdateWithoutStudent_rewardsInput>
    create: XOR<usersCreateWithoutStudent_rewardsInput, usersUncheckedCreateWithoutStudent_rewardsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudent_rewardsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudent_rewardsInput, usersUncheckedUpdateWithoutStudent_rewardsInput>
  }

  export type usersUpdateWithoutStudent_rewardsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutStudent_rewardsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type rewardsUpsertWithoutStudent_rewardsInput = {
    update: XOR<rewardsUpdateWithoutStudent_rewardsInput, rewardsUncheckedUpdateWithoutStudent_rewardsInput>
    create: XOR<rewardsCreateWithoutStudent_rewardsInput, rewardsUncheckedCreateWithoutStudent_rewardsInput>
    where?: rewardsWhereInput
  }

  export type rewardsUpdateToOneWithWhereWithoutStudent_rewardsInput = {
    where?: rewardsWhereInput
    data: XOR<rewardsUpdateWithoutStudent_rewardsInput, rewardsUncheckedUpdateWithoutStudent_rewardsInput>
  }

  export type rewardsUpdateWithoutStudent_rewardsInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardsUncheckedUpdateWithoutStudent_rewardsInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutSubject_masteryInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutSubject_masteryInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutSubject_masteryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubject_masteryInput, usersUncheckedCreateWithoutSubject_masteryInput>
  }

  export type subjectsCreateWithoutSubject_masteryInput = {
    subject_name: string
    description?: string | null
    topics?: topicsCreateNestedManyWithoutSubjectsInput
    difficulty_levels?: difficulty_levelsCreateNestedManyWithoutSubjectInput
  }

  export type subjectsUncheckedCreateWithoutSubject_masteryInput = {
    subject_id?: number
    subject_name: string
    description?: string | null
    topics?: topicsUncheckedCreateNestedManyWithoutSubjectsInput
    difficulty_levels?: difficulty_levelsUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectsCreateOrConnectWithoutSubject_masteryInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutSubject_masteryInput, subjectsUncheckedCreateWithoutSubject_masteryInput>
  }

  export type usersUpsertWithoutSubject_masteryInput = {
    update: XOR<usersUpdateWithoutSubject_masteryInput, usersUncheckedUpdateWithoutSubject_masteryInput>
    create: XOR<usersCreateWithoutSubject_masteryInput, usersUncheckedCreateWithoutSubject_masteryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSubject_masteryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSubject_masteryInput, usersUncheckedUpdateWithoutSubject_masteryInput>
  }

  export type usersUpdateWithoutSubject_masteryInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutSubject_masteryInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type subjectsUpsertWithoutSubject_masteryInput = {
    update: XOR<subjectsUpdateWithoutSubject_masteryInput, subjectsUncheckedUpdateWithoutSubject_masteryInput>
    create: XOR<subjectsCreateWithoutSubject_masteryInput, subjectsUncheckedCreateWithoutSubject_masteryInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutSubject_masteryInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutSubject_masteryInput, subjectsUncheckedUpdateWithoutSubject_masteryInput>
  }

  export type subjectsUpdateWithoutSubject_masteryInput = {
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUpdateManyWithoutSubjectsNestedInput
    difficulty_levels?: difficulty_levelsUpdateManyWithoutSubjectNestedInput
  }

  export type subjectsUncheckedUpdateWithoutSubject_masteryInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    subject_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: topicsUncheckedUpdateManyWithoutSubjectsNestedInput
    difficulty_levels?: difficulty_levelsUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type usersCreateWithoutActivity_logsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutActivity_logsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutActivity_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
  }

  export type usersUpsertWithoutActivity_logsInput = {
    update: XOR<usersUpdateWithoutActivity_logsInput, usersUncheckedUpdateWithoutActivity_logsInput>
    create: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutActivity_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutActivity_logsInput, usersUncheckedUpdateWithoutActivity_logsInput>
  }

  export type usersUpdateWithoutActivity_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutActivity_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type usersCreateWithoutTutor_groupsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutTutor_groupsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutTutor_groupsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTutor_groupsInput, usersUncheckedCreateWithoutTutor_groupsInput>
  }

  export type usersCreateWithoutStudent_groupsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutStudent_groupsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutStudent_groupsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudent_groupsInput, usersUncheckedCreateWithoutStudent_groupsInput>
  }

  export type group_membersCreateWithoutGroupInput = {
    joined_at?: Date | string | null
    student: usersCreateNestedOneWithoutGroup_membershipsInput
  }

  export type group_membersUncheckedCreateWithoutGroupInput = {
    student_id: bigint | number
    joined_at?: Date | string | null
  }

  export type group_membersCreateOrConnectWithoutGroupInput = {
    where: group_membersWhereUniqueInput
    create: XOR<group_membersCreateWithoutGroupInput, group_membersUncheckedCreateWithoutGroupInput>
  }

  export type group_membersCreateManyGroupInputEnvelope = {
    data: group_membersCreateManyGroupInput | group_membersCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type test_assignmentsCreateWithoutGroupInput = {
    assignment_id?: bigint | number
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
    test_plan: test_plansCreateNestedOneWithoutAssignmentsInput
    assigner: usersCreateNestedOneWithoutAssignments_createdInput
    student?: usersCreateNestedOneWithoutAssignments_receivedInput
  }

  export type test_assignmentsUncheckedCreateWithoutGroupInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    assigned_by: bigint | number
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsCreateOrConnectWithoutGroupInput = {
    where: test_assignmentsWhereUniqueInput
    create: XOR<test_assignmentsCreateWithoutGroupInput, test_assignmentsUncheckedCreateWithoutGroupInput>
  }

  export type test_assignmentsCreateManyGroupInputEnvelope = {
    data: test_assignmentsCreateManyGroupInput | test_assignmentsCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type test_plansCreateWithoutStudy_groupsInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    assignments?: test_assignmentsCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutStudy_groupsInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutTest_planInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutStudy_groupsInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutStudy_groupsInput, test_plansUncheckedCreateWithoutStudy_groupsInput>
  }

  export type usersUpsertWithoutTutor_groupsInput = {
    update: XOR<usersUpdateWithoutTutor_groupsInput, usersUncheckedUpdateWithoutTutor_groupsInput>
    create: XOR<usersCreateWithoutTutor_groupsInput, usersUncheckedCreateWithoutTutor_groupsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTutor_groupsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTutor_groupsInput, usersUncheckedUpdateWithoutTutor_groupsInput>
  }

  export type usersUpdateWithoutTutor_groupsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutTutor_groupsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutStudent_groupsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutStudent_groupsInput, usersUncheckedUpdateWithoutStudent_groupsInput>
    create: XOR<usersCreateWithoutStudent_groupsInput, usersUncheckedCreateWithoutStudent_groupsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutStudent_groupsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutStudent_groupsInput, usersUncheckedUpdateWithoutStudent_groupsInput>
  }

  export type usersUpdateManyWithWhereWithoutStudent_groupsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutStudent_groupsInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    user_id?: BigIntFilter<"users"> | bigint | number
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    last_login?: DateTimeNullableFilter<"users"> | Date | string | null
    active?: BoolFilter<"users"> | boolean
  }

  export type group_membersUpsertWithWhereUniqueWithoutGroupInput = {
    where: group_membersWhereUniqueInput
    update: XOR<group_membersUpdateWithoutGroupInput, group_membersUncheckedUpdateWithoutGroupInput>
    create: XOR<group_membersCreateWithoutGroupInput, group_membersUncheckedCreateWithoutGroupInput>
  }

  export type group_membersUpdateWithWhereUniqueWithoutGroupInput = {
    where: group_membersWhereUniqueInput
    data: XOR<group_membersUpdateWithoutGroupInput, group_membersUncheckedUpdateWithoutGroupInput>
  }

  export type group_membersUpdateManyWithWhereWithoutGroupInput = {
    where: group_membersScalarWhereInput
    data: XOR<group_membersUpdateManyMutationInput, group_membersUncheckedUpdateManyWithoutGroupInput>
  }

  export type test_assignmentsUpsertWithWhereUniqueWithoutGroupInput = {
    where: test_assignmentsWhereUniqueInput
    update: XOR<test_assignmentsUpdateWithoutGroupInput, test_assignmentsUncheckedUpdateWithoutGroupInput>
    create: XOR<test_assignmentsCreateWithoutGroupInput, test_assignmentsUncheckedCreateWithoutGroupInput>
  }

  export type test_assignmentsUpdateWithWhereUniqueWithoutGroupInput = {
    where: test_assignmentsWhereUniqueInput
    data: XOR<test_assignmentsUpdateWithoutGroupInput, test_assignmentsUncheckedUpdateWithoutGroupInput>
  }

  export type test_assignmentsUpdateManyWithWhereWithoutGroupInput = {
    where: test_assignmentsScalarWhereInput
    data: XOR<test_assignmentsUpdateManyMutationInput, test_assignmentsUncheckedUpdateManyWithoutGroupInput>
  }

  export type test_plansUpsertWithWhereUniqueWithoutStudy_groupsInput = {
    where: test_plansWhereUniqueInput
    update: XOR<test_plansUpdateWithoutStudy_groupsInput, test_plansUncheckedUpdateWithoutStudy_groupsInput>
    create: XOR<test_plansCreateWithoutStudy_groupsInput, test_plansUncheckedCreateWithoutStudy_groupsInput>
  }

  export type test_plansUpdateWithWhereUniqueWithoutStudy_groupsInput = {
    where: test_plansWhereUniqueInput
    data: XOR<test_plansUpdateWithoutStudy_groupsInput, test_plansUncheckedUpdateWithoutStudy_groupsInput>
  }

  export type test_plansUpdateManyWithWhereWithoutStudy_groupsInput = {
    where: test_plansScalarWhereInput
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyWithoutStudy_groupsInput>
  }

  export type usersCreateWithoutGuardian_relationshipsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutGuardian_relationshipsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutGuardian_relationshipsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGuardian_relationshipsInput, usersUncheckedCreateWithoutGuardian_relationshipsInput>
  }

  export type usersCreateWithoutStudent_relationshipsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutStudent_relationshipsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutStudent_relationshipsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudent_relationshipsInput, usersUncheckedCreateWithoutStudent_relationshipsInput>
  }

  export type usersUpsertWithoutGuardian_relationshipsInput = {
    update: XOR<usersUpdateWithoutGuardian_relationshipsInput, usersUncheckedUpdateWithoutGuardian_relationshipsInput>
    create: XOR<usersCreateWithoutGuardian_relationshipsInput, usersUncheckedCreateWithoutGuardian_relationshipsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGuardian_relationshipsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGuardian_relationshipsInput, usersUncheckedUpdateWithoutGuardian_relationshipsInput>
  }

  export type usersUpdateWithoutGuardian_relationshipsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutGuardian_relationshipsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type usersUpsertWithoutStudent_relationshipsInput = {
    update: XOR<usersUpdateWithoutStudent_relationshipsInput, usersUncheckedUpdateWithoutStudent_relationshipsInput>
    create: XOR<usersCreateWithoutStudent_relationshipsInput, usersUncheckedCreateWithoutStudent_relationshipsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudent_relationshipsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudent_relationshipsInput, usersUncheckedUpdateWithoutStudent_relationshipsInput>
  }

  export type usersUpdateWithoutStudent_relationshipsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutStudent_relationshipsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type study_groupsCreateWithoutMembersInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tutor: usersCreateNestedOneWithoutTutor_groupsInput
    students?: usersCreateNestedManyWithoutStudent_groupsInput
    assignments?: test_assignmentsCreateNestedManyWithoutGroupInput
    test_plans?: test_plansCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsUncheckedCreateWithoutMembersInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    tutor_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students?: usersUncheckedCreateNestedManyWithoutStudent_groupsInput
    assignments?: test_assignmentsUncheckedCreateNestedManyWithoutGroupInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsCreateOrConnectWithoutMembersInput = {
    where: study_groupsWhereUniqueInput
    create: XOR<study_groupsCreateWithoutMembersInput, study_groupsUncheckedCreateWithoutMembersInput>
  }

  export type usersCreateWithoutGroup_membershipsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutGroup_membershipsInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutGroup_membershipsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGroup_membershipsInput, usersUncheckedCreateWithoutGroup_membershipsInput>
  }

  export type study_groupsUpsertWithoutMembersInput = {
    update: XOR<study_groupsUpdateWithoutMembersInput, study_groupsUncheckedUpdateWithoutMembersInput>
    create: XOR<study_groupsCreateWithoutMembersInput, study_groupsUncheckedCreateWithoutMembersInput>
    where?: study_groupsWhereInput
  }

  export type study_groupsUpdateToOneWithWhereWithoutMembersInput = {
    where?: study_groupsWhereInput
    data: XOR<study_groupsUpdateWithoutMembersInput, study_groupsUncheckedUpdateWithoutMembersInput>
  }

  export type study_groupsUpdateWithoutMembersInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutor?: usersUpdateOneRequiredWithoutTutor_groupsNestedInput
    students?: usersUpdateManyWithoutStudent_groupsNestedInput
    assignments?: test_assignmentsUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateWithoutMembersInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: usersUncheckedUpdateManyWithoutStudent_groupsNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutStudy_groupsNestedInput
  }

  export type usersUpsertWithoutGroup_membershipsInput = {
    update: XOR<usersUpdateWithoutGroup_membershipsInput, usersUncheckedUpdateWithoutGroup_membershipsInput>
    create: XOR<usersCreateWithoutGroup_membershipsInput, usersUncheckedCreateWithoutGroup_membershipsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGroup_membershipsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGroup_membershipsInput, usersUncheckedUpdateWithoutGroup_membershipsInput>
  }

  export type usersUpdateWithoutGroup_membershipsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutGroup_membershipsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type test_plansCreateWithoutAssignmentsInput = {
    test_plan_id?: bigint | number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsCreateNestedManyWithoutTest_plansInput
    test_templates?: test_templatesCreateNestedOneWithoutTest_plansInput
    exam_boards: exam_boardsCreateNestedOneWithoutTest_plansInput
    student: usersCreateNestedOneWithoutAssigned_test_plansInput
    planner: usersCreateNestedOneWithoutPlanned_test_plansInput
    study_groups?: study_groupsCreateNestedManyWithoutTest_plansInput
    question_set_links?: test_plan_question_setsCreateNestedManyWithoutTest_planInput
  }

  export type test_plansUncheckedCreateWithoutAssignmentsInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutTest_plansInput
    study_groups?: study_groupsUncheckedCreateNestedManyWithoutTest_plansInput
    question_set_links?: test_plan_question_setsUncheckedCreateNestedManyWithoutTest_planInput
  }

  export type test_plansCreateOrConnectWithoutAssignmentsInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutAssignmentsInput, test_plansUncheckedCreateWithoutAssignmentsInput>
  }

  export type usersCreateWithoutAssignments_createdInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_received?: test_assignmentsCreateNestedManyWithoutStudentInput
  }

  export type usersUncheckedCreateWithoutAssignments_createdInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_received?: test_assignmentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type usersCreateOrConnectWithoutAssignments_createdInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAssignments_createdInput, usersUncheckedCreateWithoutAssignments_createdInput>
  }

  export type study_groupsCreateWithoutAssignmentsInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tutor: usersCreateNestedOneWithoutTutor_groupsInput
    students?: usersCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersCreateNestedManyWithoutGroupInput
    test_plans?: test_plansCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsUncheckedCreateWithoutAssignmentsInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    tutor_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students?: usersUncheckedCreateNestedManyWithoutStudent_groupsInput
    members?: group_membersUncheckedCreateNestedManyWithoutGroupInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutStudy_groupsInput
  }

  export type study_groupsCreateOrConnectWithoutAssignmentsInput = {
    where: study_groupsWhereUniqueInput
    create: XOR<study_groupsCreateWithoutAssignmentsInput, study_groupsUncheckedCreateWithoutAssignmentsInput>
  }

  export type usersCreateWithoutAssignments_receivedInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryCreateNestedManyWithoutUserInput
    student_progress?: student_progressCreateNestedOneWithoutUserInput
    activity_logs?: activity_logCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsCreateNestedManyWithoutAssignerInput
  }

  export type usersUncheckedCreateWithoutAssignments_receivedInput = {
    user_id?: bigint | number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    last_login?: Date | string | null
    active?: boolean
    questions?: questionsUncheckedCreateNestedManyWithoutUsersInput
    created_question_sets?: question_setsUncheckedCreateNestedManyWithoutCreatorInput
    test_executions?: test_executionsUncheckedCreateNestedManyWithoutUsersInput
    assigned_test_plans?: test_plansUncheckedCreateNestedManyWithoutStudentInput
    planned_test_plans?: test_plansUncheckedCreateNestedManyWithoutPlannerInput
    test_templates?: test_templatesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    achievements_earned?: student_achievementsUncheckedCreateNestedManyWithoutUserInput
    tutor_groups?: study_groupsUncheckedCreateNestedManyWithoutTutorInput
    student_groups?: study_groupsUncheckedCreateNestedManyWithoutStudentsInput
    group_memberships?: group_membersUncheckedCreateNestedManyWithoutStudentInput
    subject_mastery?: subject_masteryUncheckedCreateNestedManyWithoutUserInput
    student_progress?: student_progressUncheckedCreateNestedOneWithoutUserInput
    activity_logs?: activity_logUncheckedCreateNestedManyWithoutUserInput
    student_rewards?: student_rewardsUncheckedCreateNestedManyWithoutUserInput
    guardian_relationships?: student_guardiansUncheckedCreateNestedManyWithoutGuardianInput
    student_relationships?: student_guardiansUncheckedCreateNestedManyWithoutStudentInput
    assignments_created?: test_assignmentsUncheckedCreateNestedManyWithoutAssignerInput
  }

  export type usersCreateOrConnectWithoutAssignments_receivedInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAssignments_receivedInput, usersUncheckedCreateWithoutAssignments_receivedInput>
  }

  export type test_plansUpsertWithoutAssignmentsInput = {
    update: XOR<test_plansUpdateWithoutAssignmentsInput, test_plansUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<test_plansCreateWithoutAssignmentsInput, test_plansUncheckedCreateWithoutAssignmentsInput>
    where?: test_plansWhereInput
  }

  export type test_plansUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: test_plansWhereInput
    data: XOR<test_plansUpdateWithoutAssignmentsInput, test_plansUncheckedUpdateWithoutAssignmentsInput>
  }

  export type test_plansUpdateWithoutAssignmentsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutAssignmentsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type usersUpsertWithoutAssignments_createdInput = {
    update: XOR<usersUpdateWithoutAssignments_createdInput, usersUncheckedUpdateWithoutAssignments_createdInput>
    create: XOR<usersCreateWithoutAssignments_createdInput, usersUncheckedCreateWithoutAssignments_createdInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAssignments_createdInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAssignments_createdInput, usersUncheckedUpdateWithoutAssignments_createdInput>
  }

  export type usersUpdateWithoutAssignments_createdInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutAssignments_createdInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type study_groupsUpsertWithoutAssignmentsInput = {
    update: XOR<study_groupsUpdateWithoutAssignmentsInput, study_groupsUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<study_groupsCreateWithoutAssignmentsInput, study_groupsUncheckedCreateWithoutAssignmentsInput>
    where?: study_groupsWhereInput
  }

  export type study_groupsUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: study_groupsWhereInput
    data: XOR<study_groupsUpdateWithoutAssignmentsInput, study_groupsUncheckedUpdateWithoutAssignmentsInput>
  }

  export type study_groupsUpdateWithoutAssignmentsInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutor?: usersUpdateOneRequiredWithoutTutor_groupsNestedInput
    students?: usersUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateWithoutAssignmentsInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: usersUncheckedUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUncheckedUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutStudy_groupsNestedInput
  }

  export type usersUpsertWithoutAssignments_receivedInput = {
    update: XOR<usersUpdateWithoutAssignments_receivedInput, usersUncheckedUpdateWithoutAssignments_receivedInput>
    create: XOR<usersCreateWithoutAssignments_receivedInput, usersUncheckedCreateWithoutAssignments_receivedInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAssignments_receivedInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAssignments_receivedInput, usersUncheckedUpdateWithoutAssignments_receivedInput>
  }

  export type usersUpdateWithoutAssignments_receivedInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
  }

  export type usersUncheckedUpdateWithoutAssignments_receivedInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    student_groups?: study_groupsUncheckedUpdateManyWithoutStudentsNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
  }

  export type test_plansCreateManyExam_boardsInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
  }

  export type test_templatesCreateManyExam_boardsInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_by: bigint | number
    created_at?: Date | string | null
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
  }

  export type test_plansUpdateWithoutExam_boardsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutExam_boardsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateManyWithoutExam_boardsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }

  export type test_templatesUpdateWithoutExam_boardsInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    test_plans?: test_plansUpdateManyWithoutTest_templatesNestedInput
    users?: usersUpdateOneRequiredWithoutTest_templatesNestedInput
  }

  export type test_templatesUncheckedUpdateWithoutExam_boardsInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    test_plans?: test_plansUncheckedUpdateManyWithoutTest_templatesNestedInput
  }

  export type test_templatesUncheckedUpdateManyWithoutExam_boardsInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type question_set_itemsCreateManyQuestionInput = {
    item_id?: bigint | number
    set_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type question_set_itemsUpdateWithoutQuestionInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_set?: question_setsUpdateOneRequiredWithoutQuestion_set_itemsNestedInput
  }

  export type question_set_itemsUncheckedUpdateWithoutQuestionInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_set_itemsUncheckedUpdateManyWithoutQuestionInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_set_itemsCreateManyQuestion_setInput = {
    item_id?: bigint | number
    question_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type test_plan_question_setsCreateManyQuestion_setInput = {
    link_id?: bigint | number
    test_plan_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type question_set_itemsUpdateWithoutQuestion_setInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionsUpdateOneRequiredWithoutQuestion_set_itemsNestedInput
  }

  export type question_set_itemsUncheckedUpdateWithoutQuestion_setInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_set_itemsUncheckedUpdateManyWithoutQuestion_setInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_question_setsUpdateWithoutQuestion_setInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    test_plan?: test_plansUpdateOneRequiredWithoutQuestion_set_linksNestedInput
  }

  export type test_plan_question_setsUncheckedUpdateWithoutQuestion_setInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_question_setsUncheckedUpdateManyWithoutQuestion_setInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesCreateManyRolesInput = {
    user_id: bigint | number
  }

  export type user_rolesUpdateWithoutRolesInput = {
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutRolesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type topicsCreateManySubjectsInput = {
    topic_id?: number
    topic_name: string
    description?: string | null
  }

  export type subject_masteryCreateManySubjectsInput = {
    user_id: bigint | number
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
  }

  export type difficulty_levelsCreateManySubjectInput = {
    level_id?: number
    level_name: string
    level_value: number
    purpose: string
    characteristics: string
    focus_area: string
    steps_required?: string | null
    created_at?: Date | string | null
    active?: boolean | null
  }

  export type topicsUpdateWithoutSubjectsInput = {
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: subtopicsUpdateManyWithoutTopicsNestedInput
  }

  export type topicsUncheckedUpdateWithoutSubjectsInput = {
    topic_id?: IntFieldUpdateOperationsInput | number
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: subtopicsUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type topicsUncheckedUpdateManyWithoutSubjectsInput = {
    topic_id?: IntFieldUpdateOperationsInput | number
    topic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subject_masteryUpdateWithoutSubjectsInput = {
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutSubject_masteryNestedInput
  }

  export type subject_masteryUncheckedUpdateWithoutSubjectsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subject_masteryUncheckedUpdateManyWithoutSubjectsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type difficulty_levelsUpdateWithoutSubjectInput = {
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type difficulty_levelsUncheckedUpdateWithoutSubjectInput = {
    level_id?: IntFieldUpdateOperationsInput | number
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type difficulty_levelsUncheckedUpdateManyWithoutSubjectInput = {
    level_id?: IntFieldUpdateOperationsInput | number
    level_name?: StringFieldUpdateOperationsInput | string
    level_value?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    focus_area?: StringFieldUpdateOperationsInput | string
    steps_required?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type questionsCreateManySubtopicsInput = {
    question_id?: bigint | number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    created_by: bigint | number
    active?: boolean | null
  }

  export type questionsUpdateWithoutSubtopicsInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutQuestionsNestedInput
    question_set_items?: question_set_itemsUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateWithoutSubtopicsInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    question_set_items?: question_set_itemsUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutSubtopicsInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type test_executionsCreateManyTest_plansInput = {
    execution_id?: bigint | number
    student_id: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
  }

  export type test_assignmentsCreateManyTest_planInput = {
    assignment_id?: bigint | number
    assigned_by: bigint | number
    group_id?: bigint | number | null
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_plan_question_setsCreateManyTest_planInput = {
    link_id?: bigint | number
    set_id: bigint | number
    sequence: number
    created_at?: Date | string
  }

  export type test_executionsUpdateWithoutTest_plansInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    users?: usersUpdateOneRequiredWithoutTest_executionsNestedInput
  }

  export type test_executionsUncheckedUpdateWithoutTest_plansInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_executionsUncheckedUpdateManyWithoutTest_plansInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type study_groupsUpdateWithoutTest_plansInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutor?: usersUpdateOneRequiredWithoutTutor_groupsNestedInput
    students?: usersUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUpdateManyWithoutGroupNestedInput
  }

  export type study_groupsUncheckedUpdateWithoutTest_plansInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: usersUncheckedUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUncheckedUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type study_groupsUncheckedUpdateManyWithoutTest_plansInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUpdateWithoutTest_planInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigner?: usersUpdateOneRequiredWithoutAssignments_createdNestedInput
    group?: study_groupsUpdateOneWithoutAssignmentsNestedInput
    student?: usersUpdateOneWithoutAssignments_receivedNestedInput
  }

  export type test_assignmentsUncheckedUpdateWithoutTest_planInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUncheckedUpdateManyWithoutTest_planInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_plan_question_setsUpdateWithoutTest_planInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_set?: question_setsUpdateOneRequiredWithoutTest_plan_linksNestedInput
  }

  export type test_plan_question_setsUncheckedUpdateWithoutTest_planInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_question_setsUncheckedUpdateManyWithoutTest_planInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sequence?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plansCreateManyTest_templatesInput = {
    test_plan_id?: bigint | number
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
  }

  export type test_plansUpdateWithoutTest_templatesInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutTest_templatesInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateManyWithoutTest_templatesInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }

  export type subtopicsCreateManyTopicsInput = {
    subtopic_id?: number
    subtopic_name: string
    description?: string | null
  }

  export type subtopicsUpdateWithoutTopicsInput = {
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: questionsUpdateManyWithoutSubtopicsNestedInput
  }

  export type subtopicsUncheckedUpdateWithoutTopicsInput = {
    subtopic_id?: IntFieldUpdateOperationsInput | number
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: questionsUncheckedUpdateManyWithoutSubtopicsNestedInput
  }

  export type subtopicsUncheckedUpdateManyWithoutTopicsInput = {
    subtopic_id?: IntFieldUpdateOperationsInput | number
    subtopic_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionsCreateManyUsersInput = {
    question_id?: bigint | number
    subtopic_id: number
    question_text: string
    question_text_plain: string
    options: string
    correct_answer: string
    correct_answer_plain: string
    solution: string
    solution_plain: string
    difficulty_level: number
    created_at?: Date | string | null
    active?: boolean | null
  }

  export type question_setsCreateManyCreatorInput = {
    set_id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    active?: boolean
    metadata?: string | null
  }

  export type test_executionsCreateManyUsersInput = {
    execution_id?: bigint | number
    test_plan_id: bigint | number
    status: $Enums.test_executions_status
    started_at?: Date | string | null
    completed_at?: Date | string | null
    test_data: string
    score?: number | null
  }

  export type test_plansCreateManyStudentInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    planned_by: bigint | number
    planned_at?: Date | string | null
    configuration: string
  }

  export type test_plansCreateManyPlannerInput = {
    test_plan_id?: bigint | number
    template_id?: bigint | number | null
    board_id: number
    test_type: $Enums.test_plans_test_type
    timing_type: $Enums.test_plans_timing_type
    time_limit?: number | null
    student_id: bigint | number
    planned_at?: Date | string | null
    configuration: string
  }

  export type test_templatesCreateManyUsersInput = {
    template_id?: bigint | number
    template_name: string
    source: $Enums.test_templates_source
    created_at?: Date | string | null
    board_id: number
    test_type: $Enums.test_templates_test_type
    timing_type: $Enums.test_templates_timing_type
    time_limit?: number | null
    configuration: string
    active?: boolean | null
  }

  export type user_rolesCreateManyUsersInput = {
    role_id: number
  }

  export type student_achievementsCreateManyUserInput = {
    achievement_id: bigint | number
    unlocked_at?: Date | string | null
    progress?: number
  }

  export type study_groupsCreateManyTutorInput = {
    group_id?: bigint | number
    group_name: string
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type group_membersCreateManyStudentInput = {
    group_id: bigint | number
    joined_at?: Date | string | null
  }

  export type subject_masteryCreateManyUserInput = {
    subject_id: number
    mastery_level?: number
    total_questions_attempted?: number
    correct_answers?: number
    last_test_date?: Date | string | null
  }

  export type activity_logCreateManyUserInput = {
    activity_id?: bigint | number
    activity_type: string
    xp_earned?: number
    details?: string | null
    created_at?: Date | string | null
  }

  export type student_rewardsCreateManyUserInput = {
    reward_id: bigint | number
    purchased_at?: Date | string | null
  }

  export type student_guardiansCreateManyGuardianInput = {
    relationship_id?: bigint | number
    student_id: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_guardiansCreateManyStudentInput = {
    relationship_id?: bigint | number
    guardian_id: bigint | number
    relationship_type: $Enums.GuardianRelationType
    status?: $Enums.GuardianRelationStatus
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type test_assignmentsCreateManyAssignerInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    group_id?: bigint | number | null
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type test_assignmentsCreateManyStudentInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    assigned_by: bigint | number
    group_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type questionsUpdateWithoutUsersInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    subtopics?: subtopicsUpdateOneRequiredWithoutQuestionsNestedInput
    question_set_items?: question_set_itemsUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateWithoutUsersInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subtopic_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    question_set_items?: question_set_itemsUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutUsersInput = {
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subtopic_id?: IntFieldUpdateOperationsInput | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_text_plain?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    correct_answer_plain?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_plain?: StringFieldUpdateOperationsInput | string
    difficulty_level?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type question_setsUpdateWithoutCreatorInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    question_set_items?: question_set_itemsUpdateManyWithoutQuestion_setNestedInput
    test_plan_links?: test_plan_question_setsUpdateManyWithoutQuestion_setNestedInput
  }

  export type question_setsUncheckedUpdateWithoutCreatorInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    question_set_items?: question_set_itemsUncheckedUpdateManyWithoutQuestion_setNestedInput
    test_plan_links?: test_plan_question_setsUncheckedUpdateManyWithoutQuestion_setNestedInput
  }

  export type question_setsUncheckedUpdateManyWithoutCreatorInput = {
    set_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_executionsUpdateWithoutUsersInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    test_plans?: test_plansUpdateOneRequiredWithoutTest_executionsNestedInput
  }

  export type test_executionsUncheckedUpdateWithoutUsersInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_executionsUncheckedUpdateManyWithoutUsersInput = {
    execution_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: Enumtest_executions_statusFieldUpdateOperationsInput | $Enums.test_executions_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_data?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_plansUpdateWithoutStudentInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutStudentInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateManyWithoutStudentInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }

  export type test_plansUpdateWithoutPlannerInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    study_groups?: study_groupsUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutPlannerInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    study_groups?: study_groupsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateManyWithoutPlannerInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }

  export type test_templatesUpdateWithoutUsersInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    test_plans?: test_plansUpdateManyWithoutTest_templatesNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_templatesNestedInput
  }

  export type test_templatesUncheckedUpdateWithoutUsersInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    test_plans?: test_plansUncheckedUpdateManyWithoutTest_templatesNestedInput
  }

  export type test_templatesUncheckedUpdateManyWithoutUsersInput = {
    template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_name?: StringFieldUpdateOperationsInput | string
    source?: Enumtest_templates_sourceFieldUpdateOperationsInput | $Enums.test_templates_source
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_templates_test_typeFieldUpdateOperationsInput | $Enums.test_templates_test_type
    timing_type?: Enumtest_templates_timing_typeFieldUpdateOperationsInput | $Enums.test_templates_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    configuration?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type user_rolesUpdateWithoutUsersInput = {
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type student_achievementsUpdateWithoutUserInput = {
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    achievements?: achievementsUpdateOneRequiredWithoutStudent_achievementsNestedInput
  }

  export type student_achievementsUncheckedUpdateWithoutUserInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type student_achievementsUncheckedUpdateManyWithoutUserInput = {
    achievement_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type study_groupsUpdateWithoutTutorInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: usersUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateWithoutTutorInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: usersUncheckedUpdateManyWithoutStudent_groupsNestedInput
    members?: group_membersUncheckedUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateManyWithoutTutorInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type study_groupsUpdateWithoutStudentsInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutor?: usersUpdateOneRequiredWithoutTutor_groupsNestedInput
    members?: group_membersUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateWithoutStudentsInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: group_membersUncheckedUpdateManyWithoutGroupNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutGroupNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutStudy_groupsNestedInput
  }

  export type study_groupsUncheckedUpdateManyWithoutStudentsInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersUpdateWithoutStudentInput = {
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: study_groupsUpdateOneRequiredWithoutMembersNestedInput
  }

  export type group_membersUncheckedUpdateWithoutStudentInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersUncheckedUpdateManyWithoutStudentInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subject_masteryUpdateWithoutUserInput = {
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subjects?: subjectsUpdateOneRequiredWithoutSubject_masteryNestedInput
  }

  export type subject_masteryUncheckedUpdateWithoutUserInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subject_masteryUncheckedUpdateManyWithoutUserInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    mastery_level?: IntFieldUpdateOperationsInput | number
    total_questions_attempted?: IntFieldUpdateOperationsInput | number
    correct_answers?: IntFieldUpdateOperationsInput | number
    last_test_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUpdateWithoutUserInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUncheckedUpdateWithoutUserInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUncheckedUpdateManyWithoutUserInput = {
    activity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    activity_type?: StringFieldUpdateOperationsInput | string
    xp_earned?: IntFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsUpdateWithoutUserInput = {
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewards?: rewardsUpdateOneRequiredWithoutStudent_rewardsNestedInput
  }

  export type student_rewardsUncheckedUpdateWithoutUserInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsUncheckedUpdateManyWithoutUserInput = {
    reward_id?: BigIntFieldUpdateOperationsInput | bigint | number
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansUpdateWithoutGuardianInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: usersUpdateOneRequiredWithoutStudent_relationshipsNestedInput
  }

  export type student_guardiansUncheckedUpdateWithoutGuardianInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansUncheckedUpdateManyWithoutGuardianInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansUpdateWithoutStudentInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    guardian?: usersUpdateOneRequiredWithoutGuardian_relationshipsNestedInput
  }

  export type student_guardiansUncheckedUpdateWithoutStudentInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_guardiansUncheckedUpdateManyWithoutStudentInput = {
    relationship_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    relationship_type?: EnumGuardianRelationTypeFieldUpdateOperationsInput | $Enums.GuardianRelationType
    status?: EnumGuardianRelationStatusFieldUpdateOperationsInput | $Enums.GuardianRelationStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUpdateWithoutAssignerInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_plan?: test_plansUpdateOneRequiredWithoutAssignmentsNestedInput
    group?: study_groupsUpdateOneWithoutAssignmentsNestedInput
    student?: usersUpdateOneWithoutAssignments_receivedNestedInput
  }

  export type test_assignmentsUncheckedUpdateWithoutAssignerInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUncheckedUpdateManyWithoutAssignerInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUpdateWithoutStudentInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_plan?: test_plansUpdateOneRequiredWithoutAssignmentsNestedInput
    assigner?: usersUpdateOneRequiredWithoutAssignments_createdNestedInput
    group?: study_groupsUpdateOneWithoutAssignmentsNestedInput
  }

  export type test_assignmentsUncheckedUpdateWithoutStudentInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUncheckedUpdateManyWithoutStudentInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_achievementsCreateManyAchievementsInput = {
    user_id: bigint | number
    unlocked_at?: Date | string | null
    progress?: number
  }

  export type student_achievementsUpdateWithoutAchievementsInput = {
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    user?: usersUpdateOneRequiredWithoutAchievements_earnedNestedInput
  }

  export type student_achievementsUncheckedUpdateWithoutAchievementsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type student_achievementsUncheckedUpdateManyWithoutAchievementsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unlocked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type student_rewardsCreateManyRewardsInput = {
    user_id: bigint | number
    purchased_at?: Date | string | null
  }

  export type student_rewardsUpdateWithoutRewardsInput = {
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutStudent_rewardsNestedInput
  }

  export type student_rewardsUncheckedUpdateWithoutRewardsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_rewardsUncheckedUpdateManyWithoutRewardsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    purchased_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersCreateManyGroupInput = {
    student_id: bigint | number
    joined_at?: Date | string | null
  }

  export type test_assignmentsCreateManyGroupInput = {
    assignment_id?: bigint | number
    test_plan_id: bigint | number
    assigned_by: bigint | number
    student_id?: bigint | number | null
    due_date: Date | string
    status?: $Enums.TestAssignmentStatus
    created_at?: Date | string | null
  }

  export type usersUpdateWithoutStudent_groupsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUpdateManyWithoutTutorNestedInput
    group_memberships?: group_membersUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateWithoutStudent_groupsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    questions?: questionsUncheckedUpdateManyWithoutUsersNestedInput
    created_question_sets?: question_setsUncheckedUpdateManyWithoutCreatorNestedInput
    test_executions?: test_executionsUncheckedUpdateManyWithoutUsersNestedInput
    assigned_test_plans?: test_plansUncheckedUpdateManyWithoutStudentNestedInput
    planned_test_plans?: test_plansUncheckedUpdateManyWithoutPlannerNestedInput
    test_templates?: test_templatesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    achievements_earned?: student_achievementsUncheckedUpdateManyWithoutUserNestedInput
    tutor_groups?: study_groupsUncheckedUpdateManyWithoutTutorNestedInput
    group_memberships?: group_membersUncheckedUpdateManyWithoutStudentNestedInput
    subject_mastery?: subject_masteryUncheckedUpdateManyWithoutUserNestedInput
    student_progress?: student_progressUncheckedUpdateOneWithoutUserNestedInput
    activity_logs?: activity_logUncheckedUpdateManyWithoutUserNestedInput
    student_rewards?: student_rewardsUncheckedUpdateManyWithoutUserNestedInput
    guardian_relationships?: student_guardiansUncheckedUpdateManyWithoutGuardianNestedInput
    student_relationships?: student_guardiansUncheckedUpdateManyWithoutStudentNestedInput
    assignments_created?: test_assignmentsUncheckedUpdateManyWithoutAssignerNestedInput
    assignments_received?: test_assignmentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type usersUncheckedUpdateManyWithoutStudent_groupsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type group_membersUpdateWithoutGroupInput = {
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: usersUpdateOneRequiredWithoutGroup_membershipsNestedInput
  }

  export type group_membersUncheckedUpdateWithoutGroupInput = {
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_membersUncheckedUpdateManyWithoutGroupInput = {
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUpdateWithoutGroupInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_plan?: test_plansUpdateOneRequiredWithoutAssignmentsNestedInput
    assigner?: usersUpdateOneRequiredWithoutAssignments_createdNestedInput
    student?: usersUpdateOneWithoutAssignments_receivedNestedInput
  }

  export type test_assignmentsUncheckedUpdateWithoutGroupInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_assignmentsUncheckedUpdateManyWithoutGroupInput = {
    assignment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    student_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTestAssignmentStatusFieldUpdateOperationsInput | $Enums.TestAssignmentStatus
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_plansUpdateWithoutStudy_groupsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUpdateManyWithoutTest_plansNestedInput
    test_templates?: test_templatesUpdateOneWithoutTest_plansNestedInput
    exam_boards?: exam_boardsUpdateOneRequiredWithoutTest_plansNestedInput
    student?: usersUpdateOneRequiredWithoutAssigned_test_plansNestedInput
    planner?: usersUpdateOneRequiredWithoutPlanned_test_plansNestedInput
    assignments?: test_assignmentsUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateWithoutStudy_groupsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
    test_executions?: test_executionsUncheckedUpdateManyWithoutTest_plansNestedInput
    assignments?: test_assignmentsUncheckedUpdateManyWithoutTest_planNestedInput
    question_set_links?: test_plan_question_setsUncheckedUpdateManyWithoutTest_planNestedInput
  }

  export type test_plansUncheckedUpdateManyWithoutStudy_groupsInput = {
    test_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    board_id?: IntFieldUpdateOperationsInput | number
    test_type?: Enumtest_plans_test_typeFieldUpdateOperationsInput | $Enums.test_plans_test_type
    timing_type?: Enumtest_plans_timing_typeFieldUpdateOperationsInput | $Enums.test_plans_timing_type
    time_limit?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_by?: BigIntFieldUpdateOperationsInput | bigint | number
    planned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuration?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Exam_boardsCountOutputTypeDefaultArgs instead
     */
    export type Exam_boardsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Exam_boardsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsCountOutputTypeDefaultArgs instead
     */
    export type QuestionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Question_setsCountOutputTypeDefaultArgs instead
     */
    export type Question_setsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Question_setsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectsCountOutputTypeDefaultArgs instead
     */
    export type SubjectsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtopicsCountOutputTypeDefaultArgs instead
     */
    export type SubtopicsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtopicsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Test_plansCountOutputTypeDefaultArgs instead
     */
    export type Test_plansCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Test_plansCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Test_templatesCountOutputTypeDefaultArgs instead
     */
    export type Test_templatesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Test_templatesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicsCountOutputTypeDefaultArgs instead
     */
    export type TopicsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementsCountOutputTypeDefaultArgs instead
     */
    export type AchievementsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RewardsCountOutputTypeDefaultArgs instead
     */
    export type RewardsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RewardsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Study_groupsCountOutputTypeDefaultArgs instead
     */
    export type Study_groupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Study_groupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use exam_boardsDefaultArgs instead
     */
    export type exam_boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = exam_boardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questionsDefaultArgs instead
     */
    export type questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use question_set_itemsDefaultArgs instead
     */
    export type question_set_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = question_set_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use question_setsDefaultArgs instead
     */
    export type question_setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = question_setsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subjectsDefaultArgs instead
     */
    export type subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = subjectsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subtopicsDefaultArgs instead
     */
    export type subtopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = subtopicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use test_executionsDefaultArgs instead
     */
    export type test_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = test_executionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use test_plan_question_setsDefaultArgs instead
     */
    export type test_plan_question_setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = test_plan_question_setsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use test_plansDefaultArgs instead
     */
    export type test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = test_plansDefaultArgs<ExtArgs>
    /**
     * @deprecated Use test_templatesDefaultArgs instead
     */
    export type test_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = test_templatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use topicsDefaultArgs instead
     */
    export type topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = topicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_rolesDefaultArgs instead
     */
    export type user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use difficulty_levelsDefaultArgs instead
     */
    export type difficulty_levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = difficulty_levelsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use student_progressDefaultArgs instead
     */
    export type student_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = student_progressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use achievementsDefaultArgs instead
     */
    export type achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = achievementsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use student_achievementsDefaultArgs instead
     */
    export type student_achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = student_achievementsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rewardsDefaultArgs instead
     */
    export type rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rewardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use student_rewardsDefaultArgs instead
     */
    export type student_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = student_rewardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subject_masteryDefaultArgs instead
     */
    export type subject_masteryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = subject_masteryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use activity_logDefaultArgs instead
     */
    export type activity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = activity_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use level_configDefaultArgs instead
     */
    export type level_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = level_configDefaultArgs<ExtArgs>
    /**
     * @deprecated Use study_groupsDefaultArgs instead
     */
    export type study_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = study_groupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use student_guardiansDefaultArgs instead
     */
    export type student_guardiansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = student_guardiansDefaultArgs<ExtArgs>
    /**
     * @deprecated Use group_membersDefaultArgs instead
     */
    export type group_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = group_membersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use test_assignmentsDefaultArgs instead
     */
    export type test_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = test_assignmentsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}